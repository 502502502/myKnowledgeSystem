#### 1、JavaEE架构中的容器

+ Web容器：提供了处理HTTP请求和响应的环境，管理Servlet和JSP等Web组件的生命周期
+ EJB容器：管理EJB实例的生命周期、事务管理、安全性和并发访问控制等任务。
+ 应用程序客户端容器：提供与服务器的远程通信、访问企业级资源和处理分布式事务等功能
+ JMS容器：提供了将消息发送到队列或主题，以及接收和处理消息的功能



#### 2、 JavaEE架构中的常用技术

+ Servlet：处理Web请求和响应的组件
+ JSP：生成动态Web页面的技术
+ EJB：开发企业级应用程序的服务器端组件模型
+ JPA：进行对象关系映射，提供了一种简化的方式来将Java对象映射到关系数据库中的表结构
+ JDBC：提供了一组标准的Java接口和类，用于连接数据库、执行SQL语句和处理查询结果
+ JMS：提供了一种可靠、异步和解耦的方式来发送、接收和处理消息



#### 3、多层应用体系结构的构成和各个部分的功能

+ 表现层： 用户与应用进行交互的界面层，负责接收用户请求和向用户展示数据和结果
+ 应用层： 处理业务逻辑的核心层，负责执行具体的应用逻辑并协调其他层的工作
+ 业务逻辑层： 业务逻辑层是应用程序的核心，包含了业务流程和规则的实现
+ 数据访问层： 数据访问层负责与底层数据存储交互，封装了对数据的访问和操作
+ 数据库层： 数据库层是实际存储数据的物理层，包括各种类型的数据库系统



#### 4、 Servlet及其生命周期

开发Web应用的一种组件，它可以接收和处理来自客户端的HTTP请求，并生成相应的HTTP响应。

**生命周期：**

+ 初始化： Servlet容器第一次加载Servlet时，调用init()方法初始化
+ 服务： servlet每接收到一个HTTP请求，调用service()方法来处理
+ 处理请求：根据请求类型的不同，调用相应的处理方法来处理
+ 销毁： Servlet容器关闭或重启，调用destroy()方法进行销毁



#### 5、JAX-RS开发RESTful Web Service的步骤

+ 创建一个服务接口，然后实现这个接口
+ 对服务进行发布，定义POST的响应方法
+ 客户端访问



#### 6、JSP 工作原理

+ 客户端发送请求：发送一个HTTP请求到服务器。

+ 服务器接收请求：将请求交给Web容器（如Tomcat）进行处理。
+ JSP编译：Web容器首先会检查请求的URL是否对应一个JSP页面。如果是JSP页面，容器会将它翻译成一个Servlet类。
+ Servlet执行：Servlet类被实例化并执行。
+ 动态内容生成：在Servlet中，可以使用Java代码和JSP标签（<% %>）来生成动态内容。J
+ 动态内容输出：Servlet生成的动态内容会以HTML的形式返回给Web容器。
+ Web容器响应请求：Web容器将最终生成的HTML响应发送回客户端



#### 7、JSP页面中如何调用Servlet

+ Form表单提交

+ jsp:include

+ jsp:forward



#### 8、什么是JavaBean，作用是什么，JSP页面中如何调用

用JavaBean将功能、处理、值、数据库访问和其他任何可以用java代码创造的对象进行打包

**作用：**提供调用

**JSP调用：**

+ <jsp:useBean>
+  <jsp:setProperty>
+ <jsp:getProperty>



#### 9、JSF的特点和作用、生命周期

Web页面的构建，利用EL表达式等技术实现了状态保存以及和后台组件的交互



**生命周期：**

+ 还原视图： 根据请求中的视图ID来还原之前的状态或创建新的视图。
+ 应用请求值： 将请求中的参数和值应用到对应的组件上
+ 处理验证： 对组件的值进行验证，包括验证是否满足输入要求、数据类型等
+ 更新模型值： 将经过验证的组件值更新到后端的数据模型中
+ 调用应用程序： 根据用户的操作调用相关的业务逻辑方法或事件处理方法
+ 呈现响应： 将渲染响应，生成最终的HTML页面，并发送给客户端进行显示



#### 10、托管Been及其生命周期，作用域

**托管Been：**JSF使用的JavaBeen

**生命周期：**由JAVA EE服务器管理，在其作用域开始时被创建，而在其作用域结束时被销毁。

**作用域：**视图作用域、请求作用域、会话作用域、应用程序作用域



#### 11、JSF如何实现页面间的导航

使用静态导航与动态导航

**静态导航：**单击特定按钮总是选择固定的JSF页面来呈现响应，为每个桉钮赋予一个action特性

**动态导航：**页面流不仅取决于用户单击了哪个按钮, 也取决于用户的输入。JSF通过将navigation-rule条目添加到faces-config.xml中来实现将逻辑结果映射到实际页面



#### 12、命名服务、目录服务、JNDI

根据名称获取对象的一种服务；

可以根据对象的属性搜索对象的服务；

统一的形式对服务进行封装，提供一致的访问接口；



#### 13、 JNDI 的作用，本地访问，远程访问

**作用：**

+ 名称解析和查找
+ 配置管理
+ 分布式应用程序开发



**本地访问：**当资源和应用程序在同一个JVM中运行时，可以使用本地访问；当资源和应用程序位于不同的物理节点上时，需要使用远程访问。



#### 14、消息、消息服务、消息服务类型

**消息：**在应用程序之间传递的数据包

**消息服务：**实现消息传递的一种架构或模式

**类型：**

+ 点对点模型
+ 发布/订阅模型
+ 请求/应答模型



#### 15、 JMS 的两种消息传递模型

**点对点模型：** 消息是一对一的关系，一个消息只被一个接收者消费。

**发布/订阅模型：** 消息是一对多的关系，一个消息可以被多个接收者消费。



#### 16、ORM 和ORM映射的基本原则

**ORM：**在程序中实现对象和关系数据库之间的映射

**基本原则：**

+ 对象关系映射：每个对象对应数据库中的一个表，对象的属性对应表的列，对象的实例对应表的行。
+ 建立映射规则：使用注解或配置文件来定义对象和数据库之间的映射规则。
+ 惰性加载：在查询对象时，只加载需要的数据，并且在需要访问关联数据时再进行加载。
+ 事务管理：提供了事务管理的功能，以确保数据库操作的一致性和完整性。
+ 缓存机制：通过缓存查询结果，当下次再进行相同的查询时，可以直接从缓存中获取



#### 17、JMS消息发送的过程

+ 获得一个JBoss上下文
+ 创建连接工厂
+ 创建一个连接
+ 创建一个会话
+ 通过JNDI查找Queue或者Topic
+ 创建消息的生产者
+ 创建消息实例
+ 发送信息



#### 18、接收JMS 消息有哪几种方式

+ 同步接收

+ 异步接受



#### 19、JPA 中实体的生命周期

+ 新建状态：实体对象还没有与数据库中的数据相关联，也没有持久化标识
+ 托管状态：被持久化上下文管理后，它进入了托管状态。在托管状态下，实体对象与数据库中的数据相对应，任何对其属性的修改都会被自动同步到数据库。
+ 游离状态： 当托管状态的实体对象与持久化上下文分离后，它进入了游离状态。不再由持久化上下文跟踪和管理，实体对象的更改不会自动同步到数据库，仍然保留着与数据库相关的标识信息。
+ 删除状态： 被标记为删除后，进入删除状态。仍然可以在事务中进行操作和修改，但将在事务提交后从数据库中被删除



#### 20、关联关系、关联方向

**四种关联关系：**一对一、一对多、多对一、多对多
**两种关联方向：**单向关联、双向关联
总共构成七种关系，没有多对一双向



#### 21、一对一单向和多对多双向关系如何使用

**一对一单向关系：** 一对一单向关系表示两个实体之间的关联，其中一个实体引用另一个实体，而另一个实体没有引用回来。

+ 使用标注：使用@OneToOne注解来建立一对一关系。在拥有外键的实体类中使用@JoinColumn注解，指定外键列。

+ 设计数据库：在数据库中，可以为Person表增加一个外键列address_id，指向Address表的主键。

**多对多双向关系：** 多对多双向关系表示两个实体之间互相引用，彼此都具有对方的集合对象。

+ 使用标注：在两个实体类中，分别使用@ManyToMany注解来建立多对多关系。通过在一方实体中使用@JoinTable注解，指定关联表的名称和列。

+ 设计数据库：在数据库中，需要创建一个关联表student_course，包含两个外键列student_id和course_id，分别对应Student表和Course表的主键。



#### 22、JPA 中的事务管理

**声明式事务管理：**JPA支持使用注解或XML配置的方式进行声明式事务管理。

**编程式事务管理：**以获取`EntityManager`对象，并通过手动控制`EntityTransaction`来管理事务。

**事务属性设置：**设置事务的属性，如事务的隔离级别、传播行为和超时时间

**异常处理：**当出现数据库操作异常时，事务管理根据事务的设置和异常类型来决定是提交事务还是回滚事务。



#### 23、@Inject含义

将该对象实例注入（inject）到当前类中



#### 24、EJB运行原理

+ 定义EJB接口
+ 编写实现接口的EJB实现类。
+ 部署到服务器中，将JNDI名称发布。
+ 编写客户端程序，并将接口拷贝给客户端，通过JNDI查找获得EJB，客户端调用EJB。
+ 客户端向服务器发起连接，在服务器上寻找相应的JNDI名称，如果找到，返回一个对象。
+ 客户端将该对象强制转换为接口类型。
+ 客户端调用接口中的方法，实际上调用了服务器端EJB实现类内的方法



#### 25、有状态会话 Bean 生命周期

在Web应用程序中管理用户会话状态

**生命周期：**

+ 创建阶段：当客户端发起一个会话请求时，容器会为该会话创建一个新的实例。
+ 激活阶段：在创建阶段之后，会话Bean进入激活状态。
+ 会话阶段：会话Bean与客户端之间进行交互的主要时间段。
+ 钝化阶段：当会话Bean暂时不再活动一段时间后，容器可能会选择将其钝化，保存到磁盘。
+ 活化阶段：再次使用钝化的会话Bean，容器会将其从存储介质中加载并重新激活
+ 销毁阶段：当会话Bean不再需要或者应用程序关闭时，容器会销毁会话Bean实例



#### 26、单例会话 Bean 中并发管理的两种方法特点

**CMC：** CMC 是由容器管理的并发管理策略。

**特点：**

- 容器控制：开发人员不需要显式编码处理并发问题。
- 事务范围：容器会根据事务的隔离级别和并发配置来控制对持久化单元的访问。
- 并发配置：开发人员可以配置容器提供的并发参数，如最大并发数、超时时间等
- 采用悲观并发控制策略



**BMC：** BMC 是由开发人员手动管理的并发管理策略。

**特点：**

- 手动控制
- 精细控制
- 灵活性



#### 27、无状态会话Been及其生命周期

不维持和客户端的会话状态

**生命周期：**

+ 不存在状态
+ 池状态
+ 调用状态



#### 28、消息驱动 Bean及其生命周期

处理异步消息通信

**生命周期：**

+ 创建： 当应用程序部署到Java EE容器中时，容器会根据配置信息创建消息驱动Bean的实例
+ 初始化： 创建实例后，执行初始化方法
+ 监听：初始化完成后，开始监听消息队列或主题
+ 处理消息： 监听到消息后，调用消息处理方法来处理
+ 销毁： 当应用程序停止或卸载时，容器会销毁消息驱动Bean的实例



#### 29、设计并实现一个无状态会话Bean

```java
@Stateless
public class CPUMonitorBean {

    @PostConstruct
    public void initialize() {
        System.out.println("CPUMonitorBean 初始化...");
    }

    @PreDestroy
    public void cleanup() {
        System.out.println("CPUMonitorBean 销毁...");
    }

    public double calculateCPUUtilization() {
        // 模拟计算CPU利用率的随机程序
        double utilization = Math.random() * 100;
        return utilization;
    }
}
```

```java
public class RemoteClient {
    public static void main(String[] args) throws NamingException {
        InitialContext context = new InitialContext();
        CPUMonitorBean cpuMonitor = (CPUMonitorBean) context.lookup("java:global/your-app-name/CPUMonitorBean");
        
        double utilization = cpuMonitor.calculateCPUUtilization();
        System.out.println("CPU利用率：" + utilization);
    }
}
```



#### 30、设计并实现一个单例会话Bean

```java
@Singleton
public class WebsiteVisitCounterBean {
  
    private int visitCount;
  
    @PostConstruct
    public void initialize() {
        visitCount = 0;
    }
  
    public synchronized void incrementVisitCount() {
        visitCount++;
    }
  
    public synchronized int getVisitCount() {
        return visitCount;
    }
}
```



#### 31、设计并实现一个异步调用的会话Bean

```java
@Singleton
public class PerformanceDataCollectorBean {

    @Asynchronous
    public void collectPerformanceData(String machineId) {
        // 在这里执行异步操作，例如发送请求到其他机器并采集性能数据
        // 可以使用异步方式进行网络请求或者其他耗时操作
        // 你可以自定义具体的逻辑来采集性能数据
        System.out.println("正在采集机器 " + machineId + " 的性能数据...");
        // 异步操作完成后会返回线程给容器
    }
}
```



#### 32、企业应用可以采用几种安全策略

访问控制和身份验证

安全传输

数据加密

安全管理

- 定义安全策略、用户和角色等的容器级别配置。
- 记录安全事件和操作

防范攻击：

+ 对用户输入进行过滤和转义，防止恶意注入脚本；
+ 使用令牌验证请求的来源；
+ 使用相应的响应头来防止页面被嵌入到恶意网站中



