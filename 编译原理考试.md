### 一、题型

#### 1、设计文法

![image-20230624122046800](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624122046800.png)

#### 2、最左、最右推导

![image-20230624121951585](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624121951585.png)

#### 3、证明二义性

![image-20230624124408311](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624124408311.png)

#### 4、计算First集、Follow集、Select集

计算一个文法的First集时，需要按照以下规则进行推导：

1. 如果符号X是一个终结符号，则First(X) = {X}。
2. 如果符号X是一个非终结符号，并且存在一条产生式X -> Y1 Y2 ... Yk，则将Y1的First集中除去空串(epsilon)的所有终结符号加入到First(X)中，并且如果Y1可以推导出空串，则将Y2的First集中除去空串的终结符号也加入到First(X)中。依此类推，直到遇到一个Yi不能推导出空串。
3. 如果符号X是一个非终结符号，并且存在一个产生式X -> epsilon，则将epsilon加入到First(X)中。



Follow集可以通过以下步骤进行计算：

1. 对于文法的开始符号S，将"#"（表示输入串结束）添加到Follow(S)中。
2. 遍历所有的产生式A -> αBβ，对于每一个非终结符B: a. 将First(β)中不含有ε的符号添加到Follow(B)中。 b. 如果ε ∈ First(β)，则将Follow(A)中的所有符号添加到Follow(B)中。
3. 重复步骤2，直到没有新的符号被添加到任何的Follow集合中。



计算一个产生式的Select集合，需要考虑以下几个规则：

1. 如果候选项开始符号可以推导出空串ε，那么将 ε 加入Select集合中。
2. 对于候选项开始符号的First集合中不包含ε的每个终结符号X，将X加入Select集合中。
3. 如果候选项开始符号的First集合中包含ε，那么将Follow集合中的每个终结符号X加入Select集合中。



![img](https://ningct.oss-cn-hangzhou.aliyuncs.com/v2-673e1c351ebe9a49376af9a19111fc30_r.jpg)

#### 5、判断是否满足LL(1)

1、对于文法中的每个产生式 A → α，如果存在另一个产生式 A → β，则需要满足 First(α) ∩ First(β) = ∅。

2、对于文法中的每个非终结符号 A，如果存在产生式 A → ε，则需要满足 First(α) ∩ Follow(A) = ∅，其中α表示A的候选项。

3、任何一个非终极符产生式的 predict 集合没有交集



#### 6、正则式转NFA

![image-20230624164339570](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624164339570.png)

#### 7、NFA转DFA

![image-20230624164420591](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624164420591.png)

#### 8、DFA最小化

![image-20230624164742984](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624164742984.png)

#### 9、LLI(分析)

![img](https://ningct.oss-cn-hangzhou.aliyuncs.com/v2-33c3118117f2db8f064f16361238f2a1_r.jpg)

![image-20230624171203638](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624171203638.png)



#### 10、消除左递归

![image-20230624195558851](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624195558851.png)

![image-20230624195616753](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624195616753.png)

![image-20230624195816443](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624195816443.png)

#### 11、中间代码生成

![image-20230625110642164](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625110642164.png)

![image-20230625110700480](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625110700480.png)

![image-20230625110710989](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625110710989.png)

![image-20230625110719362](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625110719362.png)

![image-20230625110729727](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625110729727.png)

#### 12、例题

![image-20230624203940516](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624203940516.png)

![image-20230624204641078](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624204641078.png)

![image-20230624205003061](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624205003061.png)

![image-20230624205045134](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624205045134.png)

![image-20230624205450317](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624205450317.png)

![image-20230624205624248](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624205624248.png)

![image-20230624210244126](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624210244126.png)

![image-20230624210758222](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624210758222.png)

![image-20230624211933295](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624211933295.png)

![image-20230624213940660](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230624213940660.png)



### 二、真题

#### 1、2014

> 高级程序设计语言的实现方式包含哪些？

编译实现方式，解释实现方式

> 给出能自动识别只有奇数个 a 和奇数个 b 组成的所有符号串的最简 DFA

![image-20230625150702983](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625150702983.png)

> 从分析能力和可归前缀自动机状态数目比较一下 LR(0)、SLR(1)、LR(1)和 LALR(1)四种语 法分析方法

分析能力：LR(1)>LALR(1)>SLR(1)>LR(0) 

可归活前缀自动机状态数目：LR(0)= SLR(1)= LALR(1)< LR(1)

> 设数组类型 Array of [1..10] of Array [1..100] of integer，请给出类型的类型表信息

![image-20230625150429621](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625150429621.png)

> 在语义分析过程中，当处理函数调用语句时，都需要做哪些语义检查？

​	检查函数是否为函数标识符、检查形参类型与实参类型是否相容、检查形参个数与实参个 数是否相等

> 设有一个类 C 嵌套语言编写的程序如下：
>
>  void main () { 
>
> ​	int P(int x) 
>
> ​	Begin 
>
> ​			If X > 0 Then 
>
> ​					Return P(X-1) + X; 
>
> ​			Else 
>
> ​				Return 0; 
>
> End
>
> ​	 Begin P(100);
>
> End 
>
> 请问：当 P 被第 50 次调用而进入函数体后， 
>
> （1） 在内存中为该程序分配的栈区存在多少个活动记录？ 
>
> （2） 当前活动记录的局部 Display 表中有几条记录，都记录了什么信息

（1）51 

（2）有两条记录，分别是 main 函数活动记录的首地址和 P 函数活动记录的首地址

> 高级程序设计语言可以分为嵌套式语言（如 PASCAL 语言）和并列式语言两大类（如 C 语言）两大类，请分析在编译过程中，对于嵌套式语言的处理和并列式语言的处理都有哪些 区别？

符号表的管理和抽象地址映射两方面。

（1）对于符号表的局部化处理，嵌套式语言使用了 Scope 栈，Scope 栈中的 Scope[L]指向 L 层符号表的起始地址；并列式语言可以不使用 Scope 栈，用两个变量分别存储 0 层和 1 层 的符号表地址即可。 

（2）分配抽象地址的时候，并列式语言中并列的分程序可以共用 

（3）在抽象地址映射过程中，对于并列式语言，在活动记录可以不为变量访问环境分配空 间，使用两个寄存器分别存储静态区和当前活动记录首地址就可以完成抽象地址到物理地址 的映射；对于嵌套式语言，在活动记录必须为变量访问环境分配空间



#### 2、2015

> 简述典型编译器的构成以及各个部分的功能和作用

1. 词法分析器（Lexical Analyzer）：将源代码分割为一系列词法单元（Tokens），如标识符、关键字、运算符等。
2. 语法分析器（Parser / Syntax Analyzer）：根据语法规则分析词法单元的排列顺序，将其组织成抽象语法树（Abstract Syntax Tree）。
3. 语义分析器（Semantic Analyzer）：对抽象语法树进行语义检查，包括类型检查、作用域检查等，并生成符号表（Symbol Table）。
4. 中间代码生成（Intermediate Code Generator）：将抽象语法树转换为中间代码表示，如三地址码、四元式等。
5. 代码优化器（Code Optimizer）：对中间代码进行优化，提高程序性能和效率，如常量折叠、无用代码删除等。
6. 代码生成器（Code Generator）：将优化后的中间代码转换为目标机器代码，包括指令选择、寄存器分配等。
7. 目标机器代码（Target Machine Code）：生成可执行的目标机器代码，供计算机系统执行。

> 举例说明乔姆斯基文法分类的依据，以及各类文法表示能力的区别

无限制文法: 没有任何限制，可以描述任意的形式语言。规则形式是 α → β，其中 α 和 β 是任意字符串。具备最高的表达能力。

上下文有关文法: 对句子的生成和推导施加了一些限制。规则形式是 α A β → α γ β，其中 A 是一个非终结符，α、β、γ 是任意字符串，且 γ 非空。比上下文无关文法更强大，但仍不足以完全描述自然语言。

上下文无关文法: 广泛应用于编程语言语法定义。规则形式是 A → γ，其中 A 是一个非终结符，γ 是任意字符串。足够描述大部分编程语言的语法。

正则文法: 规则形式包括 A → ε、A → aB 或 A → a，其中 A 和 B 是非终结符，a 是终结符，ε 表示空字符串。表达能力较弱，适合用于词法分析器中的词法规则定义

> 设计一个上下文无关发文 G，描述语言{a$^i$ b$^i$ c$^k$ d$^j$e$^j$ |i>=0;j>=1,k>=2}

![image-20230625152500512](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625152500512.png)

> 简述语义分析与语法分析的区别，并列举三种语义错误

语法分析是检查是不是符合语法要求，而语义分析是检查语句的含义是否有误。 

+ If 的条件语句不是 bool 类型 
+ 类型赋值错误 
+ 变量未声明错误

> **已知文法：**
>
> S->a|^|(T)
>
> T->T,S|S
>
> 分析句型（T,(^,a))，求全部的短语、直接短语和句柄

短语：子树的末端结点形成的符号串。

简单子树：只有一层分支的子树。

直接短语（简单短语）：简单子树的末端结点形成的符号串。

句柄：子树中最左边的那棵只有父子两代的子树的所有叶结点自左至右排列起来，就是该句型的句柄

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625155737725.png" alt="image-20230625155737725" style="zoom:67%;" />

> 使用驻留法对于程序进行语义分析，请画出标识符的符号表内部表示并填写各项存储内容。
>
> 设函数 f 所在层，形参的起始 偏移为 off0，整型变量占一个单元，实型变量占两个单元。
>
> ```c
> const float x = 1000;
> int y = 20; 
> int f(int x, float y)
> { 
>     return x + 1; 
> } 
> name kind type level off access/class value/param code size forward
> ```
>
> 

![image-20230625173729693](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625173729693.png)



#### 3、2016

> DFA 和 NFA 有哪些主要的区别？

1. 状态转移规则：
   - DFA：对于给定的输入符号，DFA 的每个状态只能进行确定的状态转移，即一个输入符号只能对应到一个下一个状态。
   - NFA：对于给定的输入符号，NFA 的每个状态可以进行多个可能的状态转移，即一个输入符号可以对应到多个下一个状态，或者可以不进行状态转移（ε转移）。
2. ε转移：
   - DFA：DFA 不支持ε转移，即不能通过空输入符号进行状态转移。
   - NFA：NFA 支持ε转移，即可以通过空输入符号进行状态转移。
3. 状态接受性：
   - DFA：DFA 的状态有两种类型，接受状态和非接受状态。只有在达到接受状态时，DFA 才接受输入，否则拒绝输入。
   - NFA：NFA 的状态也有两种类型，接受状态和非接受状态。但是，NFA 可以根据任意一条路径上的状态是否为接受状态来接受输入，只要存在一条路径使得最终状态为接受状态即可。
4. 状态确定性：
   - DFA：DFA 是确定性的，即对于给定的输入符号和当前状态，下一个状态是唯一确定的。
   - NFA：NFA 是非确定性的，即对于给定的输入符号和当前状态，下一个状态可能不确定。

> 过程活动记录 AR 应包含哪些内容



> 已知文法 G[S]，请写出它的递归下降 C 语言分析程序
>
> ![image-20230625180058217](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625180058217.png)

![image-20230625180142012](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625180142012.png)

> 假设程序点的层数和偏移为(L,off0)。试写出各个程序点 的层数和偏移的变化情况。
>
> （d 为第一个形参可用区距，int 占一个单元， float 占两个单元）
>
> **![image-20230625180504334](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625180504334.png)**

类型声明不改变偏移，只有变量声明改变偏移

![image-20230625180523712](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625180523712.png)

### 三、经典例题

#### 1、驻留法全局符号表

![image-20230625211825161](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625211825161.png)

![image-20230625211737074](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625211737074.png)

#### 2、中间代码生成、优化

![image-20230625204909948](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625204909948.png)

![image-20230625204942099](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625204942099.png)

![image-20230625204956028](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625204956028.png)

#### 3、语言、文法、表达式

![image-20230625213829304](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625213829304.png)

![image-20230625213921759](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625213921759.png)

![image-20230625214043960](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625214043960.png)

![image-20230625214108023](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625214108023.png)



#### 4、NFA转DFA、确定化、最小化

> ![image-20230625212119054](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625212119054.png)



![image-20230625212051667](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625212051667.png)

#### 5、LL(1)分析：提公因，消除左递归->Predict

> <img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625213402636.png" alt="image-20230625213402636" style="zoom:67%;" />

![image-20230625213421317](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625213421317.png)

![image-20230625213433191](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625213433191.png)

![image-20230625213444341](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625213444341.png)



#### 6*、活动记录



#### 7、语法树、句型、短语、句柄

> S->a|^|(T)
>
> T->T,S|S
>
> 分析句型（T,(^,a))，求全部的短语、直接短语和句柄

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625155737725.png" alt="image-20230625155737725" style="zoom:67%;" />

#### 8*、结构体内部表示

![image-20230625210540349](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625210540349.png)

#### 9、递归下降分析：提公因，消除左递归->Predict

> <img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625180058217.png" alt="image-20230625180058217" style="zoom:67%;" />

![image-20230625180142012](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625180142012.png)

#### 10、提公因、消除左递归

> <img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625212229937.png" alt="image-20230625212229937" style="zoom: 67%;" />

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625212355151.png" alt="image-20230625212355151" style="zoom:67%;" />



#### 11、二义性文法判断

> <img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625212414569.png" alt="image-20230625212414569" style="zoom:67%;" />

![image-20230625211447190](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230625211447190.png)

