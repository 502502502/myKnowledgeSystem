### 一、词法分析

##### 1、实现思路

写出字符状态的有限状态机，对输入的源程序按照字符依次进行处理，根据当前状态和当前输入字符，计算下一个状态，将分词生成token结构，并在分析错误时报告错误字符的位置。

**核心数据结构：**

```c++
// Token 种类
typedef enum {
    ID,        //标识符
    RES,        //保留字
    NUM,        //数字
    SYM         //字符
} LexType;
// Token类
class Token {
public:
    string type;    // 类别
    string name;    // 信息
public:
    Token(string type, string name) {this->type = type; this->name = name; }
};
//保留字表
set<string> res = { "program","type","var","procedure","begin","end","array","of","record",
"if","then","else","fi","while","do","endwh","read","write","return","integer","char" };
```



##### 2、状态转换图DFA

![image-20230528120534031](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528120534031.png)

##### 3、程序流程图

![image-20230528123838941](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528123838941.png)



##### 4、核心代码

```c++

        switch (state) {
        case s0: { 
            // 开始状态
            string().swap(str);  // 初始化token缓存
            buffer = fgetc(fp);  
            if ((char)buffer == '\n') {  // 如果是'\n'行数+1
                line++;
                row = 1;
                break;
            }else if ((char)buffer == ' ' || buffer == 9) {  // 如果是' '或者是tab键跳过
                row++;
                break;
            }else if (isLetter((char)buffer)) {  // 如果是字母跳转s1状态
                str += (char)buffer;  
                row++;
                state = s1;
                break;
            }else if (isDigit((char)buffer)) {  // 如果是数字跳转s2状态
                str += (char)buffer; 
                row++;
                state = s2;
                break;
            }else if (isSingleDelimiter((char)buffer)) {  // 如果是单字符分界符跳转s3状态
                str = (char)buffer;  
                row++;
                state = s3;
                break;
            }else if ((char)buffer == ':') {  // 如果是':'跳转s4状态
                str = (char)buffer;  
                row++;
                state = s4;
                break;
            }else if ((char)buffer == '{') {  // 如果是'{'跳转s5状态
                state = s5;
                break;
            }
            else if ((char)buffer == '.') {  // 如果是'.'跳转s6状态
                str = (char)buffer;  
                row++;
                state = s6;
                break;
            }else if ((char)buffer == '\'') {  // 如果是'单引号'跳转s7状态
                row++;
                state = s7;
            }else {  
                state = s8; // 错误状态
                break;
            }
            break;
        }
        case s1: {
            // 字母开头
            while ((buffer = fgetc(fp)) != -1 && (isLetter((char)buffer) || isDigit((char)buffer)) && !feof(fp)) {
                str += (char)buffer;  
                row++;             
            }
            // 回退一个字符
            ungetc(buffer, fp);
            if (!isReserved(str)) { 
                // 是标识符
                token = new Token("ID", str);
            }else {
                //是保留字
                token = new Token("RES",upperToLower(str));
            }
            tokenList.push_back(*token);
            state = s0;
            break;
        }
        case s2: {
            // 数字开头
            while ((buffer = fgetc(fp)) != -1 && !feof(fp) && isDigit((char)buffer)) {
                str += (char)buffer;
                row++;
            }
            // 回退一个字符
            ungetc(buffer, fp);
            token = new Token("NUM", str);
            tokenList.push_back(*token);
            state = s0;
            break;
        }
        case s3: {
            // 单字符分界
            token = new Token("SYM", str);
            tokenList.push_back(*token);
            state = s0;
            break;
        }
        case s4: {
            // ：开头
            buffer = fgetc(fp);
            str += (char)buffer;
            row++;
            // 判断是否是赋值符号
            if ((char)buffer == '=') {
                token = new Token("SYM", str);
                tokenList.push_back(*token);
                state = s0;
            }
            else {
                state = s8;  // 跳转错误状态
            }
            break;
        }
        case s5: {
            // 注释{开头
            buffer = fgetc(fp);  
            while (!feof(fp) && (char)buffer != '}') {
                buffer = fgetc(fp);
            }
            //注释无法闭合
            if ((char)buffer != '}') {
                state = s8;
            }
            state = s0; 
            break;
        }
        case s6: {
            // .开头
            if (feof(fp) || (buffer = fgetc(fp)) != '.') {
                //程序结束
                token = new Token("SYM", ".");
                tokenList.push_back(*token);
                return tokenList;  // 程序结束
            }else {
                //数组范围..
                str += (char)buffer; 
                row++;
                token = new Token("SYM", str);
                tokenList.push_back(*token);
                state = s0;
            }
            break;
        }
        case s7: {
            // 字符'开头
            if ((buffer = fgetc(fp)) != -1 && !(isLetter((char)buffer) || isDigit((char)buffer))) {
                state = s8;
                break;
            }
            str += (char)buffer;  
            row++;                
            token = new Token("SYM", str);
            tokenList.push_back(*token);

            // 退出字符不是'单引号'
            buffer = fgetc(fp);
            if ((char)buffer != '\'') {
                state = s8;
                break;
            }
            state = s0;
            break;
        }
        case s8: {
            // 错误状态
            flag = true;
            printf("invalid character at (%d, %d)", line, row -1);
            return tokenList;
        }
        default:
            break;
        }
```



##### 5、运行结果

**测试源程序：**

```c
program p
type t = integer;
var t v1 ;
integer v2;
begin 
 read(v1);
 v1:=v1*10;
 v2:= 100;
 write(v1)
end.
```

**结果：**

![image-20230528112813707](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528112813707.png)

**生成的token序列：**

```txt
RES  program
ID   p
RES  type
ID   t
SYM  =
RES  integer
SYM  ;
RES  var
ID   t
ID   v1
SYM  ;
RES  integer
ID   v2
SYM  ;
RES  begin
RES  read
SYM  (
ID   v1
SYM  )
SYM  ;
ID   v1
SYM  :=
ID   v1
SYM  *
NUM  10
SYM  ;
ID   v2
SYM  :=
NUM  100
SYM  ;
RES  write
SYM  (
ID   v1
SYM  )
RES  end
SYM  .

```



### 二、语法分析_递归下降

##### 1、实现思路

根据上下文无关文法自顶向下分析，产生式右端依次进行检查，如果是非终结符，递归调用函数进行匹配，如果是非终结符，和当前的token对比。最后匹配完token序列，若出现错误，报告出错的token并终止程序，成功分析后生成语法树，在控制台和文件打印语法树。

##### 2、程序流程图

![image-20230528124751242](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528124751242.png)

##### 3、核心代码

```c++
void match_total_program()
{
	//每进来一个非终结符（递归），递归层数就要加1
	layers++;


	//记录当前非终结符信息
	tree_output.push_back({ layers, "TotalProgram" });

	//程序头部匹配
	match_program_head();
	//声明部分匹配
	match_declare_part();
	//程序主题匹配
	match_program_body();

	//序列末尾元素
	if (tokens[idx].name != ".")
	{
		printf("idx = %d\n", idx);
		puts("match_program error!");
		exit(0);
	}
	//记录当前token结点信息
	log_tree(tokens[idx].name);
	idx++;

	//当前递归结束，层数回溯到上一层
	layers--;
}

void match_program_head()
{
	layers++;
	tree_output.push_back({ layers, "ProgramHead" });

	if (tokens[idx].name != "program")
	{
		printf("idx = %d\n", idx);
		puts("match_program_head error!");
		exit(0);
	}

	log_tree(tokens[idx].name);
	idx++;

	match_program_name();
	layers--;
}

void match_factor()
{
	//递归信息记录
	layers++;
	tree_output.push_back({ layers, "Factor" });

	//产生式右端匹配，若是非终结符，递归一个函数，否则进行token的类型检查或者值检查
	if (tokens[idx].name == "(")
	{
		log_tree(tokens[idx].name);
		idx++;

		match_exp();

		if (tokens[idx].name != ")")
		{
			printf("idx = %d\n", idx);
			puts("match_factor error!");
			exit(0);
		}

		log_tree(tokens[idx].name);
		idx++;
	}
	else if (tokens[idx].type == "NUM")
	{
		log_tree(tokens[idx].name);
		idx++;
	}
	else
	{
		if (tokens[idx].type != "ID")
		{
			printf("idx = %d\n", idx);
			puts("match_factor error!");
			exit(0);
		}

		match_variable();
	}


	layers--;
}
```



##### 4、运行结果

**测试的token序列：**

```txt
RES  program
ID   p
RES  type
ID   t
SYM  =
RES  integer
SYM  ;
RES  var
ID   t
ID   v1
SYM  ;
RES  integer
ID   v2
SYM  ;
RES  begin
RES  read
SYM  (
ID   v1
SYM  )
SYM  ;
ID   v1
SYM  :=
ID   v1
SYM  *
NUM  10
SYM  ;
ID   v2
SYM  :=
NUM  100
SYM  ;
RES  write
SYM  (
ID   v1
SYM  )
RES  end
SYM  .
```

**运行结果：**

![image-20230528112656479](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528112656479.png)

**生成的语法树：**

```txt
  TotalProgram
  ├ ProgramHead
  │ ├ program
  │ ├ ProgramName
  │   ├ p
  ├ DeclarePart
  │ ├ TypeDecpart
  │ │ ├ TypeDec
  │ │   ├ type
  │ │   ├ TypeDecList
  │ │     ├ TypeId
  │ │     │ ├ t
  │ │     ├ =
  │ │     ├ TypeName
  │ │     │ ├ BaseType
  │ │     │   ├ integer
  │ │     ├ ;
  │ │     ├ TypeDecMore
  │ │       ├ NULL
  │ ├ VarDecpart
  │ │ ├ VarDec
  │ │   ├ var
  │ │   ├ VarDecList
  │ │     ├ TypeName
  │ │     │ ├ t
  │ │     ├ VarIdList
  │ │     │ ├ v1
  │ │     │ ├ VarIdMore
  │ │     │   ├ NULL
  │ │     ├ ;
  │ │     ├ VarDecMore
  │ │       ├ VarDecList
  │ │         ├ TypeName
  │ │         │ ├ BaseType
  │ │         │   ├ integer
  │ │         ├ VarIdList
  │ │         │ ├ v2
  │ │         │ ├ VarIdMore
  │ │         │   ├ NULL
  │ │         ├ ;
  │ │         ├ VarDecMore
  │ │           ├ NULL
  │ ├ ProDecpart
  │   ├ NULL
  ├ ProgramBody
  │ ├ begin
  │ ├ StmList
  │ │ ├ Stm
  │ │ │ ├ InputStm
  │ │ │   ├ read
  │ │ │   ├ (
  │ │ │   ├ v1
  │ │ │   ├ )
  │ │ ├ StmMore
  │ │   ├ ;
  │ │   ├ StmList
  │ │     ├ Stm
  │ │     │ ├ v1
  │ │     │ ├ AssCall
  │ │     │   ├ AssignmentRest
  │ │     │     ├ VariMore
  │ │     │     │ ├ NULL
  │ │     │     ├ :=
  │ │     │     ├ Exp
  │ │     │       ├ Term
  │ │     │       │ ├ Factor
  │ │     │       │ │ ├ Variable
  │ │     │       │ │   ├ v1
  │ │     │       │ │   ├ VariMore
  │ │     │       │ │     ├ NULL
  │ │     │       │ ├ OtherFactor
  │ │     │       │   ├ MulOp
  │ │     │       │   │ ├ *
  │ │     │       │   ├ Term
  │ │     │       │     ├ Factor
  │ │     │       │     │ ├ 10
  │ │     │       │     ├ OtherFactor
  │ │     │       │       ├ NULL
  │ │     │       ├ OtherTerm
  │ │     │         ├ NULL
  │ │     ├ StmMore
  │ │       ├ ;
  │ │       ├ StmList
  │ │         ├ Stm
  │ │         │ ├ v2
  │ │         │ ├ AssCall
  │ │         │   ├ AssignmentRest
  │ │         │     ├ VariMore
  │ │         │     │ ├ NULL
  │ │         │     ├ :=
  │ │         │     ├ Exp
  │ │         │       ├ Term
  │ │         │       │ ├ Factor
  │ │         │       │ │ ├ 100
  │ │         │       │ ├ OtherFactor
  │ │         │       │   ├ NULL
  │ │         │       ├ OtherTerm
  │ │         │         ├ NULL
  │ │         ├ StmMore
  │ │           ├ ;
  │ │           ├ StmList
  │ │             ├ Stm
  │ │             │ ├ OutputStm
  │ │             │   ├ write
  │ │             │   ├ (
  │ │             │   ├ Exp
  │ │             │   │ ├ Term
  │ │             │   │ │ ├ Factor
  │ │             │   │ │ │ ├ Variable
  │ │             │   │ │ │   ├ v1
  │ │             │   │ │ │   ├ VariMore
  │ │             │   │ │ │     ├ NULL
  │ │             │   │ │ ├ OtherFactor
  │ │             │   │ │   ├ NULL
  │ │             │   │ ├ OtherTerm
  │ │             │   │   ├ NULL
  │ │             │   ├ )
  │ │             ├ StmMore
  │ │               ├ NULL
  │ ├ end
  │ .

```



### 三、语法分析_LL(1)

##### 1、实现思路

根据SNL语言的上下文无关文法自顶向下分析，遇到非终结符的时候查看当前token是不是预期的终结符，如果不是，语法报错，否则找到非终结符对应的产生式，将右部逆序入栈。关键是构造非终结符的预测集，这里使用非终结符的first集替代，空值不往后找follow集，而是当成一个特殊的终结符，既满足需求，又将产生式右部逆序入栈。

##### 2、程序流程图

![image-20230528131516961](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528131516961.png)

##### 3、核心代码

```c++

//根据非终结符计算predict集合，这里用first集合替代，空值记录为null，不计算follow集
vector<string> get_predict_by_string(string s)
{
	vector<string> res;

	//找到非终结符对应的产生式，如果是终结符，直接加入，如果是非终结符，递归加入
	for (int i = 0; i < grammer.size(); i++) {
		if (grammer[i][0] == s){
			string right_first_string = grammer[i][2];

			if (judge_terminal(right_first_string)) {
				res.push_back(right_first_string);
			}
			else{
				auto predict_of_right_first_string = get_predict_by_string(right_first_string);
				for (auto t : predict_of_right_first_string) res.push_back(t);
			}
		}
	}

	return res;
}

//构造LL(1)分析表
void build_LL1_table()
{
	//打印检查输入的token序列
	if (if_print_input_tokens)	print_input_tokens();

	//计算predict集合
	for (int i = 0; i < grammer.size(); i++) {
		//非终结符还不存在predict集合，构造predict集合
		if (predict.count(grammer[i][0]) == 0) {
			predict[grammer[i][0]] = get_predict_by_string(grammer[i][0]);
		}
	}

	//打印检查predict集
	if (if_print_predict) print_predict();

	//构造LL(1)分析表，每个产生式对应一行
	for (int i = 0; i < grammer.size(); i++)
	{
		vector<string> res;

		string right_first_string = grammer[i][2];
		//终结符就是它本身
		if (judge_terminal(right_first_string)) res.push_back(right_first_string);
		//非终结符就是它的predict集合
		else res = predict[right_first_string];

		LL1_table.push_back(res);
	}

	//检查LL(1)分析表是否有冲突的预测
	if (grammer.size() != LL1_table.size())
	{
		puts("LL1_table build error!");
		exit(0);
	}

	map<string, set<string>> assert_LL1_table_no_repeat;
	//使用map判断非终结符是否重复即可
	for (int i = 0; i < grammer.size(); i++){
		auto s = grammer[i][0];
		for (auto t : LL1_table[i]){
			if (assert_LL1_table_no_repeat[s].count(t)){
				printf("%s %s\n", s.c_str(), t.c_str());
				puts("error, LL1_table has repeat!");
				exit(0);
			}
			assert_LL1_table_no_repeat[s].insert(t);
		}
	}

	//打印检查LL1分析表
	if (if_print_LL1_table) print_LL1_table();
}

//自顶向下做LL(1)分析
void LL1_process()
{
	//开始分析
	printf("\n\n%-20s%-15s%-15s%-15s\n", "分析栈栈顶", "输入栈栈顶", "语法动作", "依据的文法");


	//初始化输入栈和分析栈
	for (int i = tokens.size() - 1; i >= 0; i--) {
		token_stk.push(tokens[i]);
	}
	work_stk.push("total_program");


	//自顶向下分析栈中的元素
	while (work_stk.size()){
		string top_work_string = work_stk.top();

		//遇到标记结点，层数回溯
		if (top_work_string=="kk") {
			layer --;
			work_stk.pop();
			continue;
		}
		layer++;

		auto top_token_string = token_stk.top();

		//分析栈顶是终结符，检查token是不是相应的终结类型
		if (judge_terminal(top_work_string)){

			tree_output.push_back({ layer,top_token_string.name.c_str() });
			layer--;


			if (top_work_string == "ID" || top_work_string == "NUM"){
				if (top_work_string == top_token_string.type){
					printf("%-20s%-15s匹配！\n", top_work_string.c_str(), top_token_string.name.c_str());
					work_stk.pop();
					token_stk.pop();
				}else{
					printf("idx = %d\n", tot - token_stk.size());
					printf("%s   %s   not match!\n", top_work_string.c_str(), top_token_string.name.c_str());
					exit(0);
				}
			}else{
				if (top_work_string == top_token_string.name){
					printf("%-20s%-15s匹配！\n", top_work_string.c_str(), top_token_string.name.c_str());
					work_stk.pop();
					token_stk.pop();
				}else{
					printf("idx = %d\n", tot - token_stk.size());
					printf("%s   %s   not match!\n", top_work_string.c_str(), top_token_string.name.c_str());
					exit(0);
				}
			}
		}
		//分析栈顶是非终结符，在LL(1)分析表中找到当前栈顶元素对应的产生式，以及预测值
		//检查预测值是否包含当前token，如果不包含，说明语法出错了；
		//如果包含，说明语法正确，把当前产生式的右部逆序入栈分析
		else {
			tree_output.push_back({ layer,top_work_string });


			string token_name = top_token_string.name;
			string token_type = top_token_string.type;
			bool has_null = false;
			int match_grammer = -1;
			int null_grammer = -1;

			//在LL(1)分析表找到非终结符对应的预测值，检查当前token是否满足，不满足就出错
			for (int i = 0; i < grammer.size(); i++) {
				if (grammer[i][0] == top_work_string){
					for (auto t : LL1_table[i]){
						if (t == "null") has_null = true, null_grammer = i;
						else if (t == token_name ||
									token_type == "ID" && t == token_type ||
									token_type == "NUM" && t == token_type) {
							match_grammer = i;
						}
					}
				}
			}
			//token满足预测，可以把对应产生式的右部逆序入栈
			if (match_grammer != -1){
				//分析信息打印
				printf("%-20s%-15s%-15s%s\n", top_work_string.c_str(), top_token_string.name.c_str(),
					"移入！", get_grammer_str_by_id(match_grammer).c_str());
				work_stk.pop();

				//非终结符相当于新开了递归，需要做一个标记结点来实现层数的回溯
				work_stk.push("kk");
				
				//逆序入栈
				for (int i = grammer[match_grammer].size() - 1; i >= 2; i--) {
					work_stk.push(grammer[match_grammer][i]);
				}
			}
			//预测值允许为空，把对应产生式的右部逆序入栈
			else if (has_null) {
				printf("%-20s%-15s%-15s%s\n", top_work_string.c_str(), top_token_string.name.c_str(),
					"移入！", get_grammer_str_by_id(null_grammer).c_str());
				work_stk.pop();

				//标记结点
				work_stk.push("kk");

				for (int i = grammer[null_grammer].size() - 1; i >= 2; i--) {
					work_stk.push(grammer[null_grammer][i]);
				}
				if (work_stk.top() == "null") work_stk.pop();
			}
			//不允许为空，不是预测值
			else{
				printf("idx = %d\n", tot - token_stk.size());
				printf("%s   %s   cannot match!\n", top_work_string.c_str(), top_token_string.name.c_str());
				exit(0);
			}
		}
	}

	//结束分析
	puts("语法分析成功！");
}
```

##### 4、运行结果

**测试的token序列：**

```txt
RES  program
ID   p
RES  type
ID   t
SYM  =
RES  integer
SYM  ;
RES  var
ID   t
ID   v1
SYM  ;
RES  integer
ID   v2
SYM  ;
RES  begin
RES  read
SYM  (
ID   v1
SYM  )
SYM  ;
ID   v1
SYM  :=
ID   v1
SYM  *
NUM  10
SYM  ;
ID   v2
SYM  :=
NUM  100
SYM  ;
RES  write
SYM  (
ID   v1
SYM  )
RES  end
SYM  .

```

**产生式：**

```txt
total_program   ->   program_head   declare_part   program_body   .
program_head   ->   program   program_name
program_name   ->   ID
declare_part   ->   type_dec_part   var_dec_part   proc_dec_part
type_dec_part   ->   null
type_dec_part   ->   type_dec
type_dec   ->   type   type_dec_list
type_dec_list   ->   type_id   =   type_name   ;   type_dec_more
type_dec_more   ->   null
type_dec_more   ->   type_dec_list
type_id   ->   ID
type_name   ->   base_name
type_name   ->   structure_type
type_name   ->   ID
base_name   ->   integer
base_name   ->   char
structure_type   ->   array_type
structure_type   ->   rec_type
array_type   ->   array   [   NUM   ..   NUM   ]   of   base_name
rec_type   ->   record   field_dec_list   end
field_dec_list   ->   base_name   id_list   ;   field_dec_more
field_dec_list   ->   array_type   id_list   ;   field_dec_more
field_dec_more   ->   null
field_dec_more   ->   field_dec_list
id_list   ->   ID   id_more
id_more   ->   null
id_more   ->   ,   id_list
var_dec_part   ->   null
var_dec_part   ->   var_dec
var_dec   ->   var   var_dec_list
var_dec_list   ->   type_name   var_id_list   ;   var_dec_more
var_dec_more   ->   null
var_dec_more   ->   var_dec_list
var_id_list   ->   ID   var_id_more
var_id_more   ->   null
var_id_more   ->   ,   var_id_list
proc_dec_part   ->   null
proc_dec_part   ->   proc_dec
proc_dec   ->   procedure    proc_name   (   param_list   )   ;   declare_part   proc_body   proc_dec_more
proc_dec_more   ->   null
proc_dec_more   ->   proc_dec
proc_name   ->   ID
param_list   ->   null
param_list   ->   param_dec_list
param_dec_list   ->   param   param_more
param_more   ->   null
param_more   ->   ;   param_dec_list
param   ->   type_name   form_list
param   ->   var   type_name   form_list
form_list   ->   ID   fid_more
fid_more   ->   null
fid_more   ->   ,   form_list
proc_body   ->   program_body
program_body   ->   begin   stm_list   end
stm_list   ->   stm   stm_more
stm_more   ->   null
stm_more   ->   ;   stm_list
stm   ->   conditional_stm
stm   ->   loop_stm
stm   ->   input_stm
stm   ->   output_stm
stm   ->   return_stm
stm   ->   ID   ass_call
ass_call   ->   assignment_rest
ass_call   ->   call_stm_rest
assignment_rest   ->   vari_more   :=   exp
conditional_stm   ->   if   rel_exp   then   stm_list   else   stm_list   fi
loop_stm   ->   while   rel_exp   do   stm_list   endwh
input_stm   ->   read   (   in_var   )
in_var   ->   ID
output_stm   ->   write   (   exp   )
return_stm   ->   return   (   exp   )
call_stm_rest   ->   (   act_param_list   )
act_param_list   ->   null
act_param_list   ->   exp   act_param_more
act_param_more   ->   null
act_param_more   ->   ,   act_param_list
rel_exp   ->   exp   other_rel_e
other_rel_e   ->   cmp_op   exp
exp   ->   term   other_term
other_term   ->   null
other_term   ->   add_op   exp
term   ->   factor   other_factor
other_factor   ->   null
other_factor   ->   mul_op   term
factor   ->   (   exp   )
factor   ->   NUM
factor   ->   variable
variable   ->   ID   vari_more
vari_more   ->   null
vari_more   ->   [   exp   ]
vari_more   ->   .   field_var
field_var   ->   ID   field_var_more
field_var_more   ->   null
field_var_more   ->   [   exp   ]
cmp_op   ->   <
cmp_op   ->   =
cmp_op   ->   >
add_op   ->   +
add_op   ->   -
mul_op   ->   *
mul_op   ->   /
```

**LL1分析表：**

![image-20230528111751832](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528111751832.png)

**LL1分析过程：**

![image-20230528111810413](https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20230528111810413.png)

**生成的语法树：**

```txt
  total_program
  ├ program_head
  │ ├ program
  │ ├ program_name
  │   ├ p
  ├ declare_part
  │ ├ type_dec_part
  │ │ ├ type_dec
  │ │   ├ type
  │ │   ├ type_dec_list
  │ │     ├ type_id
  │ │     │ ├ t
  │ │     ├ =
  │ │     ├ type_name
  │ │     │ ├ base_name
  │ │     │   ├ integer
  │ │     ├ ;
  │ │     ├ type_dec_more
  │ ├ var_dec_part
  │ │ ├ var_dec
  │ │   ├ var
  │ │   ├ var_dec_list
  │ │     ├ type_name
  │ │     │ ├ t
  │ │     ├ var_id_list
  │ │     │ ├ v1
  │ │     │ ├ var_id_more
  │ │     ├ ;
  │ │     ├ var_dec_more
  │ │       ├ var_dec_list
  │ │         ├ type_name
  │ │         │ ├ base_name
  │ │         │   ├ integer
  │ │         ├ var_id_list
  │ │         │ ├ v2
  │ │         │ ├ var_id_more
  │ │         ├ ;
  │ │         ├ var_dec_more
  │ ├ proc_dec_part
  ├ program_body
  │ ├ begin
  │ ├ stm_list
  │ │ ├ stm
  │ │ │ ├ input_stm
  │ │ │   ├ read
  │ │ │   ├ (
  │ │ │   ├ in_var
  │ │ │   │ ├ v1
  │ │ │   ├ )
  │ │ ├ stm_more
  │ │   ├ ;
  │ │   ├ stm_list
  │ │     ├ stm
  │ │     │ ├ v1
  │ │     │ ├ ass_call
  │ │     │   ├ assignment_rest
  │ │     │     ├ vari_more
  │ │     │     ├ :=
  │ │     │     ├ exp
  │ │     │       ├ term
  │ │     │       │ ├ factor
  │ │     │       │ │ ├ variable
  │ │     │       │ │   ├ v1
  │ │     │       │ │   ├ vari_more
  │ │     │       │ ├ other_factor
  │ │     │       │   ├ mul_op
  │ │     │       │   │ ├ *
  │ │     │       │   ├ term
  │ │     │       │     ├ factor
  │ │     │       │     │ ├ 10
  │ │     │       │     ├ other_factor
  │ │     │       ├ other_term
  │ │     ├ stm_more
  │ │       ├ ;
  │ │       ├ stm_list
  │ │         ├ stm
  │ │         │ ├ v2
  │ │         │ ├ ass_call
  │ │         │   ├ assignment_rest
  │ │         │     ├ vari_more
  │ │         │     ├ :=
  │ │         │     ├ exp
  │ │         │       ├ term
  │ │         │       │ ├ factor
  │ │         │       │ │ ├ 100
  │ │         │       │ ├ other_factor
  │ │         │       ├ other_term
  │ │         ├ stm_more
  │ │           ├ ;
  │ │           ├ stm_list
  │ │             ├ stm
  │ │             │ ├ output_stm
  │ │             │   ├ write
  │ │             │   ├ (
  │ │             │   ├ exp
  │ │             │   │ ├ term
  │ │             │   │ │ ├ factor
  │ │             │   │ │ │ ├ variable
  │ │             │   │ │ │   ├ v1
  │ │             │   │ │ │   ├ vari_more
  │ │             │   │ │ ├ other_factor
  │ │             │   │ ├ other_term
  │ │             │   ├ )
  │ │             ├ stm_more
  │ ├ end
  │ .

```




