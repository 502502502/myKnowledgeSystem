## 1、tcpdump 在 Linux 下如何抓包？

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220909145240189.png" alt="image-20220909145240189" style="zoom:67%;" />

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220909145259766.png" alt="image-20220909145259766" style="zoom:67%;" />

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220909145422731.png" alt="image-20220909145422731" style="zoom:67%;" />

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220909145442936.png" alt="image-20220909145442936" style="zoom:67%;" />



## 2、Wireshark 工具如何分析数据包？

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220909145543300.png" alt="image-20220909145543300" style="zoom: 80%;" />

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220909145642021.png" alt="image-20220909145642021" style="zoom:80%;" />



## 3、为什么三次握手连接过程的 Seq 是 0 ？

实际上是因为 Wireshark 工具帮我们做了优化，它默认显示的是序列号 seq 是相对值，而不是真实值。

如果你想看到实际的序列号的值，可以右键菜单， 然后找到「协议首选项」，接着找到「Relative Seq」后，把它给取消



## 4、为什么抓到的 TCP 挥手是三次，而不是书上说的四次？

当被动关闭方（上图的服务端）在 TCP 挥手过程中，「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。**



## 5、TCP 第一次握手 SYN 丢包

当客户端发起的 TCP 第一次握手 SYN 包，在超时时间内没收到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 `tcp_syn_retries` 值后，客户端不再发送 SYN 包



## 6、CP 第二次握手 SYN、ACK 丢包

当 TCP 第二次握手 SYN、ACK 包丢了后，客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。

客户端 SYN 包超时重传的最大次数，是由 tcp_syn_retries 决定的，默认值是 5 次；服务端 SYN、ACK 包时重传的最大次数，是由 tcp_synack_retries 决定的，默认值是 5 次



## 7、TCP 第三次握手 ACK 丢包

- 在建立 TCP 连接时，如果第三次握手的 ACK，服务端无法收到，则服务端就会短暂处于 `SYN_RECV` 状态，而客户端会处于 `ESTABLISHED` 状态。

  由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 `tcp_synack_retries` 值（默认值 5 次）后，服务端就会断开 TCP 连接。

  而客户端则会有两种情况：

  - 如果客户端没发送数据包，一直处于 `ESTABLISHED` 状态，然后经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接，于是客户端连接就会断开连接。
  - 如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 `tcp_retries2` 值（默认值 15 次）后，客户端就会断开 TCP 连接。



## 8、TCP快速连接

- 在第一次建立连接的时候，服务端在第二次握手产生一个 `Cookie` （已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 `Cookie`，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个 RTT 的时延；
- 在下次请求的时候，客户端在 SYN 包带上 `Cookie` 发给服务端，就提前可以跳过三次握手的过程，因为 `Cookie` 中维护了一些信息，服务端可以从 `Cookie` 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；



## 9、在 Linux 上如何打开 Fast Open 功能？

可以通过设置 `net.ipv4.tcp_fastopn` 内核参数，来打开 Fast Open 功能。

net.ipv4.tcp_fastopn 各个值的意义:

- 0 关闭
- 1 作为客户端使用 Fast Open 功能
- 2 作为服务端使用 Fast Open 功能
- 3 无论作为客户端还是服务器，都可以使用 Fast Open 功能



## 10、选择性确认 SACK

一旦数据包丢失并收到重复 ACK ，即使在丢失数据包之后还成功接收了其他数据包，也只需要重传丢失的数据包。

如果不启用 SACK，就必须重传丢失包之后的每个数据包。

如果要支持 `SACK`，必须双方都要支持。

在 Linux 下，可以通过 `net.ipv4.tcp_sack` 参数打开这个功能（Linux 2.4 后默认打开）





## 11、发送方在一个窗口发出 n 个包，是不是需要 n 个 ACK 确认报文？

不一定，因为 TCP 有累计确认机制，所以当收到多个数据包时，只需要应答最后一个数据包的 ACK 报文就可以了



## 12、发送窗口和 MSS 有什么关系？

发送窗口决定了一口气能发多少字节，而 MSS 决定了这些字节要分多少包才能发完。

举个例子，如果发送窗口为 16000 字节的情况下，如果 MSS 是 1000 字节，那就需要发送 1600/1000 = 16 个包。



## 13、如何在包里看出发送窗口的大小？

很遗憾，没有简单的办法，发送窗口虽然是由接收窗口决定，但是它又可以被网络因素影响，也就是拥塞窗口，实际上发送窗口是值是 min(拥塞窗口，接收窗口)。	



## 14、在 Wireshark 看到的 Windows size 也就是 " win = "，这个值表示发送窗口吗？

这不是发送窗口，而是在向对方声明自己的接收窗口。

你可能会好奇，抓包文件里有「Window size scaling factor」，它其实是算出实际窗口大小的乘法因子，「Window size value」实际上并不是真实的窗口大小，真实窗口大小的计算公式如下：

「Window size value」 * 「Window size scaling factor」 = 「Caculated window size 」



## 15、 TCP 延迟确认

当没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文

TCP 延迟确认的策略：

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK





## 16、延迟确认 和 Nagle 算法混合使用时，会产生新的问题

- 发送方先发出一个小报文，接收方收到后，由于延迟确认机制，自己又没有要发送的数据，只能干等着发送方的下一个报文到达；
- 而发送方由于 Nagle 算法机制，在未收到第一个报文的确认前，是不会发送后续的数据；
- 所以接收方只能等待最大时间 200 ms 后，才回 ACK 报文，发送方收到第一个报文的确认报文后，也才可以发送后续的数据。

很明显，这两个同时使用会造成额外的时延，这就会使得网络"很慢"的感觉。

要解决这个问题，只有两个办法：

- 要不发送方关闭 Nagle 算法
- 要不接收方关闭 TCP 延迟确认



## 17、为什么连续两个报文的seq会是一样的呢，比如三次握手之后的那个报文？

1. 三次握手中的前两次，是 seq+1；
2. 三次握手中的最后一个 ack，实际上是可以携带数据的，由于我文章的例子是没有发送数据的，你可以看到第三次握手的 len=0 ，在数据传输阶段「下一个 seq=seq+len 」，所以第三次握手的 seq 和下一个数据报的 seq 是一样的，因为 len 为 0；





## 18、如何知道应用程序的 TCP 全连接队列大小？

在服务端可以使用 `ss` 命令，来查看 TCP 全连接队列的情况

在「LISTEN 状态」时，`Recv-Q/Send-Q` 表示的含义如下：

- Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 `accept()` 的 TCP 连接；
- Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务，最大全连接长度为 128；

在「非 LISTEN 状态」时，`Recv-Q/Send-Q` 表示的含义如下：

- Recv-Q：已收到但未被应用进程读取的字节数；
- Send-Q：已发送但未收到确认的字节数；



## 19、如何模拟 TCP 全连接队列溢出的场景？

`wrk` 工具，它是一款简单的 HTTP 压测工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，通过多线程和事件模式，对目标机器产生大量的负载

<img src="C:/Users/ning chuang tao/AppData/Roaming/Typora/typora-user-images/image-20220911124054483.png" alt="image-20220911124054483" style="zoom:67%;" />

在服务端可以使用 `ss` 命令，来查看当前 TCP 全连接队列的情况

<img src="C:/Users/ning chuang tao/AppData/Roaming/Typora/typora-user-images/image-20220911124111771.png" alt="image-20220911124111771" style="zoom:67%;" />

**当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接**，丢掉的 TCP 连接的个数会被统计起来，我们可以使用 netstat -s 命令来查看

<img src="C:/Users/ning chuang tao/AppData/Roaming/Typora/typora-user-images/image-20220911124125037.png" alt="image-20220911124125037" style="zoom:67%;" />





## 20、 TCP 全连接队列满了会使用什么策略

丢弃连接只是 Linux 的默认行为，我们还可以选择向客户端发送 RST 复位报文

tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：

- 0 ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；
- 1 ：如果全连接队列满了，server 发送一个 `reset` 包给 client，表示废掉这个握手过程和这个连接；



## 21、TCP 全连接队列满了默认丢弃有什么好处

有利于应对突发流量

客户端的连接状态是 ESTABLISHED，进程就在建立好的连接上发送请求。

只要服务器没有为请求回复 ACK，请求就会被多次**重发**。

如果服务器上的进程只是**短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。**



## 22、如何增大 TCP 全连接队列呢？

**TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)**

- `somaxconn` 是 Linux 内核的参数，默认值是 128，可以通过 `/proc/sys/net/core/somaxconn` 来设置其值；
- `backlog` 是 `listen(int sockfd, int backlog)` 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；



## 23、如何解决TCP全连接队列溢出问题

**如果持续不断地有连接因为 TCP 全连接队列溢出被丢弃，就应该调大 backlog 以及 somaxconn 参数**



## 24、如何查看 TCP 半连接队列长度？

TCP 半连接队列长度的长度，没有像全连接队列那样可以用 ss 命令查看

可以用服务端处于 `SYN_RECV` 状态的 TCP 连接，代表TCP半连接队列长度

<img src="C:/Users/ning chuang tao/AppData/Roaming/Typora/typora-user-images/image-20220911125213090.png" alt="image-20220911125213090" style="zoom:67%;" />



## 25、如何模拟 TCP 半连接队列溢出场景？

对服务端一直发送 TCP SYN 包，但是不回第三次握手 ACK，这样就会使得服务端有大量的处于 `SYN_RECV` 状态的 TCP 连接，即SYN攻击

使用 `hping3` 工具模拟 SYN 攻击

<img src="C:/Users/ning chuang tao/AppData/Roaming/Typora/typora-user-images/image-20220911125319429.png" alt="image-20220911125319429" style="zoom:80%;" />

当服务端受到 SYN 攻击后，连接服务端 ssh 就会断开了，无法再连上。



在服务端主机上执行查看当前 TCP 半连接队列大小



通过 netstat -s 观察半连接队列溢出的情况

<img src="C:/Users/ning chuang tao/AppData/Roaming/Typora/typora-user-images/image-20220911125408285.png" alt="image-20220911125408285" style="zoom:67%;" />



## 26、如何确定半连接队列的理论长度？

tcp_max_syn_backlog ：半连接队列参数

sk_max_ack_backlog ：全连接队列最大长度

max_qlen_log：半连接队列理论长度以2为底的幂

> 半连接队列理论长度

max_qlen_log =  $log_2$(max(min(tcp_max_syn_backlog, sk_max_ack_backlog), 8) 向上取一个2的整数次幂)



## 27、半连接队列的溢出条件是什么样的

> 未开启**tcp_syncookies**

+ 达到理论长度后丢弃
+ 达到全连接队列最大长度且没有重传 SYN+ACK 包的连接请求多于 1 个，丢弃
+ 达到tcp_max_syn_backlog的一半时丢弃



>  开启**tcp_syncookies**

**开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接**

syncookies 参数主要有以下三个值：

- 0 值，表示关闭该功能；
- 1 值，表示仅当 SYN 半连接队列放不下时，再启用它；
- 2 值，表示无条件开启功能；



## 28、如何防御 SYN 攻击？

- 增大半连接队列

  - **不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列**

- 开启 tcp_syncookies 功能

- 减少 SYN+ACK 重传次数

  - 当服务端受到 SYN 攻击时，就会有大量处于 SYN_RECV 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。

    那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_RECV 状态的 TCP 连接断开。



## 29、如何查看由于 SYN 半连接队列已满，而被丢弃连接的情况？

通过 `netstat -s` 命令给出的统计结果中， 可以得到由于半连接队列已满，引发的失败次数：

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/10.jpg" alt="img" style="zoom:67%;" />

上面输出的数值是**累计值**，表示共有多少个 TCP 连接因为半连接队列溢出而被丢弃。**隔几秒执行几次，如果有上升的趋势，说明当前存在半连接队列溢出的现象**。



## 30、如何优化TCP连接

> 客户端的优化

当客户端发起 SYN 包时，可以根据网络的稳定性和目标服务器的繁忙程度通过 `tcp_syn_retries` 控制其重传的次数。

比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序；

> 服务端的优化

1、调整半连接队列大小

当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 `netstat -s` 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况比较严重，可以通过 `tcp_max_syn_backlog、somaxconn、backlog` 参数来调整 SYN 半连接队列的大小。

2、调整重传次数

服务端回复 SYN+ACK 的重传次数由 `tcp_synack_retries` 参数控制，服务端当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数，反之则可以调小重发次数；

3、避免SYN攻击

如果遭受 SYN 攻击，应把 `tcp_syncookies` 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。

4、调整全连接队列大小

如果 accpet 队列溢出严重，可以通过 listen 函数的 `backlog` 参数和 `somaxconn` 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)。

5、调整全连接队列溢出处理策略

通过 `ss -lnt` 查看服务端进程的 accept 队列长度，如果 accept 队列溢出，系统默认丢弃 ACK，

可以把 `tcp_abort_on_overflow` 设置为 1 ，表示用 RST 通知客户端连接建立失败。

默认为0，可以应对流量突发





## 31、如何绕过三次握手？

开启TCP快速连接，勇Cookie保存第一次连接的信息，第二次发起连接的时候在第一次握手时携带上一次连接的Cookie信息以及本次的请求信息，直接建立连接，发起请求。



在 Linux 系统中，可以通过**设置 tcp_fastopn 内核参数，来打开 Fast Open 功能**：

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/23.jpg" alt="img" style="zoom:67%;" />

tcp_fastopn 各个值的意义:

- 0 关闭
- 1 作为客户端使用 Fast Open 功能
- 2 作为服务端使用 Fast Open 功能
- 3 无论作为客户端还是服务器，都可以使用 Fast Open 功能

**TCP Fast Open 功能需要客户端和服务端同时支持，才有效果。**



## 32、调用 close 函数和 shutdown 函数有什么区别？

调用了 close 函数意味着完全断开连接，**完全断开不仅指无法传输数据，而且也不能发送数据。**

此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。

孤儿连接只是关闭数据交互，即断开与进程的联系，但是tcp连接还是会走四次挥手，可以接收和发送FIN和ACK



 `shutdown` 函数，**它可以控制只关闭一个方向的连接**：

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/26.jpg" alt="img" style="zoom:50%;" />

第二个参数决定断开连接的方式，主要有以下三种方式：

- SHUT_RD(0)：**关闭连接的「读」这个方向**，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。

  > 关闭读方向后，如果处于FIN_WAIT2,那么在收到对方发来的数据包，则会回复 RST 报文。

- SHUT_WR(1)：**关闭连接的「写」这个方向**，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端。

- SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，**关闭套接字的读和写两个方向**。



## 33、**tcp_orphan_retries 参数**有什么用？

主动方发送 FIN 报文后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动方的 ACK，则会很快变为 FIN_WAIT2 状态。

但是当迟迟收不到对方返回的 ACK 时，连接就会一直处于 FIN_WAIT1 状态。

此时，**内核会定时重发 FIN 报文，其中重发次数由 tcp_orphan_retries 参数控制**

（注意，orphan 虽然是孤儿的意思，该参数却不只对孤儿连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效）



​	



## 34、**tcp_max_orphans 参数**有什么用？

定义了「孤儿连接」的最大数量，如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。



## 35、FIN_WAIT1 状态连接过多该如何优化？

对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报文根本无法发送出去，这由 TCP 两个特性导致的：

- 首先，TCP 必须保证报文是有序发送的，FIN 报文也不例外，当发送缓冲区还有数据没有发送时，FIN 报文也不能提前发送。
- 其次，TCP 有流量控制功能，当接收方接收窗口为 0 时，发送方就不能再发送数据。所以，当攻击者下载大文件时，就可以通过接收窗口设为 0 ，这就会使得 FIN 报文都无法发送出去，那么连接会一直处于 FIN_WAIT1 状态。

解决这种问题的方法，是**调整 tcp_max_orphans 参数**，控制孤儿连接的最大个数



## 36、孤儿连接挥手阶段和其它TCP连接有什么不同？

孤儿连接收到第二次挥手的ACK后进入FIN_WAIT2 状态，FIN_WAIT2 状态不会一直等待第三次挥手的FIN，因为读写通道已经关闭了，不用确认了，在一段时间后，孤儿连接如果还没有收到FIN，会直接关闭，跳过TIME_WAIT状态。

如果收到FIN，则进入TIME_WAIT状态。



## 37、TIME_WAIT状态如何优化？

1、增大TIME_WAIT状态的连接数

当服务器的并发连接增多时，相应地，同时处于 TIME_WAIT 状态的连接数量也会变多，此时就应当调大 `tcp_max_tw_buckets` 参数，减少不同连接间数据错乱的概率。tcp_max_tw_buckets 也不是越大越好，毕竟系统资源是有限的。

2、复用处于 TIME_WAIT 状态的连接

**打开 tcp_tw_reuse 参数，但是需要注意，该参数是只用于客户端（建立连接的发起方），因为是在调用 connect() 时起作用的，而对于服务端（被动连接方）是没有用的。**

> 使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持（对方也要打开 ）
>
>  TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用
>
> 只适用于连接发起方，也就是 C/S 模型中的客户端

3、调整close关闭策略

在程序中设置 socket 选项，来设置调用 close 关闭连接行为。

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/37.jpg" alt="img" style="zoom: 50%;" />

如果 `l_onoff` 为非 0， 且 `l_linger` 值为 0，**那么调用 close 后，会立该发送一个 RST 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 TIME_WAIT 状态，直接关闭。**



## 38、TCP报文引入时间戳有什么好处

- 更加精确的计算RTT
- 防止序列号绕回，也是因为重复的数据包会由于时间戳过期被自然丢弃；



## 39、tcp_tw_recycle参数有哪些缺陷

允许处于 TIME_WAIT 状态的连接被快速回收，需要默认开启时间戳.tcp_timestamps，tcp_timestamps 选项开启之后， PAWS 机制会自动开启

但是它在判断TCP 报文中时间戳是否有效时，是**对「对端 IP 做 PAWS 检查」**，即per-host 的 PAWS 机制，而非对「IP + 端口」四元组做 PAWS 检查，

如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，

如果服务端开启了tcp_tw_recycle，

由于 per-host 的 PAWS 机制的作用，若同一网关下，下一个客户端连接的时间戳比上一个客户端的时间戳小，服务端就会丢弃这个客户端 发来的 SYN 包，因为这两个客户端是同样的IP，服务端不知道已经更换了客户端，对IP做PAWS后发现时间戳不是递增的，因此丢弃请求的SYN。



## 40、什么情况下会出现三次挥手

当被动方收到 FIN 报文时，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

如果被动方迅速调用 close 函数，那么被动方的 ACK 和 FIN 有可能在一个报文中发送，这样看起来，四次挥手会变成三次挥手



## 41、CLOSE_WAIT 状态会持续多久？

内核没有权利替代进程去关闭连接，因为如果主动方是通过 shutdown 关闭连接，那么它就是想在半关闭连接上接收数据或发送数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间



## 42、如果连接双方同时关闭连接，会怎么样？

双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭



## 43、如何优化TCP挥手

> 主动方的优化

主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 `tcp_orphan_retries` 参数决定，如果FIN_WAIT1状态连接过多，可以降低FIN重传次数，如何还不行，那可能是遭受了恶意攻击，阻止FIN报文的发出，可以降低孤儿连接的最大数量。



孤儿连接在FIN_WAIT2状态，如果 `tcp_fin_timeout` 秒内没有收到对方的 FIN 报文，连接就直接关闭。

如果孤儿连接的数量太多，会一直占用系统资源，为了应对孤儿连接占用太多的资源，`tcp_max_orphans` 定义了最大孤儿连接的数量，超过时连接就会直接释放。



非孤儿连接在FIN_WAIT2状态，会一直等待对方的FIN，不受时间限制，数量也没有限制



当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，`tcp_max_tw_buckets` 定义了最大数量，超过时连接也会直接释放。

当 TIME_WAIT 状态过多时，还可以通过设置 `tcp_tw_reuse` 和 `tcp_timestamps` 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。





> 被动方的优化

被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。

当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 `tcp_orphan_retries` 参数的控制下重发 FIN 报文。



## 44、什么是宽带时延积

决定网络中飞行报文的大小，意味着客户端到服务端的网络一共可以存放的字节数

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220912132552897.png" alt="image-20220912132552897" style="zoom:50%;" />



## 45、如何扩充滑动窗口大小

在 TCP 选项字段定义了窗口扩大因子，用于扩大 TCP 通告窗口，其值大小是 2^14，这样就使 TCP 的窗口大小从 16 位扩大为 30 位（2^16 * 2^ 14 = 2^30），所以此时窗口的最大值可以达到 1GB。

Linux 中打开这一功能，需要把 tcp_window_scaling 配置设为 1（默认打开）



通讯双方必须在各自的 SYN 报文中发送这个选项：

- 主动建立连接的一方在 SYN 报文中发送这个选项；
- 而被动建立连接的一方只有在收到带窗口扩大选项的 SYN 报文之后才能发送这个选项



## 46、发送缓冲区大小和宽带时延积的关系

发送缓冲区与带宽时延积的关系：

- 如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的网络传输，同时导致网络过载，容易丢包；
- 如果发送缓冲区「小于」带宽时延积，就不能很好的发挥出网络的传输效率。

所以，发送缓冲区的大小最好是往带宽时延积靠近



## 47、如何调整缓冲区大小

> 发送缓冲区，它的范围通过 tcp_wmem 参数配置

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/45.jpg" alt="img" style="zoom:50%;" />

上面三个数字单位都是字节，它们分别表示：

- 第一个数值是动态范围的最小值，4096 byte = 4K；
- 第二个数值是初始默认值，16384 byte ≈ 16K；
- 第三个数值是动态范围的最大值，4194304 byte = 4096K（4M）；

**发送缓冲区是自行调节的**，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。



>收缓冲区范围的 tcp_rmem 参数：

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/46.jpg" alt="img" style="zoom:50%;" />

上面三个数字单位都是字节，它们分别表示：

- 第一个数值是动态范围的最小值，表示即使在内存压力下也可以保证的最小接收缓冲区大小，4096 byte = 4K；
- 第二个数值是初始默认值，87380 byte ≈ 86K；
- 第三个数值是动态范围的最大值，6291456 byte = 6144K（6M）；



**接收缓冲区可以根据系统空闲内存的大小来调节接收窗口：**

- 如果系统的空闲内存很多，就可以自动把缓冲区增大一些，这样传给对方的接收窗口也会变大，因而提升发送方发送的传输数据数量；
- 反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连接正常工作；



发送缓冲区的调节功能是自动开启的，**而接收缓冲区则需要配置 tcp_moderate_rcvbuf 为 1 来开启调节功能**：

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/47.jpg" alt="img" style="zoom:67%;" />



## 48、接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？

通过 tcp_mem 配置

![img](https://ningct.oss-cn-hangzhou.aliyuncs.com/48.jpg)

上面三个数字单位不是字节，而是「页面大小」，1 页表示 4KB，它们分别表示：

- 当 TCP 内存小于第 1 个值时，不需要进行自动调节；
- 在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的大小；
- 大于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是无法建立的；

一般情况下这些值是在系统启动时根据系统内存数量计算得到的。

根据当前 tcp_mem 最大内存页面数是 177120，当内存为 (177120 * 4) / 1024K ≈ 692M 时，系统将无法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。





## 49、如何优化TCP传输

开启窗口扩充可以提高传输速率，但是不是越大越好，应当保证缓冲区的动态调整的最大值达到带宽时延积，最小保持默认的4k，可以兼顾网速和并发能力。当然，如果内存紧张，调低缓冲区最小值可以可以有效提高并发，可以为更多的连接分配内存。



如果是网络 IO 型服务器，那么，**调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力**。

需要注意的是，tcp_wmem 和 tcp_rmem 的单位是字节，而 tcp_mem 的单位是页面大小。

**千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能。**



## 50、为什么 UDP 是面向报文的协议？

当用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是**每个 UDP 报文就是一个用户消息的边界**，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。



## 51、为什么 TCP 是面向字节流的协议？

当用户消息通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。

这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。



## 52、什么是粘包问题

两个消息的某个部分内容被分到同一个 TCP 报文



## 53、如何解决粘包？

粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。

一般有三种方式分包的方式：

- 固定长度的消息；

- 特殊字符作为边界；

- 自定义消息结构

  自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。



## 54、为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？

如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，历史报文的序列号有很大概率在当前连接对方的接收窗口内。

如果初始序列号不一样，就算历史报文在有效期内到达了，很大概率不会在连接方的接收窗口内，

因此很大程度上可以防止历史报文被下一个相同四元组的连接接收。



## 55、什么情况下历史报文会被新的TCP连接接收

如果能正常四次挥手，由于 TIME_WAIT 状态会持续 2 MSL 时长，历史报文会在下一个连接之前就会自然消失。

但是并不能保证每次连接都能通过四次挥手来正常关闭连接，所以历史报文可能在有效期内到达新的TCP连接的接收方，此时若历史报文的序列号正好在对方接收窗口内，会被接收。



## 56、TCP每次建立连接初始序列号不一致一定能避免历史报文吗

不一定，因为序列号会回绕

- **序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0**。
- **初始序列号**，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。**初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时**。

在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。

如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。



## 57、如何解决序列号回绕问题？PAWS机制是什么？

开启 TCP 时间戳tcp_timestamps 

防回绕序列号算法要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，**如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包**，即PAWS机制



## 58、如果时间戳也回绕了怎么办？

1）增加时间戳的大小，由32 bit扩大到64bit

这样虽然可以在能够预见的未来解决时间戳回绕的问题，但会导致新旧协议兼容性问题，像现在的IPv4与IPv6一样

2）将一个与时钟频率无关的值作为时间戳，时钟频率可以增加但时间戳的增速不变

随着时钟频率的提高，TCP在相同时间内能够收发的包也会越来越多。如果时间戳的增速不变，则会有越来越多的报文使用相同的时间戳。这种趋势到达一定程度则时间戳就会失去意义，除非在可预见的未来这种情况不会发生。



## 59、SYN 报文什么时候情况下会被丢弃？

1、开启**tcp_tw_recycle** 快速回收TIME_WAIT状态的连接

由于服务端的 per-host  PAWS 机制的作用，若同一网关下，下一个客户端连接的时间戳比上一个客户端的时间戳小，服务端就会丢弃这个客户端 发来的 SYN 包，因为这两个客户端是同样的IP，服务端对IP做PAWS后发现时间戳不是递增的，因此丢弃请求的SYN。

2、半连接队列满了

当服务器造成syn攻击，就有可能导致 **TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃**。

但是，**如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包**。

syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功

3、全连接队列满了

在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了 ，这时后续的连接就会被丢弃



## 60、已建立连接的TCP，收到SYN会发生什么？

**1. 客户端的 SYN 报文里的端口号与历史连接不相同**

如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。

那旧连接里处于 establish 状态的服务端最后会怎么样呢？

如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。

如果服务端一直没有发送数据包给客户端，在超过一段时间后， TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。

**2. 客户端的 SYN 报文里的端口号与历史连接相同**

处于 establish 状态的服务端如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。

接着，客户端收到这个 Challenge ACK，发现序列号并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接

> 在收到报文后，首先会判断序列号是否在窗口内，如果不在，则看看 RST 标记有没有被设置，如果有就会丢掉。然后如果没有 RST 标志，就会判断是否有 SYN 标记，如果有 SYN 标记就会跳转到 syn_challenge 标签，然后执行 tcp_send_challenge_ack 函数。
>
> tcp_send_challenge_ack 函数里就会调用 tcp_send_ack 函数来回复一个携带了正确序列号和确认号的 ACK 报文



## 61、 如何关闭一个 TCP 连接？

1、杀掉进程

- 在客户端杀掉进程的话，就会发送 FIN 报文，来断开这个客户端进程与服务端建立的所有 TCP 连接，这种方式影响范围只有这个客户端进程所建立的连接，而其他客户端或进程不会受影响。
- 而在服务端杀掉进程影响就大了，此时所有的 TCP 连接都会被关闭，服务端无法继续提供访问服务。

2、模拟**四元组相同的 SYN 报文**

如果处于 establish 状态的服务端，收到四元组相同的 SYN 报文后，会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号，说白了，就是可以通过这一步**拿到服务端下一次预期接收的序列号**。

然后**用这个确认号作为 RST 报文的序列号**，发送给服务端，此时服务端会认为这个 RST 报文里的序列号是合法的，于是就会释放连接！

> 在 Linux 上有个叫 killcx 的工具，就是基于上面这样的方式实现的
>
> 它伪造客户端发送 SYN 报文，服务端收到后就会回复一个携带了正确「序列号和确认号」的 ACK 报文（Challenge ACK），然后就可以利用这个 ACK 报文里面的信息，伪造两个 RST 报文：
>
> - 用 Challenge ACK 里的确认号伪造 RST 报文发送给服务端，服务端收到 RST 报文后就会释放连接。
> - 用 Challenge ACK 里的序列号伪造 RST 报文发送给客户端，客户端收到 RST 也会释放连接。
>
> 正是通过这样的方式，成功将一个 TCP 连接关闭了！



## 62、四次挥手中收到乱序的 FIN 包会如何处理？

如果收到的报文的序列号是我们预期的，也就是有序的话：

- 会判断该报文有没有 FIN 标志，如果有的话就会调用 tcp_fin 函数，这个函数负责将 FIN_WAIT_2 状态转换为 TIME_WAIT。
- 接着还会看乱序队列有没有数据，如果有的话会调用 tcp_ofo_queue 函数，这个函数负责检查乱序队列中是否有数据包可用，即能不能在乱序队列找到与当前数据包保持序列号连续的数据包。



当收到的报文的序列号不是我们预期的，也就是乱序的话，将报文加入到乱序队列，这个队列的数据结构是红黑树



客户端收到被网络延迟的数据包后，此时因为该数据包的序列号是期望的，然后又因为上一次收到的乱序 FIN 报文被加入到了乱序队列，表明乱序队列是有数据的，于是就会调用 tcp_ofo_queue 函数。



在乱序队列中找到能与当前报文的序列号保持的顺序的报文后，会看该报文是否有 FIN 标志，如果有的话，就会调用 tcp_fin() 函数，如果当前的 TCP 状态为 TCP_FIN_WAIT2，就会发送第四次挥手 ack，然后调用 tcp_time_wait 函数，这个函数里会将 TCP 状态变更为 TIME_WAIT，并启动 TIME_WAIT 的定时器



