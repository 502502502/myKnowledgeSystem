### 1、用threadlocal做了什么，为什么要用，底层实现

我有这样一个需求，就是在整个请求的处理过程中，会多次需要到当前用户对象，所以我想在请求处理之前，从数据库把这个对象加载到内存中，交给spring容器，需要的地方直接用注解注入就行，不用每次都创建。



一开始我想用session存储，使用session的好处是，同一个用户发的请求，不用每一次都去创建用户对象，直接从session获取就行，不同用户发的请求都从自己的session获取，实现并发隔离。而且使用redis替代session后，在分布式环境下，无论哪个结点来处理请求，都能直接获取创建好的用户对象。



但是有一个问题就是，用户对象是可变的，如果进行了用户资料的修改，需要同步到session或者redis，这就比较麻烦了，同步过程还得解决丢失，并发覆盖等问题。而且用户连续发送的多个请求，可能会出现多个线程同时操作同一个session的情况。这就导致一个请求在处理的过程中，它的用户对象是可能会变的，这个会留下一些隐患。



所以我用threadlocal来解决这个问题，去保证每一个线程执行过程中，它的用户对象信息都不会发生修改。在请求处理之前，使用拦截器从数据库加载对象，放到threadlocal中，整个处理过程使用的都是同一个对象，请求处理结束后手动从threadlocal删除用户对象。



> 实现原理

threadlocal有一个静态内部类ThreadLocalMap，这个Map是实现线程隔离的核心，它是自定义的，没有实现Map接口，用了一个Entry数组来存储threadlocal, value键值对，这个key是threadlocal实例，value是绑定的对象。

每个线程都有自己Map对象，用来存储自己线程的所有thtreadlocal对象和它绑定的对象，所以不会存在并发安全问题。

Map是local类的静态内部类，意味着，同样的线程，即使你有多个threadlocal实例，线程都只有一个Map实例，在这个实例里以threadlocal实例为键，存储对象。

> threadlocalMap解决哈希冲突的方式

处理冲突检测的机制是向后移位, 清除过期条目 最终找到合适的位置

> 为什么结束后要删除用户对象

会，当前线程结束后，当前线程对应的map应该被回收，map里的threadlocal，value都应该被回收，但是如果其它线程保持着对local实例的引用，当前对象的Map会被认定为存活对象，不能被回收，map里的threadlocal，value对也会一直存在。

解决办法就是在当前线程使用完local对象后，手动调用remove方法将其从Map中删除。



### 2、用elasticsearch做了什么，为什么要用，底层实现





### 3、用Kafka做了什么，为什么要用，底层实现





### 4、用caffeine做了什么，为什么要用，底层实现





### 5、用redis做了什么，为什么要用，底层实现





### 6、用线程池做了什么，线程池有哪些参数









### 7、用Quartz做了什么，为什么要用，底层实现







### 8、使用springsecurity做了什么，为什么要用，底层实现







### 9、使用docker做了什么，为什么要用，底层实现







### 10、有没有用到事务，为什么要用，底层实现





> spring怎么实现事务





> mysql怎么实现事务





### 11、进行了哪些JVM参数的调整







