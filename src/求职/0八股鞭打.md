### 1、并发

> 进程、线程、协程

进程拥有独立的内存空间和系统资源（内存映射表、虚拟内存信息、文件描述符表），寄存器状态（PC、栈指针）、调度信息

线程是进程内的实体，共享进程的资源（内存空间、虚拟内存信息、文件描述符表），每个线程有自己的寄存器（程序计数器）、栈空间(局部变量、调用信息)和私有数据(threadlocal)



进程切换需要保存和恢复的信息比较多，除了寄存器状态，还需要切换内存空间，文件描述表。因为每个进程都是隔离的虚拟地址，映射规则都不一样，不同进程需要加载自己的内存映射表，才能找到正确的地址。

线程的切换相对较轻，只需要保存和恢复栈和寄存器的状态，地址空间是共享进程的，不需要做修改。



进程奔溃后，不会对其他进程产生影响。

线程的错误可能导致整个进程的崩溃。



线程是由操作系统内核进行调度和切换的，采用的是抢占式调度，也就是说一个线程可以被强制中断以切换到另一个线程。

协程是由用户自己进行调度和切换的，采用的是协作式调度，一个协程需主动让出控制权才会切换到下一个协程。



线程切换通常需要到内核态去做切换，保存和恢复寄存器状态

协程的上下文信息存储在线程的堆区里边，不需要切换到内核状态去修改寄存器状态。



线程是同时运行的，多个线程可以在多个CPU核心上并行执行。

协程运行在单个线程中，只有一个协程处于运行状态，其他协程处于等待状态，因此协程通常用于解决IO密集型任务，而非CPU密集型任务。



线程在同一进程中共享内存空间，可以直接读写共享变量，但需要考虑线程安全性。

协程通常是在单个线程中运行，可以直接访问共享变量而无需考虑线程安全问题。





> 操作系统怎么保证原子性

操作系统有一个指令，叫做“test and set”，将读取内存、判断和设置值作为一个原子操作，在单核操作下能够保证原子性。

多核的情况就复杂一些，但是多个核心是共享总线的，把总线锁住就行。

在cpu芯片上有一个HLOCK Pin，可以通过发送指令来操作，将#HLOCK Pin电位拉低，并持续到这条指令执行完毕，从而将总线锁住。



> Java锁机制

原子类实现CAS锁

synchronized同步锁

reentrantlock可重入锁



> volatile

volatile是Java中的关键字，用来修饰会被不同线程访问和修改的变量。JMM（Java内存模型）是围绕并发过程中如何处理可见性、原子性和有序性这3个特征建立起来的，而volatile可以保证其中的两个特性，就是可见性和有序性。





使用volatile修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，线程操作变量副本并写回主内存。保证了线程每次获取都是从主存拿到最新的数据，每次写入都会写回贮存，被其它线程获取。



 volatile 就可以通过添加内存屏障来保证指令的安全有序，具体来说就是它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；

volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障，来禁止编译器进行重排序。



> Java内存模型的3个特性

可见性：一个线程修改的状态对其它线程可见

原子性：某个操作要么全部执行，要么全部不执行

有序性：一个操作会被编译为多条指令，编译器和处理器为了优化程序性能而对指令序列进行重新排序，可以使用内存屏障来保证指令的有序执行。



> 信号量

操作系统通过内核实现信号量机制，通过几个系统调用，实现信号量初始化，以及PV操作，这些操作所需的原子性通过CPU指令还有硬件实现。

P操作可以获取资源，如果信号量大于0，执行减一操作，如果为0，线程进入阻塞。

V操作可以释放资源，信号量进行加一操作



Java使用Semaphore实现了信号量，通过acquire()和release()实现PV操作。

```java
class Semaphore {
    private AtomicInteger permits;

    public Semaphore(int permits) {
        this.permits = new AtomicInteger(permits);
    }

    public void acquire() throws InterruptedException {
        int currentPermits;
        do {
            currentPermits = permits.get();
            if (currentPermits == 0) {
                Thread.sleep(10); // 如果许可数量为0，则线程休眠一段时间后重试
            }
        } while (!permits.compareAndSet(currentPermits, currentPermits - 1)); // 使用CAS操作尝试获取一个许可
    }

    public void release() {
        permits.incrementAndGet(); // 释放一个许可
    }
}
```




> 操作系统的进程和JVM的进程的区别

JVM运行的进程本质上是操作系统中的一个进程，JVM是单进程的，它所处的进程是被操作系统管理的。

JVM创建的进程会拥有它的一套虚拟内存，JVM对这些内存进行管理，调度。JVM通过创建多线程实现并发。



> mysql什么样的sql走乐观锁，什么走悲观锁

mysql的锁是根据事务的隔离级别来生成的

读未提交不会上锁去限制并发行为；

读提交和

### 2、垃圾回收

> 怎么进行垃圾回收

垃圾回收是通过垃圾回收器来完成的，主要有G1，CMS，serial，parNew;

这些垃圾回收器是搭配使用的，来负责不同的内存区域。

JVM把堆内存分为了年轻代和老年代，erial，parNew是专门做年轻代垃圾回收的，CMS做老年代，G1都可以。

然后GC主要是两种类型，一种是只对年轻代做回收的young GC，一种是对全局内存做回收的Full GC；



年轻代是所有新对象产生的地方。分为3个部分——Enden区和两个Survivor区（From和to）当Eden区被对象填满时，就会执行young GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这个清除的算法是复制算法。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。这个是分代回收的算法。



在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中,老年代空间不足，会触发 full gc。

full GC 可以使用CMS或者G1来完成，CMS是基于标记清除算法的，可以获得最短停顿时间的效果，G1是基于标记整理算法的，可以根据预测的停顿时间选择一些区域进行回收。





> 有哪些垃圾回收算法

**标记-清除**（Mark-sweep）:标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。优缺点：**实现简单，容易产生内存碎片**

**复制**（Copying）将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。 优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。

**标记-整理**（Mark-Compact）先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存 优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，**移动次数多，效率低下**

**分代收集算法**(目前大部分JVM的垃圾收集器所采用的算法） 
年轻代（Young Generation）的回收算法 (回收主要以Copying为主) 
年老代（Old Generation）的回收算法（回收主要以Mark-Compact为主）



> CMS垃圾回收器

简介 以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是 Mark-Sweep 算法。  
场景 如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的 CPU 资源也比较丰富，就适合适用 CMS 收集器。

垃圾回收步骤：

1.  初始标记 (Stop the World 事件 CPU 停顿， 很短) 初始标记仅标记一下 GC Roots 
    能直接关联到的对象，速度很快；
2.  并发标记 (收集垃圾跟用户线程一起执行) 并发标记过程就是进行 GC Roots 查找的过程；
3.  重新标记 (Stop the World 事件 CPU 停顿，比初始标记稍微长，远比并发标记短) 
    修正由于并发标记时应用运行产生变化的标记。
4.  并发清理，标记清除算法；

缺点：

并发标记时和应用程序同时进行，占用一部分线程，所以吞吐量有所下降。 
并发清除时和应用程序同时进行，这段时间产生的垃圾就要等下一次 GC 再清除。 
采用的标记清除算法，产生内存碎片，如果要新建大对象，会提前触发 Full GC 。



> G1垃圾回收器

并行与并发收集器，它能建立可预测的停顿时间模型，即可以设置 [STW](https://so.csdn.net/so/search?q=STW&spm=1001.2101.3001.7020) 的时间。

垃圾回收步骤 
1、初始标记(stop the world 事件 CPU 停顿只处理垃圾)； 
2、并发标记(与用户线程并发执行)； 
3、最终标记(stop the world 事件 ,CPU 停顿处理垃圾)； 
4、筛选回收(stop the world 事件 根据用户期望的 GC 停顿时间回收)

特点

**并发与并行** 充分利用多核 CPU ，使用多核来缩短 STW 时间，部分需要停顿应用线程的操作，仍然可以通过并发保证应用程序的执行。 
**分代回收** 新生代，老年代 
**空间整合** 总体看是采用标记整理算法回收，每个 Region 大小相等，通过复制来回收。 
**可预测的停顿时间** 使用 -XX:MaxGCPauseMillis=200 设置最长目标暂停值。



> CMS和G1区别

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用 
G1收集器收集范围是老年代和新生代。
CMS收集器以最小的停顿时间为目标的收集器。 
G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型） 
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片 
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片



> full GC触发时机

永久代/元空间满
老年代空间不足
显式调用System.gc()
由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。



> 怎么判断对象是否可回收

方法区中的静态属性 
方法区的中的常量 
虚拟机中的局部变量 



>  两个对象循环引用会不会被被GC？

GC里边在JVM当中是使用的ROOT算法，ROOT算法 也就是根; 只要看这个两个对象有没有挂在 根 上, 挂在根上了 就不会被回收; 没有挂在根上就会回收;



### 3、索引

> 索引分类





### 4、事务

> mysql事务



> spring事务



> java事务



> redis事务



> spring事务传播

当事务方法调用了别的事务方法，别的事务方法应该怎么执行的问题。

可以选择在当前事务执行，或者新的事务执行，或者不以事务方式执行



> spring事务失效

1、非public方法加注解

2、远程调用

3、同一个类中的非事务方法调用事务方法

4、try catch内部消化

5、数据库引擎不支持事务



> 分布式事务

两阶段提交，有一个协调者，给所有参与者发送准备提交请求，参与者收到后，做好提交准备，回复同意或者拒绝，如果协调者全部收到同意，就发送提交请求，所有参与者提交事务，返回提交结果，如果有失败的，或者第一阶段有拒绝提交的，协调者发送回滚请求。

两阶段提交存在阻塞问题，可以使用三阶段提交，新增一个预提交状态，通过设置超时时间解决阻塞问题



### 5、数据结构

>  介绍一下B+树/为什么要用B+树做索引/B+树比B树有哪些优点

B+树是一种平衡树，节点的子树高度差不超过一个常数。这保证了树的高度相对较小，从而减少了查询时需要的磁盘访问次数。

B+树的叶子节点通过指针串联成有序链表。可以通过对链表的顺序访问来获取范围查询结果。

B+树的内部节点只保存索引信息，不存储实际数据，减少磁盘IO。一个结点可以保存更多的索引信息，查询的范围会缩小，降低了数的高度，因为你如果每个结点存储的索引少，那就需要更多的高度去减少查询的范围，最终定位到叶子结点。



> 介绍一下平衡树

平衡树会保证子树的高度差在一个常数的范围内，保证了树的高度不会太大，退化成链表

平衡树每一个结点都会存储一个平衡因子，来判断当前结点是否平衡，从而是否需要进行自平衡操作。

自平衡操作是平衡树为了保证子树高度平衡采取的一些措施，去调整树的结构，比如旋转，变色。

常见的平衡树有二叉平衡树，B树和B+树，红黑树等。



> 二叉平衡树是怎么保证高度平衡的

**插入**：

+ 先按照二叉搜索树的插入方式递归的进行插入
+ 然后检测高度是否平衡，如果高度不再平衡，**通过旋转的方式调整**
  + 更新结点的高度

**删除**：

+ 先按照二叉搜索树的方式递归的进行删除
+ 删除后检测左右子树高度以及子树的左右子树高度确认不平衡的原因
+ 根据原因进行不同的旋转操作即可

**左旋**：

+ 旋转点下沉为左子结点，它的右子节点上升父节点，再交换彼此的子树。逆时针旋转

**右旋**：

+ 旋转点下沉为右子节点，它的左子节点上升为父节点，再交换彼此的子树。顺时针旋转

**旋转场景**：

+ LL：导致不平衡的结点在左结点的左结点后边：右旋
+ RR：导致不平衡的结点在右结点的右结点后边：左旋
+ LR：导致不平衡的结点在左结点的右结点后边：先对左节点左旋变成LL
+ RL：导致不平衡的结点在右结点的左结点后边：先对右节点右旋变成RR



> 红黑树的原理

红黑树也是平衡树，但是它的平衡条件没有那么苛刻，不会频繁的触发树结构的调整，降低了旋转的开销。

红黑树是基于2-3树的原理，使用二叉树加上结点颜色实现的。

因为**红节点的出现**是为了模拟2-3树中的3节点，3结点不会增加2-3树的高度，所以红黑树的**高度近似取决于黑节点**。

红黑树每一条**路径的黑色结点数量**都相等。



红黑树结点的颜色有几个特点，第一个就是根节点和叶子节点都是黑色的，第二个就是红色结点不会连续出现。红黑色的自平衡操作是通过变色和旋转来实现的，在插入和删除结点的时候如果破坏了红黑树的性质，就会根据树的结构进行复杂的上升还有下沉操作。具体是哪些情况应该做什么调整，我不太清楚。







HashMap和ConcurrentHashMap

> hashmap put元素的过程

首先是计算元素的hashcode，然后对数组长度进行取模，得到元素应该放到的下标，如果这个位置是空的，直接插入；

如果这个位置不为空，遍历这个桶里的所有元素，看看这个key是不是已经存在了，如果存在，更新。

如果不存在，就把元素加到这个桶中，这个桶可能是一个链表，或者红黑树。

如果是红黑树的话，直接生成新节点即可，如果是链表，还需要判断链表元素数量是否超过8。

如果没有超过8，直接把元素查到链表的尾结点，如果超过8了，需要判断所有元素数量是否超过64。

如果没有超过64，就进行扩容，再进行元素插入，如果超过64了，就会把当前桶的链表转为红黑树。



> 为什么是尾插法

jdk1.7之前插入数据使用的是头插法，这个操作在多线程环境下可能会导致链表成环。

就是在插入元素时，把元素放到头结点，在扩容的时候，有一个线程拿到了头结点，正准备修改next指针指向新位置的头结点的时候，另一个线程获得了CPU执行，把链表这个头结点已经做好了迁移，还迁移了其它结点，这个时候这个头结点在新的表里已经不是头结点了，新的头结点是在原来链表的下边的，但是刚开始的线程不知道，仍然把旧头结点的next指针指向了新表的头结点，这就形成了环。





> 为什么要把链表转化为红黑树，转化为红黑树会有什么问题

在元素比较多的时候，可能会在一个桶发生大量的哈希冲突，导致链表长度很长，查询效率很低，红黑树的查询效率是logn的，比链表的效率要高很多。

但是也会有一些问题，红黑树本身的结点需要额外存储一些信息，比如颜色，会造成额外的内存开销；而且插入的操作会变得复杂，效率低，因为可能会破坏平衡性，需要进行自平衡。



> 为什么临界值是8和64

元素数量比较小的时候，可能直接遍历的效率会高一些，因为红黑树本身结构复杂，需要做自平衡，是需要一些开销的。8是一个相对平衡的分界点。元素数量不超过64，但是链表长度超过8的时候，元素数量也是非常少的，没有必要去使用红黑树，扩容就可以使元素进行重新分布，链表也能达到一个很优秀的效率。



> 为什么hashcode和equals都要比一下？直接用equals不行吗？

如果都对hashcode和equals进行了重写的情况下。

两个元素hashcode相等，value不一定相等，因为hashcode可能会产生哈希冲突；所以需要进一步的equals判断值相等。

直接用equals来判断是可以的，但是首先你得找到元素，如果你不打算使用hashcode去定位元素，那需要遍历桶数组，效率很低。如果使用hashcode去定位元素，假设hashcode都不一样了，就没有必要继续比equals了，肯定不一样。因为对hashcode方法重写后，相同元素应该映射到相同的hashcode。



> hashmap rehash过程

如果还没有初始化，会按照初始化设置的容量进行初始化，否则将容量扩大两倍，然后把旧的元素迁移到新的表里，重新计算下标。



> hashmap是如何定位下标的

首先通过hashcode方法得到元素的hashcode，但是这个时候还不能直接计算下标，计算下标使用的计算原理是取模，取模有一个特点，就是高的位会被忽略，不参与下标。如果多个元素的hashcode高位不同，低位相同，直接取模就会造成很多的冲突，但是如果高位也参与计算，也许就不会冲突了，所以使用了一个hash函数对hashcode进行了扰动，将高位和地位进行了异或运算。

当然最后这个取模也不是真的取模，因为hashmap的容量是2的幂，使用扰动后的hash对容量-1进行与运算，效果是和取模一样的。





>  hashmap是怎么计数的

hashmap中有一个计数器，获取元素数量的时候直接返回，不需要遍历表。



> hashmap多线程有哪些安全问题，怎么解决

jdk1.8的实现里，hashmap使用尾插法解决了多线程扩容链表成环的问题。

但是还存在其它的问题，比如多线程put元素，可能会覆盖掉其中一个；

还有多线程put和remove，本应该先删除旧值，然后put新值，但是由于线程竞争，可能先put，才执行的remove，新元素被错误删除。



解决hashmap的线程安全问题有几个方法：

第一个就是手动对修改hahsmap的代码进行加锁，使用synchronized关键字

第二个就是使用collections提供的synchronousMap方法，把hashmap的方法进行了同步的包装，本质上也是使用`synchronized`进行了方法加。

第三个是使用hashtable，hashtable对修改元素的方法都使用了`synchronized`进行加锁

第四个是使用concurrentHashMap，concurrenthashMap在jdk1.8以后，只对桶数组的具体下标头结点或者根节点进行了加锁。其它的下标仍然可以进行操作，效率会高很多。



> concurrenthashma是怎么保证线程安全的

首先通过volatile关键字修饰共享的成员变量，保证多线程下的可见性。

其次通过CAS和synchronized同步锁保证线程安全。

以put元素为例，如果下标位置为空，会使用cas尝试插入元素，如果插入失败，说明有其它线程已经插入了元素，应该使用其它的插入方法。如果当前正在扩容，先帮忙参与扩容，再执行插入。下标位置第一个元素的hash在扩容的时候，会修改为-1，通过这个就可以判断是不是在扩容。

如果没有扩容，会把当前下标的第一个元素加上synchronized锁，然后根据链表或者红黑树的插入方式进行插入。插入完成后，修改元素计数器，同时检查是否需要扩容。



> CAS的原理

CAS 表示比较与替换，里面有3个参数，分别是目标内存地址、旧值、新值，每次判断的时候，会将旧值与目标内存地址中的值进行比较，如果相等，就将新值更新到内存地址里，如果不相等，就继续循环，直到操作成功为止	



> ConcurrentHashMap不能解决什么问题呢？

concurrentHashMap只是在集合内部保证了线程安全，但是调用的业务如果出现了安全问题，也不能保证正确的执行结果，比如我在业务层需要先判断key是不是空的，是空的或者某一个特定的值的时候才插入，可能在判断完之后，插入之前，已经有其它线程插入了，最后会被覆盖掉。





> ArrayList扩容



> hashMap扩容





> concurrent扩容





> redis  hash扩容





> SDS底层实现



> 跳表底层实现



> Hyperloglog底层实现



> quicklist底层实现





### 6、自动配置

> spring启动时怎么加载配置文件的

Spring通过ApplicationContext接口的实现类来加载和解析XML配置文件。
加载过程中，Spring会读取XML配置文件的内容，并使用XML解析器（如DOM或SAX解析器）解析XML文档，将配置信息转化为Spring内部的数据结构（如Bean定义对象），注入到spring容器。



> springboot启动过程

1、加载启动类

Spring Boot应用程序的入口是一个Java类，通常使用@SpringBootApplication注解进行标记。@SpringBootApplication注解是一个复合注解，包含了@Configuration、@EnableAutoConfiguration和@ComponentScan等注解。
2、创建Spring Application上下文

Spring Boot会创建一个Spring Application上下文，用于管理应用程序中的所有Bean。
上下文是基于Spring Framework构建的，可以实现依赖注入和管理Bean的生命周期。
3、执行自动配置

Spring Boot根据应用程序的依赖关系和类路径上的内容，自动配置各种功能和组件。
自动配置是通过@EnableAutoConfiguration注解实现的，它会根据classpath上的依赖项自动添加所需的配置。
4、启动嵌入式Web服务器

如果应用程序需要使用Web功能，Spring Boot会启动一个嵌入式的Web服务器（如Tomcat、Jetty或Undertow）。
嵌入式Web服务器会监听指定的端口，并接收和处理传入的HTTP请求。

> springboot自动配置原理





> `@Autowired`和`@Resource`

`@Autowired`是Spring提供的注解，`@Resource`是Java标准的注解。

`@Autowired`按照类型进行自动装配，`@Resource`默认按照名称进行自动装配

当无法找到匹配的Bean时，`@Autowired`注解的required属性默认为true，会抛出异常。`@Resource`如果找不到匹配的Bean，会将字段设置为Null。



### 7、JavaAPI

> 重写hashCode

```java
 @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
```



> 重写equals()

```java
public class MyClass {
    private int id;
    private String name;

    // 构造函数、getter 和 setter 方法等省略...

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }

        MyClass other = (MyClass) obj;
        return id == other.id && name.equals(other.name);
    }
}
```



> 单例

```java
public enum A {
    getInstance();
}


public class A {
    private static class Inner{
        public static final A a = new A();
    }
    public static A getInstance(){
        return Inner.a;
    }
}

public class A {
    private static volatile A a;
    public static A getInstance(){
        if(a == null){
            synchronized(A.class) {
                if(a == null) {
                    a = new A();
                }
            }
        }
        return a;
    }
}
```



> ApplicationContext

ApplicationContext 接口是 Spring 框架中的核心接口之一，它继承了以下几个重要的接口：

1、BeanFactory 接口：ApplicationContext 扩展了 BeanFactory 接口，提供了更高级的功能和扩展性。BeanFactory 是 Spring IoC 容器的基本接口，定义了管理和获取 bean 的基本方法。

2、ListableBeanFactory 接口：ApplicationContext 继承了 ListableBeanFactory 接口，该接口在 BeanFactory 的基础上增加了对 bean 列表的操作。它提供了一系列遍历和检索 bean 的方法，如根据类型、名称、注解等条件获取 bean。

3、HierarchicalBeanFactory 接口：ApplicationContext 还继承了 HierarchicalBeanFactory 接口，该接口定义了分层结构的 bean 工厂。通过层级关系，可以实现 bean 的继承和重载等特性。

4、MessageSource 接口：ApplicationContext 拓展了 MessageSource 接口，用于支持国际化和本地化的消息处理。MessageSource 提供了获取和解析消息文本的方法，使应用程序能够根据不同的语言和地区显示相应的消息。

5、ApplicationEventPublisher 接口：ApplicationContext 实现了 ApplicationEventPublisher 接口，用于发布和监听应用程序事件。通过该接口，我们可以定义和触发自定义的事件，并在需要的地方监听和处理这些事件。



> BeanFactory

BeanFactory 提供了以下主要功能：

1、 负责创建对象，并配置类型、作用域、依赖关系以及属性值等信息。

2、负责管理 bean 的生命周期，确保 bean 在被创建和销毁时执行相关的操作。

3、将依赖的 bean 注入到目标对象中，不需要手动处理对象之间的关联。

4、提供了多种方法来获取和管理 bean。可以根据 bean 的名称、类型、注解等条件进行检索和获取，还支持单例、原型等不同的作用域。



### 8、SQL查询

> 查询很慢

1、为字段加索引

2、explain检查是否走索引

3、限制结果集大小和分页，过滤记录

5、避免不必要的字段查询

6、避免不必要的JOIN和子查询





### 9、代码测试



> 测试方法

1、单元测试：验证每个函数的预期行为，并确保其在各种输入情况下都能正常工作。

2、集成测试：多个模块、类或服务之间的集成点，检查它们是否能够正确地互相通信和协调工作。
3、功能测试：对整个系统或应用程序的功能进行测试，以验证其是否按照预期执行。
4、性能测试：在正常和高负载情况下的性能和响应时间。
5、冒烟测试：执行一小部分核心功能或关键路径，确保系统的主要功能没有严重问题。



> 异常

继承Throwable类，有Exception和Error

Exception有两种，一种受检查，就是编译器就能检查出来的错误，比如classnotfount，IOException;

另一种是运行时发生的异常，比如类型转换异常，空指针，数组越界等。



> finally中可以抛出异常吗

语法上可以，但是不建议

因为会覆盖掉try中发生的异常