### 1、并发

> 进程、线程、协程



> 操作系统怎么保证原子性

操作系统有一个指令，叫做“test and set”，将读取内存、判断和设置值作为一个原子操作，在单核操作下能够保证原子性。

多核的情况就复杂一些，但是多个核心是共享总线的，把总线锁住就行。

在cpu芯片上有一个HLOCK Pin，可以通过发送指令来操作，将#HLOCK Pin电位拉低，并持续到这条指令执行完毕，从而将总线锁住。

> Java锁机制

乐观锁CAS



> 同步工具



> volatile



> 信号量



### 2、垃圾回收

> 怎么进行垃圾回收



> 有哪些垃圾回收器



> 有哪些垃圾回收算法



> CMS过程是什么样的



> young GC的过程



> full GC过程



> 怎么判断对象是否可回收









### 3、索引

> 索引分类





### 4、事务

> mysql事务



> spring事务



> java事务



> redis事务





### 5、数据结构

>  介绍一下B+树/为什么要用B+树做索引/B+树比B树有哪些优点

B+树是一种平衡树，节点的子树高度差不超过一个常数。这保证了树的高度相对较小，从而减少了查询时需要的磁盘访问次数。

B+树的叶子节点通过指针串联成有序链表。可以通过对链表的顺序访问来获取范围查询结果。

B+树的内部节点只保存索引信息，不存储实际数据，减少磁盘IO。一个结点可以保存更多的索引信息，查询的范围会缩小，降低了数的高度，因为你如果每个结点存储的索引少，那就需要更多的高度去减少查询的范围，最终定位到叶子结点。



> 介绍一下平衡树

平衡树会保证子树的高度差在一个常数的范围内，保证了树的高度不会太大，退化成链表

平衡树每一个结点都会存储一个平衡因子，来判断当前结点是否平衡，从而是否需要进行自平衡操作。

自平衡操作是平衡树为了保证子树高度平衡采取的一些措施，去调整树的结构，比如旋转，变色。

常见的平衡树有二叉平衡树，B树和B+树，红黑树等。



> 二叉平衡树是怎么保证高度平衡的

**插入**：

+ 先按照二叉搜索树的插入方式递归的进行插入
+ 然后检测高度是否平衡，如果高度不再平衡，**通过旋转的方式调整**
  + 更新结点的高度

**删除**：

+ 先按照二叉搜索树的方式递归的进行删除
+ 删除后检测左右子树高度以及子树的左右子树高度确认不平衡的原因
+ 根据原因进行不同的旋转操作即可

**左旋**：

+ 旋转点下沉为左子结点，它的右子节点上升父节点，再交换彼此的子树。逆时针旋转

**右旋**：

+ 旋转点下沉为右子节点，它的左子节点上升为父节点，再交换彼此的子树。顺时针旋转

**旋转场景**：

+ LL：导致不平衡的结点在左结点的左结点后边：右旋
+ RR：导致不平衡的结点在右结点的右结点后边：左旋
+ LR：导致不平衡的结点在左结点的右结点后边：先对左节点左旋变成LL
+ RL：导致不平衡的结点在右结点的左结点后边：先对右节点右旋变成RR



> 红黑树的原理

红黑树也是平衡树，但是它的平衡条件没有那么苛刻，不会频繁的触发树结构的调整，降低了旋转的开销。

红黑树是基于2-3树的原理，使用二叉树加上结点颜色实现的。

因为**红节点的出现**是为了模拟2-3树中的3节点，3结点不会增加2-3树的高度，所以红黑树的**高度近似取决于黑节点**。

红黑树每一条**路径的黑色结点数量**都相等。



红黑树结点的颜色有几个特点，第一个就是根节点和叶子节点都是黑色的，第二个就是红色结点不会连续出现。红黑色的自平衡操作是通过变色和旋转来实现的，在插入和删除结点的时候如果破坏了红黑树的性质，就会根据树的结构进行复杂的上升还有下沉操作。具体是哪些情况应该做什么调整，我不太清楚。







HashMap和ConcurrentHashMap

> hashmap put元素的过程

首先是计算元素的hashcode，然后对数组长度进行取模，得到元素应该放到的下标，如果这个位置是空的，直接插入；

如果这个位置不为空，遍历这个桶里的所有元素，看看这个key是不是已经存在了，如果存在，更新。

如果不存在，就把元素加到这个桶中，这个桶可能是一个链表，或者红黑树。

如果是红黑树的话，直接生成新节点即可，如果是链表，还需要判断链表元素数量是否超过8。

如果没有超过8，直接把元素查到链表的尾结点，如果超过8了，需要判断所有元素数量是否超过64。

如果没有超过64，就进行扩容，再进行元素插入，如果超过64了，就会把当前桶的链表转为红黑树。



> 为什么是尾插法

jdk1.7之前插入数据使用的是头插法，这个操作在多线程环境下可能会导致链表成环。

就是在插入元素时，把元素放到头结点，在扩容的时候，有一个线程拿到了头结点，正准备修改next指针指向新位置的头结点的时候，另一个线程获得了CPU执行，把链表这个头结点已经做好了迁移，还迁移了其它结点，这个时候这个头结点在新的表里已经不是头结点了，新的头结点是在原来链表的下边的，但是刚开始的线程不知道，仍然把旧头结点的next指针指向了新表的头结点，这就形成了环。





> 为什么要把链表转化为红黑树，转化为红黑树会有什么问题

在元素比较多的时候，可能会在一个桶发生大量的哈希冲突，导致链表长度很长，查询效率很低，红黑树的查询效率是logn的，比链表的效率要高很多。

但是也会有一些问题，红黑树本身的结点需要额外存储一些信息，比如颜色，会造成额外的内存开销；而且插入的操作会变得复杂，效率低，因为可能会破坏平衡性，需要进行自平衡。



> 为什么临界值是8和64

元素数量比较小的时候，可能直接遍历的效率会高一些，因为红黑树本身结构复杂，需要做自平衡，是需要一些开销的。8是一个相对平衡的分界点。元素数量不超过64，但是链表长度超过8的时候，元素数量也是非常少的，没有必要去使用红黑树，扩容就可以使元素进行重新分布，链表也能达到一个很优秀的效率。



> 为什么hashcode和equals都要比一下？直接用equals不行吗？

如果都对hashcode和equals进行了重写的情况下。

两个元素hashcode相等，value不一定相等，因为hashcode可能会产生哈希冲突；所以需要进一步的equals判断值相等。

直接用equals来判断是可以的，但是首先你得找到元素，如果你不打算使用hashcode去定位元素，那需要遍历桶数组，效率很低。如果使用hashcode去定位元素，假设hashcode都不一样了，就没有必要继续比equals了，肯定不一样。因为对hashcode方法重写后，相同元素应该映射到相同的hashcode。



> hashmap rehash过程

如果还没有初始化，会按照初始化设置的容量进行初始化，否则将容量扩大两倍，然后把旧的元素迁移到新的表里，重新计算下标。



> hashmap是如何定位下标的

首先通过hashcode方法得到元素的hashcode，但是这个时候还不能直接计算下标，计算下标使用的计算原理是取模，取模有一个特点，就是高的位会被忽略，不参与下标。如果多个元素的hashcode高位不同，低位相同，直接取模就会造成很多的冲突，但是如果高位也参与计算，也许就不会冲突了，所以使用了一个hash函数对hashcode进行了扰动，将高位和地位进行了异或运算。

当然最后这个取模也不是真的取模，因为hashmap的容量是2的幂，使用扰动后的hash对容量-1进行与运算，效果是和取模一样的。





>  hashmap是怎么计数的

hashmap中有一个计数器，获取元素数量的时候直接返回，不需要遍历表。



> hashmap多线程有哪些安全问题，怎么解决

jdk1.8的实现里，hashmap使用尾插法解决了多线程扩容链表成环的问题。

但是还存在其它的问题，比如多线程put元素，可能会覆盖掉其中一个；

还有多线程put和remove，本应该先删除旧值，然后put新值，但是由于线程竞争，可能先put，才执行的remove，新元素被错误删除。



解决hashmap的线程安全问题有几个方法：

第一个就是手动对修改hahsmap的代码进行加锁，使用synchronized关键字

第二个就是使用collections提供的synchronousMap方法，把hashmap的方法进行了同步的包装，本质上也是使用`synchronized`进行了方法加。

第三个是使用hashtable，hashtable对修改元素的方法都使用了`synchronized`进行加锁

第四个是使用concurrentHashMap，concurrenthashMap在jdk1.8以后，只对桶数组的具体下标头结点或者根节点进行了加锁。其它的下标仍然可以进行操作，效率会高很多。



> concurrenthashma是怎么保证线程安全的

首先通过volatile关键字修饰共享的成员变量，保证多线程下的可见性。

其次通过CAS和synchronized同步锁保证线程安全。

以put元素为例，如果下标位置为空，会使用cas尝试插入元素，如果插入失败，说明有其它线程已经插入了元素，应该使用其它的插入方法。如果当前正在扩容，先帮忙参与扩容，再执行插入。下标位置第一个元素的hash在扩容的时候，会修改为-1，通过这个就可以判断是不是在扩容。

如果没有扩容，会把当前下标的第一个元素加上synchronized锁，然后根据链表或者红黑树的插入方式进行插入。插入完成后，修改元素计数器，同时检查是否需要扩容。



> CAS的原理

CAS 表示比较与替换，里面有3个参数，分别是目标内存地址、旧值、新值，每次判断的时候，会将旧值与目标内存地址中的值进行比较，如果相等，就将新值更新到内存地址里，如果不相等，就继续循环，直到操作成功为止	



> ConcurrentHashMap不能解决什么问题呢？

concurrentHashMap只是在集合内部保证了线程安全，但是调用的业务如果出现了安全问题，也不能保证正确的执行结果，比如我在业务层需要先判断key是不是空的，是空的或者某一个特定的值的时候才插入，可能在判断完之后，插入之前，已经有其它线程插入了，最后会被覆盖掉。





> ArrayList扩容



> hashMap扩容





> concurrent扩容





> redis  hash扩容





> SDS底层实现



> 跳表底层实现



> Hyperloglog底层实现



> quicklist底层实现









