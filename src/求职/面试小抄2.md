### 1、Java8新特性

Java8新特性包括**Lambda表达式、Stream API、接口默认方法**等

Java11新特性包括**ZGC、Epsilon GC、HTTP Client API**等²

Java17新特性包括**Sealed Class**。

### 2、Java内存模型

Java内存模型（Java Memory Model，JMM）是一种**虚拟机规范**，用于**屏蔽掉各种硬件和操作系统的内存访问差异**，以实现让**Java程序在各种平台下都能达到一致的并发效果**。Java内存模型是通过**在变量修改后将新值同步回主内存**，**在变量读取前从主内存刷新变量值**的这种依赖主内存作为传递媒介的方式来实现的。Java 内存模型还规定了在执行八种基本操作时，必须满足如下规则：**不允许 read 和 load、store 和write 操作之一单独出现**；**不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中**；**不允许一个线程无原因地（没有发生过任何相关的同步操作）看到另一个线程的操作结果**；**如果一个变量被 volatile 修饰，则对它的写操作就会立即刷新到主内存中，而读操作就会从主内存中读取最新值**。

### 3、**TCP 和 UDP 区别：**

*1. **连接***

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 服务对象*

- TCP 是一对一的**两点服务**，即一条连接只有两个端点。
- UDP 支持**一对一、一对多、多对多**的交互通信

*3. 可靠性*

- TCP 是**可靠交付数据**的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。

*4. 拥塞控制、流量控制*

- TCP 有**拥塞控制和流量控制**机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

*5. 首部开销*

- **TCP 首部长度较长**，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

*6. 传输方式*

- TCP 是**流式传输**，没有边界，但保证顺序和可靠。
- UDP 是**一个包一个包的发送**，是有边界的，但可能会丢包和乱序。

*7. 分片不同*

- TCP 的数据大小如果大于 **MSS** 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会**在 IP 层进行分片**，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

### 3、TCP 和 UDP 应用场景

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` **文件传输**；
- **HTTP / HTTPS**；

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 **`DNS` 、`SNMP`** 等；
- **视频、音频**等多媒体通信；
- **广播**通信；

### 4、kafka重复消费和消息丢失

**重复消费**

消费后的数据，offset没有提交（消费系统宕机、重启、自动提交）



**消息丢失**

producer发送消息后，由于网络等原因，没有到kafka;

Kafka为了提高吞吐量和性能，采用**异步批量的刷盘**策略，如果系统挂掉，数据就会丢失。

消费者先提交offset，再消费。



**解决办法**

重复消费：offset机制，保证幂等性

消息丢失：ACK确认机制；同步刷盘；先消费后提交；

### 5、数据库三范式

第一范式每一**列都是不可分割**的原子项。

第二范式，**非主键属性必须依赖于主键**属性。

第三范式，**非主键属性必须直接依赖于主键**，而不能间接依赖于主键。

### 6、mysql存储过程

MySQL存储过程是一种**在数据库中存储复杂程序，以便外部程序调用**的一种数据库对象。存储过程是为了**完成特定功能的SQL语句集**，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数 (需要时)来调用执行。

### 7、mysql优缺点

- 优点：
    - **体积小、速度快、总体拥有成本低，开源，提供的接口支持多种语言连接操作**。
    - MySQL 的核心程序采用完全的**多线程编程**。
- 缺点：
    - 不支持**热备份**。
    - 不支持**自定义数据类型**。
    - MySQL最大的缺点是其**安全系统，主要是复杂**而非标准，另外只有到调用mysqladmin来重读用户权限时才发生改变。

### 8、进程和线程的区别

进程是操作系统**资源分配**的基本单位，而线程是**任务调度和执行**的基本单位。

线程是进程内的一个执行单元，进程内至少有一个线程，它们**共享进程的地址空间**，而进程有自己**独立的地址空间**。

同一个进程内的线程**共享进程的资源**，如内存、I/O等。

### 9、synchronized和 ReentrantLock区别

1. 用法不同：synchronized可以用来修饰普通方法、静态方法和代码块，而ReentrantLock**只能用于代码块**。
2. 获取锁和释放锁的机制不同：synchronized是**自动加锁和释放锁**，而ReentrantLock则需要手动获取和释放锁。
3. ReentrantLock可以实现**公平锁**，而synchronized只能是非公平锁。

### 10、堆和栈的区别

线程是否共享

存储的对象是什么

是否有垃圾回收机制

### 11、spring是什么

企业级应用程序开发框架，简化企业级应用程序开发。

+ 实现了IOC容器，对Java对象进行管理，降低对象替换的复杂性。
+ 使用AOP增强，实现事务，日志，异常的统一配置和管理。
+ 方便集成其它的优秀框架，例如mybatics
+ 降低JavaEEAPI的使用难度，例如JDBC，远程调用
+ 方便测试程序，支持Junit

### 12、spring主要模块

+ 核心容器：提供控制反转和依赖注入，管理been对象。
+ web：提供了web程序的开发功能，例如MVC框架。
+ 数据访问：提供了对数据库的操作等，例如JDBC，对象关系映射。
+ 测试：提供单元测试和集成测试
+ AOP：提供面向切面编程的实现，将代码按照功能进行分类

### 13、IOC

将对象的创建和依赖的管理从程序代码移动到外部容器。

### 14、AOP

在不修改原有代码的情况下动态增强某个类或方法的职责。

### 15、序列化和反序列化

序列化是指**将对象转换为字节序列**，而反序列化则是**将字节序列转换成目标对象**。

序列化最重要的作用是在**传递和保存对象**时保证对象的完整性和可传递性。

Java实现序列化有两种方式： 实现 **Serializable 接口** 和 实现 Externalizable 接口。

### 16、JVM内存分配方式

**指针碰撞**是指当堆中的**内存比较整齐**，即用过的内存和空闲内存有一条清晰的分界线（分界线处有个指针作为分界点指示器）时，可以使用这种方法。

**空闲列表**是指当堆中的**内存比较零散**，即用过的内存和空闲内存没有一条清晰的分界线时，可以使用这种方法。

### 17、操作系统如何管理文件和磁盘

操作系统管理磁盘的方式有很多，其中最常见的是文件系统。

文件系统是一种操作系统用来**管理和组织计算机上文件和目录**的方法。

创建一个新的文件或文件夹时，操作系统会将其存储在磁盘上，并将其添加到文件系统中。

需要访问这些文件时，操作系统会查找它们的位置并将它们加载到内存中

### 18、tcp可以看见https加密前的明文吗

不能，tls加密数据后才将加密数据交付给传输层传输，tcp看不到加密前的报文

### 19、servlet重要方法

1. **init()**方法：当Servlet被实例化时，容器会调用init()方法来初始化Servlet。在这个方法中，你可以执行一些初始化操作，例如读取配置文件、建立数据库连接等。
2. **service()**方法：当客户端发送请求时，容器会调用service()方法来处理请求。在这个方法中，你可以获取请求参数、执行业务逻辑等。
3. **destroy()**方法：当Servlet被销毁时，容器会调用destroy()方法来释放资源。在这个方法中，你可以关闭数据库连接、释放内存等。

### 20、InnoDB和MyISAM区别

1. InnoDB支持**事务**，而MyISAM不支持事务。

2. InnoDB支持**行级锁**，而MyISAM只支持表级锁。

3. InnoDB支持**外键约束**，而MyISAM不支持外键约束。

4. InnoDB支持**MVCC**（多版本并发控制），而MyISAM不支持MVCC。

5. InnoDB的数据**存储方式**是聚集索引，而MyISAM的数据存储方式是堆表。

### 21、什么是存储引擎

存储引擎是数据库管理系统中**负责数据存储和检索**的模块。它们负责将数据存储在磁盘上，并**提供一些API**来让用户对数据进行操作。

### 22、mysql语句执行过程

客户端通过连接器**建立连接**，这个操作进行**权限验证**，通过之后会先前往**缓存**，根据sql作为key去查询，查到直接返回，否者前往分析器，经过分析器对sql**语句的分析**、解析，得到一个mysql可以理解的**语法**，随后进入优化器，mysql会根据你查询的条件进行**适当的优化**，之后在经过**执行器**，这就真正的开始**前往存储引擎查询数据**，最后将查询到的数据**返回给客户端**，顺便写入缓存（不一定）

### 23、堆排序是怎么实现的

 **堆的性质**

+ 完全二叉树
+ 每个节点的值都大于或等于其子节点的值

 **基本思想**

+ 自底向上将待排序的序列**构造成一个最大堆**，此时序列的最大值为根节点
+ 每次从堆顶选择一个最值，放到堆的最下边，然后重新调整堆的结构，已经选出来的值不参与堆调整。一直重复直到最大堆只剩下一个元素，就完成了堆排序，本质上还是一个选择排序

### 24、事务隔离级别

+ 多事务并发执行时，会产生一些问题，根据不同的场景可能需要不同的解决策略，来隔离多个事务的执行
+ 有些事务要求的隔离性比较强，有些事务对隔离性的要求没有那么强，因此根据隔离事务的强弱制定了一些不同的隔离策略，这就是隔离级别
+ 读未提交、读提交 、可重复读、串行化
+ 讲含义，讲实现

### 25、BST树

> **介绍**

是一颗结点有序的二叉树，左子树的所有结点值都小于当前结点，右子树的所有结点值都大于当前结点，**平均查找效率是O(lgn)，但是在极端情况下会退化为链表。**

> **实现**

**数据结构：**

+ 结点的数据结构包含存储内容以及左右子节点。

**插入：**

+ 在插入结点时先进行二分检索，找到插入位置，插入即可。

**删除：**

+ 在删除结点时需要先找到一个**替代结点**，替代待删除结点，再递归的删除那个替代结点，替代结点会出现在左子树的最右边或者右子树的最左边，都在叶子结点，删除之后不会影响查找树的性质。

### 26、AVL树

> **介绍**

是一颗高度平衡的二叉查找树，**左右子树的高度差值**不超过1，可以保证**查找效率最坏也能达到O(lgn)**，但是高度平衡要求比较严格，需要**频繁的通过旋转来保持树的平衡**。

> **实现**

**数据结构**

+ 结点的数据结构中包含左右结点指针，存储的内容，以及**以当前结点为根的子树高度**。

**插入**：

+ 先按照二叉搜索树的插入方式递归的进行插入
+ 然后检测高度是否平衡，如果高度不再平衡，**通过旋转的方式调整**
  + 更新结点的高度

**删除**：

+ 先按照二叉搜索树的方式递归的进行删除
+ 删除后检测左右子树高度以及子树的左右子树高度确认不平衡的原因
+ 根据原因进行不同的旋转操作即可



**左旋**：

+ 旋转点下沉为左子结点，它的右子节点上升父节点，再交换彼此的子树。逆时针旋转

**右旋**：

+ 旋转点下沉为右子节点，它的左子节点上升为父节点，再交换彼此的子树。顺时针旋转

**旋转场景**：

+ LL：导致不平衡的结点在左结点的左结点后边：右旋
+ RR：导致不平衡的结点在右结点的右结点后边：左旋
+ LR：导致不平衡的结点在左结点的右结点后边：先对左节点左旋变成LL
+ RL：导致不平衡的结点在右结点的左结点后边：先对右节点右旋变成RR



### 26、B树

**介绍**

**实现**

### 26、红黑树

> **介绍**

红黑树是一颗**基于2-3树或者2-3-4实现的高度平衡的二叉查找树**，具有查找树的性质，也具有平衡树的性质，**查找、插入和删除在最坏情况下都能达到O(lgn)效率**。

在基于**2-3树的实现**里，不会出现4结点，也就是**黑结点不会有两个红子节点**，红节点只能作为左子结点，在这个限制下插入和删除的平衡调整会简单很多。

在基于**2-3-4树的实现**里，会出现**黑节点有两个红子结点**的情况，在插入和删除时需要考虑更加复杂的情况。

红黑树的高度是平衡的，因为**红节点的出现**是为了模拟2-3树中的3节点，3结点不会增加2-3树的高度，所以红黑树的**高度近似取决于黑节点**，而红黑树每一条**路径的黑色结点数量**都相等，所以红黑树是一个**黑色平衡**的树，左右子树高度差最大只能只能是比较矮的子树的高度。

红黑树结点不是黑色就是红色，**根节点是黑色，叶结点是黑色**的空结点，**红色结点不会连续出现**，任意**路径包含相同数量黑色结点**。

> **实现**

**数据结构**

+ 

**插入**：

+ 插入结点设置为红色的，因为红色结点的插入不会破坏黑平衡。

+ 先用二分检索找到插入位置，根据插入位置父亲和兄弟的颜色情况进行不同的调整。

+ 如果父亲是黑的，直接插入，如果形成了4结点，就将子节点分裂为黑节点，父节点变成红结点上升到上一层。

+ 如果父亲是红的，那就会出现两个连续红结点，如果是右倾，先进行一次左旋变成左倾连续红结点，如果是左倾，那就是连续左倾红结点，接下来对黑色父结点进行一次右旋，此时黑色平衡被破坏了，需要交换一下颜色变成4结点，保持黑色平衡，再对这个4结点进行分裂和上升结合即可。

**删除**：

+ 首先对结点进行搜索，同时进行非2结点化，将路径上的结点全部变成3结点或者临时4结点。
  + 根节点直接合并两个子节点，变成4结点；
  + 除了根节点以外，父亲都会是一个非2结点；
  + 如果兄弟是2结点，就把父亲下沉，合并两个子节点，变成4结点；
  + 如果兄弟是非2结点，就把父亲下沉，与当前结点变成一个3结点； 
+ 找到待删除结点后直接删除红节点即可，不会破坏黑色平衡



### 27、锁升级

在Java中，锁的升级是由虚拟机自动完成的，具体的过程如下：

1. 偏向锁： 当一个线程第一次访问一个没有锁定的对象时，JVM会将该对象的对象头设置为偏向锁，并且将线程id记录到对象头中。之后，该线程每次访问该对象时，都不需要进行同步操作，因为它已经拥有了偏向锁。
2. 轻量级锁： 当另一个线程尝试获取一个拥有偏向锁的对象时，JVM会将其升级为轻量级锁。轻量级锁是通过CAS（Compare And Swap）实现的，即线程尝试使用CAS操作把对象头中的线程ID替换成自己的ID，如果成功则获得锁，失败则表示有竞争，此时锁就会退化为重量级锁。
3. 重量级锁： 当一个线程获取锁失败时，就会进入到阻塞状态，此时锁就被升级为重量级锁。重量级锁是通过操作系统的互斥量实现的，即在内核态进行同步操作。重量级锁会导致线程的上下文切换，降低了程序的执行效率，因此尽量避免长时间持有重量级锁。



### 28、怎么维护线程安全

1. 使用锁机制： 通过在关键代码段或者资源上设置锁，保证同一时间只有一个线程可以访问它，其他线程必须等待锁的释放。Java提供了多种锁的实现方式，例如synchronized关键字、ReentrantLock类、ReadWriteLock类等。
2. 使用原子变量： 原子变量可以保证对共享变量的操作是原子性的，在同一时间只能有一个线程对它进行修改，从而保证线程安全。Java提供了多种原子变量的实现方式，例如AtomicInteger、AtomicLong、AtomicReference等。
3. 使用线程安全的集合类： Java中提供了多种线程安全的集合类，例如ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue等，这些集合类都是线程安全的，可以在多线程环境下安全地对其中的数据进行操作。
4. 使用可变对象的不可变副本： 如果需要在多线程环境下共享数据，为了避免数据被篡改，可以使用可变对象的不可变副本来保证线程安全。例如，可以将ArrayList封装为一个不可变的List，通过Collections.unmodifiableList()方法创建一个只读的List，从而避免多个线程同时修改数据。



### 29、什么是数字签名

验证数据完整性和身份认证

1. 密钥对生成：首先，需要生成一对密钥，包括私钥和公钥。私钥由签名者自己保留，用于生成数字签名；公钥公开给其他人用于验证签名。
2. 数据哈希：将待签名的数据使用哈希函数生成一个固定长度的摘要。哈希函数是将任意长度的数据映射为固定长度输出的算法，具有唯一性和不可逆性。
3. 数字签名生成：使用私钥对数据的哈希值进行加密，生成数字签名。加密过程使用的是非对称加密算法，如RSA或DSA。私钥只有签名者本人拥有，因此只有签名者才能生成正确的数字签名。
4. 数字签名验证：接收到带数字签名的数据后，接收方可以使用签名者的公钥对数字签名进行解密，得到数据的哈希值。然后，接收方自行对接收到的原始数据进行哈希运算，得到另一个哈希值。最后，接收方将解密得到的哈希值与自行计算的哈希值进行比较。如果两个哈希值完全一致，则说明数据未被篡改，数字签名有效。