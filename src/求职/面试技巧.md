#### 1、学过哪些课程

**计算机基础**

+ 数字电路
+ 计组
+ 编译原理
+ 计算机科学导论
+ 计算机网络
+ 操作系统

**语言方面**

+ c
+ c++
+ Java
+ python
+ c#

**重要课程**

+ 面向对象
+ 数据结构
+ 算法分析
+ 数据库原理
+ 设计模式
+ 网页设计和网站建设
+ JavaEE、

**软件模块**

+ 软件工程
+ 软件系统设计
+ 软件项目管理
+ 质量测试
+ UML建模语言



#### 2、做过哪些实验、项目

+ 不围棋算法设计：设计一个算法实现最优下棋策略，基于蒙特卡洛树搜索，极小化极大算法的贪心算法。
+ 操作系统课设：读者和写者问题，c#和unity的多线程信号量控制解决读写问题
+ 网络管理和协议分析：交换机配置，socket编程，网络包的编写和捕获分析。
+ c++课设：多线程的通讯系统，socket实现网络通讯，以及多线程实现多人聊天，好友的增删改查，群聊的管理。
+ python实验：图像识别背景替换
+ 在线博客论坛：基于springboot搭建的一个Java应用程序



#### 3、新技术是怎么学习的

+ 教材：重要，经典

+ 视频：入门，快速上手，理解

+ 官方文档：实践性强，框架，中间件

+ 博客，专栏：零碎的知识点，google或者百度

+ 实践：linux，网络管理和协议分析，网站建设等实践性很强的知识

  

#### 4、课余有哪些爱好

+ 健身

+ 打羽毛球

+ 跑步

+ 游戏

+ 小说

  

#### 5、对未来有哪些规划

+ 技术沉淀：五年八年
+ 全面发展：五年八年
+ 自由开发：十年以后



#### 6、自我介绍

①、姓名、学校、学院、专业

​	就读于吉林大学软件学院，专业是软件工程大三年级。

②、出身

​	老家在广西钦州的一个小县城，准确来说是小乡村。

③、成绩

​	在学校的成绩处于中上游水平，勉强摸到校级奖学金的水平，没达到夏令营的标准。

④、课程

​	学过很多课程，包括学院开设的还有自己感兴趣的，主要是计算机基础还有软件开发的课程。

⑤、业余爱好

​	平时喜欢运动，主要是健身，跑步，还有羽毛球，体测和体育课成绩都远超专业课的成绩。空闲的时候也会和家人或者对象聊天或者视频，但是不怎么玩游戏，有时候会看看小说。

⑥、方向

​	对于未来发展的方向，我稍微倾向于做Java的后台开发，在技术沉淀到一定水平以后我会选择更加全面的发展，在技术方面会倾向于全栈的开发，在非技术方面会发展一些其它的能力。因为我希望能够凭借自己的能力去做好自己喜欢的一些应用。

⑦、如何学习

​	首先对要学习的知识做一个定位，比如它的重要性，实践性，以及时间上是否充足。

+ 对于一些重要的知识，我会看书来学习，比如数据结构，算法分析。
+ 对于一些不那么重要或者时间上比较赶的知识，我会选择视频入门，然后根据一些技术博客或者官方文档，进行应用。
+ 对于实践性强的知识，我会搭建实验环境，跟着视频或者书籍，敲一敲命令或者代码。
+ 对于学习或者实践过程遇到的问题，我会在必应或者谷歌，或者gpt上搜索解决问题的办法。



#### 7、反问

①、实习生是怎么培养的

②、在秋招进入贵公司需要一个什么样的水平，比较看重哪方面的能力，哪一块知识点的理解

③、实习工作地点在哪里，实习时间是每周多少天



#### 8、项目篇

##### ①、介绍

​		**我的项目是基于springboot构建，主要实现了一个类似于博客或者论坛之类的系统，功能也比较简单，实现了用户的管理，帖子的管理，还有互动的管理，以及简单的数据监控，最后做了一些优化，还有部署。**



**用户的管理包括注册，登录，密码找回，以及头像更换和信息修改，以及简单的角色分类和权限控制。这里主要是有几个比较重要的实现，就是保持登录状态的逻辑，通过邮件认证的逻辑，验证码实现逻辑还有权限控制的逻辑；**

+ 在第一次登录之后，以及页面的跳转时，需要保持已经登录的状态，实现的逻辑很简单，用户登录之后，会生成一个登录凭证，里边存储了登录的用户，登录的时间，过期时间，以及一个随机字符串，这个随机字符串可以作为登录凭证的key值，在用户首次登录后，把这个登录凭证存到redis中，把这个随机字符串写到cookie中，绑定到请求上响应给浏览器。然后利用spring web模块，编写一个拦截器，在请求被分发到具体控制器之前做一个处理，从请求的cookie中把这个随机字符串拿出来，去redis中找登录凭证，检查没有问题后，直接构建用户对象，以及相应的认证。
+ 在注册和找回密码的时候需要通过这个邮件做认证，原理也很简单，就是随机生成一个随机字符作为key，将验证信息存入redis，然后把key通过邮件的形式发送给用户，用户点击邮件的链接访问，后端可以拿到这个key，去redis中查找相应的值进行验证。
+ 在登录的时候需要填写一个验证码，避免机器去恶意访问，实现逻辑也很简单，主要利用了kaptcha工具，生成验证码，把验证码存储到redis，接着生成验证码图片，响应给页面，同时把redis的key写到cooike中，在验证验证码的时候，后端从cookie中拿到那个key，从redis里把验证码拿出来对比。
+ 用户实现了简单的角色分类，但是没有在数据库层做角色的管理，只是用一个字段标注了用户的类型，在业务层做了角色的认证和管理，实现很简单，就是用spring security直接分配角色以及相应的访问权限的配置，还有权限不足的处理。这里没有用security自带的认证，而是自己写了一个拦截器，去数据库查询用户，根据用户类型生成用户认证结果，直接注入到security的安全上下文，security根据这个认证结果，在用户访问资源的时候就会去检查相应的权限，做出放行或者拒绝的处理。



**帖子的管理包括帖子的发布，分页展示，置顶加精和删除，还有帖子的热榜排行，以及帖子的全文搜索功能。这里有几个重要的实现，就是分页功能的实现逻辑，敏感词过滤的实现逻辑，以及热度计算原理，以及搜索的实现逻辑**

+ 分页功能是在业务层实现的，是自己实现的，没有用到mybatics-plus的集成。写了一个Page类，保存分页信息，包括当前页码，起始和终止页码，所有记录的数量，每页数据的数量，还有访问路径。视图层可以通过访问路径访问不同的页码，只需要在访问路径增加一个参数记录要访问第几页即可。数据访问层会根据要访问的页数还有记录的总数，每页的记录数编写具体的sql去查找置顶页码的数据，封装返回给视图层。
+ 置顶加精和删除主要是权限的管理，实现逻辑就是，只有相应身份的用户才能做置顶和删除，只有管理员才能做删除，这个也是通过springsecurity实现的，为了隔离不同用户的视图，在视图层通过thymeleaf和security框架做了权限的认证，根据权限来决定这个置顶和加精，删除的按钮是否被当前登录用户可见。
+ 热度计算的实现逻辑这样的，通过quartz模块设置一个定时任务，去检查是否有需要更新热度的帖子，按照热度计算公式计算好后，更新数据库更和ES即可。quartz的使用也很简单，配置一下任务调度器，然后写一个任务逻辑即可，在任务逻辑里，用redis的集合类型做了一个消息队列，每当发生导致热度变化的事件，比如评论，回复，点赞，加精等事件，就把相应的帖子ID放到队列里，定时任务会检查这个消息队列，将所有帖子都拿出来消费。、
+ 全文搜索是用elasticsearch做的，es内部实现了检索和存储的逻辑，我只是简单的把帖子存储到es，配置一下分词器即可，当需要存储数据，查询差距时，在业务层构建相应的请求，直接访问es服务器获取搜索结果，再对搜索结果进行解析处理响应即可。



**互动的管理包括评论，点赞和关注，会话和私信功能，以及系统通知的发送，这里有几个关键的实现，就是评论和回复的业务逻辑，点赞和关注的实现逻辑，会话的管理逻辑，以及通知的发送逻辑。**

+ 评论的实现很简单，没有用到什么技术，但是它的代码的编写比较繁琐，既要处理评论本身，还要管理评论的回复管理，说白了就是嵌套一层评论而已，在前后端的数据数据传递需要设计好清晰明了的对象结构。
+ 点赞和关注本身没有存储到mysql中，而是选择了redis存储，也没有什么复杂的过程，就是做了一个点赞和关注状态的检测，其余的操作就是redis的存取API调用。使用redis存储数据，难点主要是根据数据的性质和场景，选用合适的数据结构，然后设计一个合适的key值。
+ 会话管理和私信只是进行了简单的实现，设计了数据表来存储，在业务层也只是做了简单的增删改查和一些判断，在视图层做了一个分页。稍微复杂一点的就是做了未读消息数量的统计，以及阅读之后未读数量的更新。
+ 通知的实现是一个比较关键和重要的，当发生一些需要交互的事件时，系统需要发送一个通知提醒到相应的用户，比如你的帖子怎么怎么样了，被置顶了还是被加精或者删除了，有人关注了，有人评论或者点赞你的哪篇帖子或者评论了，都会发送一条通知。通知的格式不复杂，完全就是私信的消息格式，但是对通知做了一个生产者和消费者的模式去发送，主要的目的时为了降低请求的响应延迟，当然也不止通知的发送，其它一些耗时的过程也可以封装起来，延迟处理，把这些事件标记为不同的主题，存到Kafka服务器中，在服务器空闲时，去kafka取出这些事件，不同的主题有不同的处理方式，通知的发送就是把通知写入数据库，当用户刷新页面的时候会从数据库读取属于它的通知。



**数据监控只做了网站访问UV和活跃用户DAU的统计，实现很简单，就是写了一个拦截器去统计每一次的访问，将结果存储到redis，这里用了redis的一个用于统计的数据类型HiperLogLog，查询的时候再从redis里进行查询。统计，当然，数据监控也不是每个用户都可以去看的，这里也做了权限的管理。**



**项目部署在单点inux服务器上，使用docker进行了环境的安装，然后把项目打包到tomcat服务器，使用nginx作为反向代理**





##### ②、优化

**项目优化包括几个方面，包括日志和异常的优化，事务优化，缓存优化，session优化，图片存储优化，延迟处理优化**

+ 对项目的日志记录和异常处理做了解耦，单独实现，统一管理，通过AOP代理的方式，编写了通知，对切点进行了配置

+ 在业务层对一些业务进行了事务的配置，包括隔离级别，事务传播行为等，保证事务执行的一致性。

+ 缓存方便主要是做了两个方面的优化，第一是把一些热点数据在redis做一个备份，主要是用户对象；第二是对不常变化的数据做了一个本地缓存，直接从内存获取，这里用了coffine做本地缓存，主要存储帖子，因为帖子对象比较大，每次访问数据库效率太低，数据库压力也大。

+ session主要是解决了单点服务的session问题，将session优化为分布式session，存储到redis。

+ 对图片的存储一开始都是存储到本地的，考虑到以后可能会重构为分布式i项目，所以选择了阿里云对象存储作为图床。

+ 刚开始Kafka只是用来解决交互行为的系统通知的发送的，后边我把其它的几个过程也进行了延迟处理，主要是同步es和数据库的数据，图片上传到图床，以及邮件的发送过程

  

  ```
  private void help(){
  	new Main().solve();
  	for(int i = 0; i < 9; i++){
  	Map<Integer, Integer> map = new HashMap<>();
  	ArrayDeque<Integer> q = new ArrayDeque<>();
  	BufferedReader reader = new BufferedReader(new BufferedInputStream(System.in));
  	StringTokenizer token = new StringTokenizer(reader.readLine());
  	while(token.hasMoreTokens()){
  		String k = token.nextToken();
  		char[] ch = k.toCharArrays();
  		int[] st = new int[len +1];
  		int top = -1;
  		while(top > -1){
  			int l = 0;
  			int r = nums.length -1;
  			while(l < r){
  			int m = l + (r -l +1)/2;
  			if(nums[m] > tar){
  				r = m -1;
  			}else{
  				l = m;
  			}
  			}
  		}
  		}
  }
  public class Node{
  	public int v;
  	public Node l;
  	public Node r;
  }
  
  ```

  



##### ③、难点

**项目难点有几个地方，redis数据类型的选择和key的设计，版本的冲突，还有部署的过程，视图层的处理**

+ redis的使用，因为实践经验不够，redis的使用还不太熟练，对于数据类型的选择和key的设计比较的乱，最后抽象了一个redis工具类来专门生成key。
+ 在导入es模块的时候，jdk8和springboot版本以及es版本不兼容，试了很多版本都匹配不上这三者的关系，也从官方文档查看了他们之间的版本对应关系，但是把具体版本放进去的时候还是出现不匹配，最后试了很多个，才解决这个问题。
+ 在第一次部署的时候，选择了阿里云服务器，当时还没有学docker，用的常规方法在linux装各种服务，遇到很多的报错和问题，查看了很多的文章才解决，有些不知道怎么解决的，就卸载了再重新装，在这其间也学会了在linux通过查看日志查找错误的方法。
+ 视图层代码的编写还是很头疼的，UI的处理和视图的解析，js的编写，ajax异步方式的提交，都吃了不少的苦，主要还是浏览器debug的能力不太行，还有前端代码不熟练。



##### ④、还能如何优化

**项目当前还是比较简单和脆弱，低性能，不安全的，如果考虑继续优化，可以几个方面入手**

+ 首先是项目的**架构优化**，可以优化为完全前后端分离的模式，用VUE或者其它的前端框架把视图层和静态资源分离出去，可以有效提高页面浏览的流畅度和完全restful风格的前后端交互。
+ 其次是后端模块的**分布式优化**，可以把项目重构为分布式应用，部署到多个服务器上，做好统一的网关和负载均衡，以及一些熔断和限流的措施，同时对依赖的服务也做一个主从结构的配置或者直接做集群的配置提高服务的可用性，比如mysql，redis，kafka，es。
+ 然后在**性能方面**也可以做优化，比如mysql表的重新设计，索引的设计；还有redis数据结构的重新选择，过期时间的设计等等。
+ 接着在**安全方面**也可以做优化，从数据库层面可以改用oracle做更加严格和细致的权限管理，在网络层面可以配置使用https做为传输协议。
+ 最后是**内容的优化**，比如更加丰富的管理功能，用户和管理员界面隔离的优化；帖子发布可以新增图片，表情，表格等多元化的输入；数据监控模块可以做更多的功能，比如一些后台服务健康状态的监控、调优。