# 复习方式：画类图+奔腾刷题



## 一、创建型模式

### 1、简单工厂模式

适用于生产同一类产品，根据名称或者类别，生产具体产品

##### ①、抽象产品

```java
//一类产品
public interface Product {
    void show();
}
```

##### ②、具体产品

```java
//本类别的A产品
public class ProductA implements Product{
    @Override
    public void show() {
        System.out.println("this is productA");
    }
}
```

```java
//本类别的B产品
public class ProductB implements Product{
    @Override
    public void show() {
        System.out.println("this is productB");
    }
}
```

```java
//本类别的C产品
public class ProductC implements Product{
    @Override
    public void show() {
        System.out.println("this is productC");
    }
}
```

##### ③、工厂

```java
//本类别产品的简单工厂，根据输入的不同进行不同的生产
public class Factory {
    public Product getProductByName(String name){
        if(name.equals("A")){
            return  new ProductA();
        }else if(name.equals("B")){
            return  new ProductB();
        }else if(name.equals("C")){
            return new ProductC();
        }
        return null;
    }
}
```

##### ④、测试类

```java
public class SimpleFactoryTest {
    public static void main(String[] args) {
        Factory factory = new Factory();
        factory.getProductByName("A").show();
        factory.getProductByName("B").show();
        factory.getProductByName("C").show();
    }
}
```

### 2、抽象工厂模式

适用于生产同一族的不同类产品；

每一个具体工厂是某一个产品族的代工厂，可以生产很多类的本族产品；

每一个抽象产品都代表一类产品，包含不同族的本类别产品；

##### ①、抽象工厂

```java
 //本族产品，由具体的族进行扩展，生产自己族的多类产品
public interface Factory {
    ProductA getProductA();
    ProductB getProductB();
}
```

##### ②、具体工厂

```java
//1族工厂
public class Factory1 implements Factory{
    @Override
    public ProductA getProductA(){
        return new ProductA1();
    }
    @Override
    public ProductB getProductB(){
        return new ProductB1();
    }
}
```

```java
//2族工厂
public class Factory2 implements Factory{
    @Override
    public ProductA getProductA(){
        return new ProductA2();
    }
    @Override
    public ProductB getProductB(){
        return new ProductB2();
    }
}
```

##### ③、抽象产品A

```java
//A类产品，由子类扩展不同族
public interface ProductA {
    void show();
}
```

##### ④、抽象产品B

```java
//B类产品，由子类扩展不同族
public interface ProductB {
    void show();
}
```

##### ⑤、具体产品A

```java
//1族的A产品
public class ProductA1 implements ProductA{
    @Override
    public void show() {
        System.out.println("this is productA1!");
    }
}
```

```java
//2族的A产品
public class ProductA2 implements ProductA{
    @Override
    public void show() {
        System.out.println("this is productA2!");
    }
}
```

##### ⑥、具体产品B

```java
//1族的B产品
public class ProductB1 implements ProductB{
    @Override
    public void show() {
        System.out.println("this is productB1!");
    }
}
```

```java
//2族的B产品
public class ProductB2 implements ProductB{
    @Override
    public void show() {
        System.out.println("this is productB2!");
    }
}

```

##### ⑦、测试类

```java
public class AbstractFactoryTest {
    public static void main(String[] args) {
        //1族创建工厂，生产本族产品
        Factory factory1 = new Factory1();
        factory1.getProductA().show();
        factory1.getProductB().show();

        //2族创建工厂，生产本组产品
        Factory factory2 = new Factory2();
        factory2.getProductA().show();
        factory2.getProductB().show();
    }
}
```

### 3、工厂方法模式

产品和工厂都抽象出抽象类，若扩展新的产品，需要扩展新的工厂去生产这类产品，职责单一；

##### ①、抽象工厂

```java
public interface Factory {
    //具体子类进行扩展，创建具体产品，一个子类创建一种产品
    Product getProduct();
}
```

##### ②、抽象产品

```java
public interface Product {
    void show();
}
```

##### ③、具体工厂

```java
public class FactoryA implements Factory{
    @Override
    public Product getProduct() {
        return new ProductA();
    }
}
```

```java
public class FactoryB implements Factory{
    @Override
    public Product getProduct() {
        return new ProductB();
    }
}
```

##### ④、具体产品

```java
public class ProductA implements Product{
    @Override
    public void show(){
        System.out.println("this is productA");
    }
}
```

```java
public class ProductB implements Product{
    @Override
    public void show(){
        System.out.println("this is productB!");
    }
}
```

##### ⑤、测试类

```java
public class FactoryMethodTest {
    public static void main(String[] args) {
        //先创建工厂
        Factory factoryA = new FactoryA();
        Factory factoryB = new FactoryB();
        //用工厂创建产品
        factoryA.getProduct().show();
        factoryB.getProduct().show();
    }
}
```

### 4、单例模式

私有构造函数、静态成员变量存储单例、提供对外的接口访问；

根据单例的创建时机，有多种实现方式

##### ①、饿汉式

```java
public class HungerSingleton {
    private HungerSingleton(){}
    //提前实例化单例，资源浪费
    private static final HungerSingleton singleton = new HungerSingleton();

    public static HungerSingleton getInstance(){
        return singleton;
    }
}
```

##### ②、加锁单检查延迟

```java
public class LockAndSingleCheckLazySingleton {
    private LockAndSingleCheckLazySingleton(){}
    private static LockAndSingleCheckLazySingleton singleton;

    public static LockAndSingleCheckLazySingleton getInstance(){
        //第一次使用单例时实例化，因为加锁会等待，单检查可能出现多个线程检查完后进行等待，之后再次进行加锁实例化的现象
        if(singleton == null){
            synchronized(LockAndSingleCheckLazySingleton.class) {
                singleton = new LockAndSingleCheckLazySingleton();
            }
        }
        return singleton;
    }
}
```

##### ③、加锁双检查延迟

```java
public class LockAndDoubleCheckLazySingleton {
    private LockAndDoubleCheckLazySingleton(){}
    private static volatile LockAndDoubleCheckLazySingleton singleton;

    public static LockAndDoubleCheckLazySingleton getInstance(){
        //检查
        if(singleton == null){
            synchronized(LockAndDoubleCheckLazySingleton.class) {
                //双重检查，同一时间只有一个线程能加锁，即便多个线程进行了先后加锁，也不会多次实例化
                if(singleton == null) {
                    singleton = new LockAndDoubleCheckLazySingleton();
                }
            }
        }
        return singleton;
    }
}
```

##### ④、静态内部类延迟

```java
public class HolderLazySingleton {
    private HolderLazySingleton(){}
    //在内部类进行实例化，调用内部类的时候内部类才会进行初始化
    private static class Holder{
        public static final HolderLazySingleton single = new HolderLazySingleton();
    }
    public static HolderLazySingleton getInstance(){
        return Holder.single;
    }
}
```

##### ⑤、枚举延迟

```java
public enum EnumLazySingleton {
    getInstance();
}
```

##### ⑥、测试类

```java
public class SingletonTest {
    public void testHunger(){
        HungerSingleton singleton = HungerSingleton.getInstance();
        HungerSingleton singleton1 = HungerSingleton.getInstance();
        System.out.println(singleton == singleton1);
    }
    public void testLockAndSingleCheckLazy(){
        LockAndSingleCheckLazySingleton singleton = LockAndSingleCheckLazySingleton.getInstance();
        LockAndSingleCheckLazySingleton singleton1 = LockAndSingleCheckLazySingleton.getInstance();
        System.out.println(singleton == singleton1);
    }
    public void testLockAndDoubleCheckLazy(){
        LockAndDoubleCheckLazySingleton singleton = LockAndDoubleCheckLazySingleton.getInstance();
        LockAndDoubleCheckLazySingleton singleton1 = LockAndDoubleCheckLazySingleton.getInstance();
        System.out.println(singleton == singleton1);
    }
    public void testHolderLazy(){
        HolderLazySingleton singleton = HolderLazySingleton.getInstance();
        HolderLazySingleton singleton1 = HolderLazySingleton.getInstance();
        System.out.println(singleton == singleton1);
    }
    public void testEnumLazy(){
        EnumLazySingleton singleton = EnumLazySingleton.getInstance;
        EnumLazySingleton singleton1 = EnumLazySingleton.getInstance;
        System.out.println(singleton == singleton1);
    }
    public static void main(String[] args) {
        SingletonTest test = new SingletonTest();
        //测试各种单例方法
        test.testHunger();
        test.testLockAndDoubleCheckLazy();
        test.testLockAndSingleCheckLazy();
        test.testHolderLazy();
        test.testEnumLazy();
    }
}
```

### 4、原型模式

浅拷贝可以通过重载拷贝构造函数实现；或者在抽象原型使用Java类Object自带的clone()实现；

深拷贝在抽象原型使用序列化；

##### ①、抽象原型

```java
public class AbstractPrototype implements Serializable{
    protected int id;
    protected AbstractPrototype friend;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public AbstractPrototype getFriend() {
        return friend;
    }

    public void setFriend(AbstractPrototype friend) {
        this.friend = friend;
    }

    public void show(){}

    //浅拷贝，由子类进行重写调用自己的拷贝构造函数
    public AbstractPrototype shallowClone(){return null;}

    //深拷贝，子类不进行重写
    public AbstractPrototype deepClone(){
        try {
            //序列化
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            //将当前对象写入流
            oos.writeObject(this);

            //反序列化
            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);
            //从流里把对象读出
            AbstractPrototype clone = (AbstractPrototype) ois.readObject();

            bos.close();
            oos.close();
            bis.close();
            bos.close();
            return clone;
        } catch (Exception e) {
            System.out.println("深拷贝出错！" + e.getMessage());
        }
        return null;
    }
}
```

##### ②、具体原型

```java
public class ConcretePrototypeA extends AbstractPrototype{
    public ConcretePrototypeA(){}
    //拷贝构造函数
    public ConcretePrototypeA(AbstractPrototype prototype){
        setId(prototype.getId());
        setFriend(prototype.getFriend());
    }
    //重写浅拷贝方法
    @Override
    public AbstractPrototype shallowClone(){
        return new ConcretePrototypeA(this);
    }

    @Override
    public void show(){
        System.out.println("this id ConcretePrototypeA ! " +"id: " + id + " friend:" + friend.getId());
    }
}
```

```java
public class ConcretePrototypeB extends AbstractPrototype{
    public ConcretePrototypeB(){}
    //拷贝构造函数
    public ConcretePrototypeB(AbstractPrototype prototype){
        setId(prototype.getId());
        setFriend(prototype.getFriend());
    }
    //重写浅拷贝方法
    @Override
    public AbstractPrototype shallowClone(){
        return new ConcretePrototypeB(this);
    }
    @Override
    public void show() {
        System.out.println("this id ConcretePrototypeB ! " +"id: " + id +" friend:" + friend.getId());
    }
}
```

##### ③、原型样本注册表

```java
public class ObjectMannager {
    private List<AbstractPrototype> myObject = new ArrayList<>();
    //提前注册样本原型
    public ObjectMannager(){
        AbstractPrototype a = new ConcretePrototypeA();
        AbstractPrototype b = new ConcretePrototypeB();
        a.setId(0);
        a.setFriend(b);
        b.setId(1);
        b.setFriend(a);

        myObject.add(a);
        myObject.add(b);
    }
    //获取浅拷贝
    public AbstractPrototype getShowCloneObjectById(int id){
        return myObject.get(id).shallowClone();
    }
    //获取深拷贝
    public AbstractPrototype getDeepCloneObjectById(int id){
        return myObject.get(id).deepClone();
    }
    //获取样本原型
    public AbstractPrototype getPrototypeById(int id){
        return myObject.get(id);
    }
}
```

##### ④、测试类

```java
public class PrototypeTest {
    public static void main(String[] args) {
        //创建原型样本
        ObjectMannager mannager = new ObjectMannager();
        //获取样本原型的克隆对象
        AbstractPrototype a = mannager.getShowCloneObjectById(0);
        AbstractPrototype a1 = mannager.getDeepCloneObjectById(0);
        AbstractPrototype b = mannager.getShowCloneObjectById(1);
        AbstractPrototype b1 = mannager.getDeepCloneObjectById(1);
        //输出克隆对象，比较成员函数friend确定是不是深拷贝
        boolean f =  a.getFriend()==mannager.getPrototypeById(a.getFriend().getId());
        System.out.println("浅拷贝ConcretePrototypeA: " + "friend是否相同：" +f);
        a.show();

        f =  a1.getFriend()==mannager.getPrototypeById(a1.getFriend().getId());
        System.out.println("深拷贝ConcretePrototypeA: " + "friend是否相同：" +f);
        a1.show();

        f =  b.getFriend()==mannager.getPrototypeById(b.getFriend().getId());
        System.out.println("浅拷贝ConcretePrototypeB: " + "friend是否相同：" +f);
        b.show();

        f =  b1.getFriend()==mannager.getPrototypeById(b1.getFriend().getId());
        System.out.println("深拷贝ConcretePrototypeB: " + "friend是否相同：" +f);
        b1.show();
    }
}
```

### 6、建造者模式

实现建造过程、建造方案、建造原料的相互解耦

指挥者专注于建造方案，将构建方案写成接口，方便具体指挥者扩展建造方案，使用自己的建造者去构建；

建造者专注于产品部分的创建，将部分产品的构建过程写成接口，方便具体建造者扩展建造细节；

原料、可选择的构建者由客户端提供给指挥者；

产品只存储数据；

简化版可以省略指挥者、省略抽象建造者；只保留一个具体建造者去负责构建产品

##### ①、产品

```java
public class Product {
    private int A, B, C, D;

    public int getA() {
        return A;
    }

    public void setA(int a) {
        A = a;
    }

    public int getB() {
        return B;
    }

    public void setB(int b) {
        B = b;
    }

    public int getC() {
        return C;
    }

    public void setC(int c) {
        C = c;
    }

    public int getD() {
        return D;
    }

    public void setD(int d) {
        D = d;
    }
    @Override
    public String toString() {
        return "Product{" +
                "A=" + A +
                ", B=" + B +
                ", C=" + C +
                ", D=" + D +
                '}';
    }
}
```

##### ②、抽象建造者

```java
public abstract class AbstractBuilder {
    //建造者类型，方便指挥者进行判断使用哪个建造者
    protected int type;
    //建造的产品
    protected Product product = new Product();

    public int getType() {
        return type;
    }

    public Product build(){
        return product;
    }

    public AbstractBuilder setProduct(Product product){
        this.product = product;
        return this;
    }
	//具体的建造细节，由子类扩展
    public AbstractBuilder buildA(int material){return this;}
    public AbstractBuilder buildB(int material){return this;}
    public AbstractBuilder buildC(int material){return this;}
    public AbstractBuilder buildD(int material){return this;}
}
```

##### ③、抽象指挥者

```java
public class AbstractDirector {
    //建造者集合
    protected List<AbstractBuilder> builders;
    //原料集合
    protected Map<String, Integer> materials;
    //建造的产品
    protected Product product;
	//添加建造者
    public AbstractDirector addBuilder(AbstractBuilder builder) {
        builder.setProduct(product);
        this.builders.add(builder);
        return this;
    }
    //添加原料
    public AbstractDirector addMaterial(String key, int value){
        materials.put(key, value);
        return this;
    }
    //具体建造方案，由子类扩展
    public Product createProduct(){return null;}
}
```

##### ④、具体建造者

```java
public class ConcreteBuilder1 extends AbstractBuilder{
    public ConcreteBuilder1(){
        this.type = 1;
    }
    @Override
    public AbstractBuilder buildA(int material) {
        product.setA(material +2);
        return super.buildA(material);
    }

    @Override
    public AbstractBuilder buildB(int material) {
        product.setB(material +2);
        return super.buildB(material);
    }

    @Override
    public AbstractBuilder buildC(int material) {
        product.setC(material +2);
        return super.buildC(material);
    }

    @Override
    public AbstractBuilder buildD(int material) {
        product.setD(material +2);
        return super.buildD(material);
    }
}
```

```java
public class ConcreteBuilder2 extends AbstractBuilder{
    public ConcreteBuilder2(){
        this.type = 2;
    }
    @Override
    public AbstractBuilder buildA(int material) {
        product.setA(material *2);
        return super.buildA(material);
    }

    @Override
    public AbstractBuilder buildB(int material) {
        product.setB(material *2);
        return super.buildB(material);
    }
    @Override
    public AbstractBuilder buildC(int material) {
        product.setC(material *2);
        return super.buildC(material);
    }

    @Override
    public AbstractBuilder buildD(int material) {
        product.setD(material *2);
        return super.buildD(material);
    }
}
```

##### ⑤、具体指挥者

```java
public class ConcreteDirector1 extends AbstractDirector{
    public ConcreteDirector1(){
        this.builders = new ArrayList<>();
        this.materials = new HashMap<>();
        this.product = new Product();
    }
    @Override
    public Product createProduct(){
        for(AbstractBuilder builder : builders){
            if(builder.getType() == 1){
                builder.buildA(materials.get("A"))
                        .buildB(materials.get("B"));
            }else if(builder.getType() == 2){
                builder.buildC(materials.get("C"))
                        .buildD(materials.get("D"));
            }
        }
        return product;
    }
}
```

```java
public class ConcreteDirector2 extends AbstractDirector{
    public ConcreteDirector2(){
        this.builders = new ArrayList<>();
        this.materials = new HashMap<>();
        this.product = new Product();
    }
    @Override
    public Product createProduct(){
        for(AbstractBuilder builder : builders){
            if(builder.getType() == 2){
                builder.buildA(materials.get("A"))
                        .buildB(materials.get("B"));
            }else if(builder.getType() == 1){
                builder.buildC(materials.get("C"))
                        .buildD(materials.get("D"));
            }
        }
        return product;
    }
}
```

##### ⑥、测试类

```java
public class BuilderTest {
    public static void main(String[] args) {
        //提供建造者
        AbstractBuilder builder1 = new ConcreteBuilder1();
        AbstractBuilder builder2 = new ConcreteBuilder2();

        //创建指挥者2,并设置原料和构建者
        AbstractDirector director1 = new ConcreteDirector1()
                .addBuilder(builder1)
                .addBuilder(builder2)
                .addMaterial("A",1)
                .addMaterial("B",10)
                .addMaterial("C",100)
                .addMaterial("D",1000);
        //指挥者1按照自己的逻辑指挥构建者构建产品
        Product product1 = director1.createProduct();
        System.out.println("director1指挥构建的产品：" +product1.toString());

        //创建指挥者2,并设置原料和构建者
        AbstractDirector director2 = new ConcreteDirector2()
                .addBuilder(builder1)
                .addBuilder(builder2)
                .addMaterial("A",1)
                .addMaterial("B",10)
                .addMaterial("C",100)
                .addMaterial("D",1000);
        //指挥者2按照自己的逻辑指挥构建者构建产品
        Product product2 = director2.createProduct();
        System.out.println("director2指挥构建的产品：" +product2.toString());
    }
}
```

## 二、结构型模式

### 1、桥接模式

抽象与实现分离；

两个维度分别变化；

核心在于抽象一方关联实现方的引用；

实现方的接口必须定义完功能，不能通过继承来扩展功能，只能通过继承重写来提供不同的功能实现；

抽象方既可以通过继承扩展功能，也可以通过继承来提供不同的实现；

可以极大减少类的数量；

##### ①、抽象

```java
//变化维度1
public class AstractA {
    //变化维度2
    protected ImpA impA;

    public void setImpA(ImpA impA) {
        this.impA = impA;
    }
}
```

##### ②、实现

```java
//变化维度2
public class ImpA {
    public void f(){};
}
```

##### ③、抽象扩展

```java
//功能扩展1
public class ConcreteA1 extends AstractA{
    public void x(){
        System.out.println("this is change 1!");
        impA.f();
    }
}
```

```java
//功能扩展2
public class ConcreteA2 extends AstractA{
    public void y(){
        System.out.println("this is change 2!");
        impA.f();
    }
}
```

```java
//功能扩展3
public class ConcreteA3 extends AstractA{
    public void z(){
        System.out.println("this is change 3!");
        impA.f();
    }
}
```



##### ④、实现扩展

```java
//实现1
public class ImpA1 extends ImpA{
    @Override
    public void f() {
        System.out.println("this is imp1!");
    }
}
```

```java
//实现2
public class ImpA2 extends ImpA{
    @Override
    public void f() {
        System.out.println("this is imp2！");
    }
}
```

```java
//实现3
public class ImpA3 extends ImpA{
    @Override
    public void f() {
        System.out.println("this is imp3");
    }
}
```

##### ⑤、测试

```java
public class BridgeTest {
    public static void main(String[] args) {
        //抽象的三个扩展
        ConcreteA1 concreteA1 = new ConcreteA1();
        ConcreteA2 concreteA2 = new ConcreteA2();
        ConcreteA3 concreteA3 = new ConcreteA3();
        //实现的三个扩展
        ImpA impA1 = new ImpA1();
        ImpA impA2 = new ImpA2();
        ImpA impA3 = new ImpA3();

        //实现九种不同的搭配
        concreteA1.setImpA(impA1);
        concreteA1.x();
        concreteA1.setImpA(impA2);
        concreteA1.x();
        concreteA1.setImpA(impA3);
        concreteA1.x();

        concreteA2.setImpA(impA1);
        concreteA2.y();
        concreteA2.setImpA(impA2);
        concreteA2.y();
        concreteA2.setImpA(impA3);
        concreteA2.y();

        concreteA3.setImpA(impA1);
        concreteA3.z();
        concreteA3.setImpA(impA2);
        concreteA3.z();
        concreteA3.setImpA(impA3);
        concreteA3.z();

    }
}
```

### 2、适配器模式

非要使用接口A类型的对象，但是业务必须由B来完成；

A就是target，B就是Adaptee；

为实现这个需求，需要写一个Adapter继承target，这样Adapter就是target类型了，同时Adapter关联Adaptee的引用，使用AAdaptee的方法来完成业务。

##### ①、target抽象

```java
public class Target {
    public void show(){};
}
```

##### ②、Adaptee抽象

```java
public class Adaptee {
    public void work(){}
}
```

##### ③、Adaptee具体

```java
public class AdapteeImp extends Adaptee{
    @Override
    public void work() {
        System.out.println("this is adaptee!");
    }
}
```

##### ④、Adapter

```java
public class Adapter extends Target{
    private Adaptee adaptee;

    public Target setAdaptee(Adaptee adaptee) {
        this.adaptee = adaptee;
        return this;
    }

    @Override
    public void show() {
        System.out.println("this is Target");
        adaptee.work();
    }
}
```

##### ⑤、测试类

```java
public class AdatperTest {
    public static void main(String[] args) {
        //非要使用target,但是想做的却是Adaptee的事情
        Target target = (new Adapter()).setAdaptee(new AdapteeImp());
        target.show();
    }
}
```

### 3、组合模式

本质上就是抽象接口关联自身对象；

按照职责的定义时机，分为安全模式，透明模式；



安全模式在抽象接口只提供抽象方法，关联自身以及相关方法交给扩展子类去完成，扩展子类职责单一；

优点：职责单一，调用安全；

缺点：灵活性差，组装成形后难修改；



透明模式在抽象接口就关联好自身对象并提供所有方法，扩展子类选择实现，扩展子类会冗余抽象类的成员和方法；

优点：灵活性好，随时进行结构调整

缺点：职责冗余，依赖抽象类默认实现，存在安全问题；



透明模式也可以选择不派生子类，自己实现所有业务，不存在冗余，但是复杂度提高；

优点：不存在安全问题，结构调整灵活；

缺点：复杂度高，扩展冗余；

#### 安全模式

##### ①、抽象接口

```java
public interface SafeNode {
    int getValue();
}
```

##### ②、关联自身的扩展子类

```java
public class SafeBranch implements SafeNode {
    private List<SafeNode> nodes = new ArrayList<>();
    public SafeBranch addNode(SafeNode node){
        nodes.add(node);
        return this;
    }
    @Override
    public int getValue() {
        int res = 0;
        for (SafeNode node : nodes) {
            res += node.getValue();
        }
        return res;
    }
}
```

##### ③、不关联自身的扩展子类

```java
public class SafeLeaf implements SafeNode {
    private int value;
    public SafeLeaf setValue(int value){
        this.value = value;
        return this;
    }
    @Override
    public int getValue() {
        return value;
    }
}
```

#### 透明模式

##### ①、抽象类

```java
public abstract class ParentNode {
    protected List<ParentNode> nodes = new ArrayList<>();
    protected int value = 0;
    public ParentNode addNode(ParentNode node){
        return this;
    }
    public ParentNode setValue(int value){
        return this;
    }

    public abstract int getValue();
}
```

##### ②、扩展子类

```java
public class ParentBranch extends ParentNode {
    @Override
    public ParentNode addNode(ParentNode node) {
        this.nodes.add(node);
        return this;
    }

    @Override
    public int getValue() {
        int res = 0;
        for (ParentNode node : nodes) {
            res += node.getValue();
        }
        return res;
    }
}
```

##### ③、扩展子类

```java
public class ParentLeaf extends ParentNode {
    @Override
    public ParentNode setValue(int value) {
        this.value = value;
        return this;
    }

    @Override
    public int getValue() {
        return this.value;
    }
}
```

#### 透明模式简化版

```java
public class NodePlus {
    private List<NodePlus> nodes = new ArrayList<>();
    private int value = 0;
    public NodePlus setValue(int value){
        this.value = value;
        return this;
    }
    public NodePlus addNode(NodePlus node){
        nodes.add(node);
        return this;
    }
    public int getValue(){
        int res = this.value;
        if(nodes != null && !nodes.isEmpty()) {
            for (NodePlus node : nodes) {
                res += node.getValue();
            }
        }
        return res;
    }
}
```

#### 测试类

```java
public class NodeTest {
    //安全模式
    //安全模式只能先组装好，再赋值给统一接口类型！
    public static void safeTest(){
        //生成树叶
        SafeNode leaf = new SafeLeaf().setValue(2);
        SafeNode leaf1 = new SafeLeaf().setValue(2);
        SafeNode leaf2 = new SafeLeaf().setValue(2);

        //组装树枝
        SafeNode branch = new SafeBranch().addNode(leaf).addNode(leaf1);
        SafeNode branch1 = new SafeBranch().addNode(leaf2);

        //组装树
        SafeNode root = new SafeBranch().addNode(branch).addNode(branch1);

        System.out.println(root.getValue());
    }
    //透明模式
    //透明模式可以先赋予统一类型，再进行组装；也可以先组装，再赋予统一类型！
    public static void transparentTest(){
        //组装叶子
        ParentNode leaf = new ParentLeaf();
        leaf.setValue(10);
        ParentNode leaf1 = new ParentLeaf();
        leaf1.setValue(10);
        ParentNode leaf2 = new ParentLeaf();
        leaf2.setValue(10);
        //组装数制
        ParentNode branch = new ParentBranch();
        branch.addNode(leaf).addNode(leaf1);
        ParentNode branch2 = new ParentBranch();
        branch.addNode(leaf2);
        //组装树
        ParentNode root = new ParentBranch();
        root.addNode(branch).addNode(branch2);

        System.out.println(root.getValue());

    }
    //透明模式简化版
    //组装方式同透明模式
    public static void nodePlusTest(){
        //组装叶子
        NodePlus leaf = new NodePlus().setValue(100);
        NodePlus leaf1 = new NodePlus().setValue(100);
        NodePlus leaf2 = new NodePlus().setValue(100);
        //组装树枝
        NodePlus branch = new NodePlus().addNode(leaf).addNode(leaf1);
        NodePlus branch1 = new NodePlus().addNode(leaf2);
        //组装树
        NodePlus root = new NodePlus().addNode(branch).addNode(branch1);

        System.out.println(root.getValue());
    }
    public static void main(String[] args) {
        safeTest();
        nodePlusTest();
        transparentTest();
    }
}
```

### 4、门面模式

使用门面来管理子系统；

门面可以使用简单的类，关联子系统类，调用其方法完成某个复杂业务·；

门面也可以抽象出抽象类，对同一个业务使用不同的子系统，对业务的扩展和变化提供了抽象；

##### ①、子系统类

```java
public class Model1 {
    public void on(){
        System.out.println("model1 is on!");
    }
    public void off(){
        System.out.println("model1 is off!");
    }
}
```

```java
public class Model2 {
    public void add(){
        System.out.println("model2 is add!");
    }
    public void remove(){
        System.out.println("model1 is remove!");
    }
}
```

```java
public class Model3 {
    public void heater(){
        System.out.println("model3 is heater!");
    }
    public void coder(){
        System.out.println("model1 is colder!");
    }
}
```



##### ②、抽象门面

```java
public abstract class AstractFacade {
    public abstract void turnOn();
    public abstract void turnOff();
}
```

##### ③、具体门面

```java
public class ConcreteFacade1 extends AstractFacade{
    private Model1 model1 = new Model1();
    private Model2 model2 = new Model2();

    @Override
    public void turnOn() {
        model1.on();
        model2.add();
    }

    @Override
    public void turnOff() {
        model1.off();
        model2.remove();
    }
}
```

```java
public class ConcreteFacade2 extends AstractFacade{
    private Model1 model1 = new Model1();;
    private Model2 model2 = new Model2();
    private Model3 model3 = new Model3();

    @Override
    public void turnOn() {
        model1.on();
        model2.add();
        model3.heater();
    }

    @Override
    public void turnOff() {
        model1.off();
        model2.remove();
        model3.coder();
    }
}
```



##### ④、测试类

```java
public class FacadeTest {
    private static AstractFacade facade = new ConcreteFacade1();
    private static AstractFacade facade1 = new ConcreteFacade2();
    public static void main(String[] args) {
        facade.turnOn();
        facade.turnOff();

        facade1.turnOn();
        facade1.turnOff();
    }
}
```

### 5、装饰模式

在不改变原有类的情况下，对一个类的功能进行增强；

根据增强的功能不同分别扩展不同的装饰类；

可以对同一类型的所有子类进行同样的增强；

增强和原有功能两个维度分别变化

优点：不改变原有代码，实现功能扩展，避免对原有类进行继承扩展，对同一类型的同一个增强只需编写一个装饰类；

##### ①、原有组件接口

```java
public interface Component {
    void show();
}
```

##### ②、原有组件实现类

```java
public class ComponentImp1 implements Component{

    @Override
    public void show() {
        System.out.println("this is component1!");
    }
}
```

```java
public class ComponentImp2 implements Component{

    @Override
    public void show() {
        System.out.println("this is component2!");
    }
}
```



##### ③、抽象装饰

```java
public class Decorator implements Component{
    protected Component component;
    public Decorator(Component component){
        this.component = component;
    }
    @Override
    public void show() {
        component.show();
    }
}
```

##### ④、具体装饰

```java
public class ConcreteDecorator1 extends Decorator{
    public ConcreteDecorator1(Component component) {
        super(component);
    }

    @Override
    public void show() {
        showBefore(component);
        component.show();
    }
    public void showBefore(Component component){
        System.out.println("this is show before!");
    }
}
```

```java
public class ConcreteDecorator2 extends Decorator{
    public ConcreteDecorator2(Component component) {
        super(component);
    }

    @Override
    public void show() {
        component.show();
        showAfter(component);
    }
    public void showAfter(Component component){
        System.out.println("this is show after!");
    }
}
```

##### ⑤、测试类

```java
public class DecoratorTest {
    public static void main(String[] args) {
        //原始方式
        Component component = new ComponentImp1();
        component.show();
        //装饰方式1
        component = new ConcreteDecorator1(component);
        component.show();
        //装饰方式2
        component = new ConcreteDecorator2(component);
        component.show();


        //对同种类型的其它子类进行增强
        component = new ComponentImp2();
        component.show();
        //装饰方式1
        component = new ConcreteDecorator1(component);
        component.show();
        //装饰方式2
        component = new ConcreteDecorator2(component);
        component.show();
    }
}
```

### 6、代理模式

对一个类的某些方法进行增强;

静态代理结构和装饰模式类似，只是适用业务不同，代理模式一般不需要派生子类进行多样的代理，因此不需要设置抽象代理类，而装饰者模式需要设置抽象装饰者，子类扩展不同的增强；静态代理只能代理一个类型的接口，而且接口方法发生变化时需要重构代码；可以进行多重代理；

Jdk动态代理可以代理任意接口类型，对于同一增强不需要编写其它类；可以进行多重代理

Cglib动态代理可以代理任意可继承的类，不能进行多重代理；

##### ①、抽象主题

```java
public interface Subject {
    void show();
}
```

##### ②、具体主题

```java
public class RealSubject implements Subject{
    @Override
    public void show() {
        System.out.println("this is realsubject!");
    }
}
```

##### ③、静态代理类

```java
public class StaticProxy implements Subject{
    private Subject subject;
    public StaticProxy(){
        subject = new StaticProxy();
    }
    public StaticProxy(Subject subject){
        this.subject = subject;
    }
    @Override
    public void show() {
        before();
        subject.show();
        after();
    }

    public void before(){
        System.out.println("proxy before!");
    }
    public void after(){
        System.out.println("proxy after!");
    }
}
```

##### ④、Jdk动态代理逻辑

```java
public class JdkProxyLogic implements InvocationHandler {
    private Object object;
    public JdkProxyLogic(Object object){
        this.object = object;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object invoke = method.invoke(object, args);
        after();
        return invoke;
    }
    public void before(){
        System.out.println("this is jdk before!");
    }
    public void after(){
        System.out.println("this is jdk after!");
    }
}
```

##### ⑤、Cglib动态代理逻辑

```java
public class CglibProxyLogic implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object invoke = methodProxy.invokeSuper(o,objects);
        after();
        return invoke;
    }
    public void before(){
        System.out.println("this is cglib before!");
    }
    public void after(){
        System.out.println("this is cglib after!");
    }
}
```

##### ⑥、测试类

```java
public class ProxyTest {
    public static void main(String[] args) {
        //真实对象
        RealSubject realSubject = new RealSubject();


        //静态代理
        //结果类型是原接口类型
        //若需要代理其它接口，需要编写新的代理类
        //可以进行多重代理
        System.out.println("静态一次代理！");
        Subject proxy = new StaticProxy(realSubject);
        proxy.show();
        System.out.println("静态二次次代理");
        proxy = new StaticProxy(proxy);
        proxy.show();


        //Jdk动态代理
        //得到的代理对象是Object！
        //可以根据接口强转为原来的类型！
        //可以代理任何接口类型，不用开发新的类！
        //可以进行多重代理
        realSubject = new RealSubject();
        System.out.println("Jdk 一次  动态代理");
        Subject proxy1 = (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),
                realSubject.getClass().getInterfaces(),
                new JdkProxyLogic(realSubject));
        proxy1.show();
        System.out.println("Jdk 二次  动态代理");
        proxy1 = (Subject) Proxy.newProxyInstance(proxy1.getClass().getClassLoader(),
                proxy1.getClass().getInterfaces(),
                new JdkProxyLogic(proxy1));
        proxy1.show();

        //Cglib动态代理
        //不需要实现接口！但是需要可继承，不能是final
        //对任何对象进行代理，增强
        //不能进行多重代理
        realSubject = new RealSubject();
        System.out.println("cglib 动态代理");
        Enhancer proxyHelp = new Enhancer();
        proxyHelp.setClassLoader(realSubject.getClass().getClassLoader());
        proxyHelp.setSuperclass(realSubject.getClass());
        proxyHelp.setCallback(new CglibProxyLogic());
        Subject proxy2 = (Subject) proxyHelp.create();
        proxy2.show();
    }
}
```

### 7、享元模式

共享对象，重复利用相同的对象

是否共享取决于对象的内部状态，每个类根据不同的内部状态创建对象；

外部状态是随时改变的状态，使用频率低，不共享；

##### ①、抽象享元

```java
public interface FlyWeight {
    //将外部状态作为形参传入
    void operation(String externalState);
}
```

##### ②、具体享元

```java
public class ConcreteFlyWeight implements FlyWeight{
    //存储内部状态
    private String internalState;
    public ConcreteFlyWeight(String internalState){
        this.internalState = internalState;
    }
    //结合内部状态和外部状态进行操作
    @Override
    public void operation(String externalState) {
        System.out.println("HashCode:" + this.hashCode());
        System.out.println("InternalState:" + internalState);
        System.out.println("ExternalState:" + externalState);
    }
}
```

##### ③、享元工厂

```java
public class FlyWeightFactory {
    //关联一个享元池
    public static Map<String, FlyWeight> pool = new HashMap<>();
    //根据内部状态从享元池获取共享对象
    public static FlyWeight getFlyWeight(String internalState){
        if(!pool.containsKey(internalState)){
            pool.put(internalState,new ConcreteFlyWeight(internalState));
        }
        return pool.get(internalState);
    }
}
```

##### ④、测试类

```java
public class FlyWeightTest {
    public static void main(String[] args) {
        FlyWeight flyWeight1 = null;
        //第一次获取内部信息为key1
        flyWeight1 = FlyWeightFactory.getFlyWeight("key1");
        flyWeight1.operation("aa");
        //第一次获取内部信息为key2
        flyWeight1 = FlyWeightFactory.getFlyWeight("key2");
        flyWeight1.operation("bb");
        //第二次获取内部信息为key1
        flyWeight1 = FlyWeightFactory.getFlyWeight("key1");
        flyWeight1.operation("cc");
        //第二次获取内部信息为key2
        flyWeight1 = FlyWeightFactory.getFlyWeight("key2");
        flyWeight1.operation("dd");
    }
}
```

## 三、行为型设计模式

### 1、策略模式

关联策略类，将具体执行过程委托给策略类，可以对策略类提供参数输入；

##### ①、抽象策略

```java
public interface Strategy {
    void doThis(int a, int b);
}
```

##### ②、具体策略

```java
public class Strategy1 implements Strategy{
    @Override
    public void doThis(int a, int b) {
        System.out.println(a + b);
    }
}
```

```java
public class Strategy2 implements Strategy{
    @Override
    public void doThis(int a, int b){
        System.out.println(a*b);
    }
}
```

##### ③、策略调用者

```java
public class Context {
    private Strategy strategy = null;
    public Context(Strategy strategy){
        this.strategy =strategy;
    }
    public Context setStrategy(Strategy strategy){
        this.strategy = strategy;
        return this;
    }
    //将具体执行策略委托给策略类
    public void operation(int a, int b){
        strategy.doThis(a,b);
    }
}
```

##### ④、测试类

```java
public class StrategyTest {
    public static void main(String[] args) {
        Context context = null;
        //执行策略1
        context = new Context(new Strategy1());
        context.operation(2,3);
        //执行策略2
        context.setStrategy(new Strategy2());
        context.operation(2,3);
    }
}
```

### 2、状态模式

和策略模式差不多，委托具体的状态执行不同的操作；

不同的是，需要将自身的引用传输给状态，状态在完成处理后负责将环境的状态推进

##### ①、环境类

```java
public class Context {
    private State state = null;
    public void setState(State state){
        this.state = state;
    }
    public void handel(){
        state.doAction(this);
    }
}
```

##### ②、抽象状态

```java
public interface State {
    void doAction(Context context);
}
```

##### ③、具体状态

```java
public class StartState implements State{
    @Override
    public void doAction(Context context){
        System.out.println("this is StartState!");
        context.setState(new DoingState());
    }
}
```

```java
public class DoingState implements State{
    @Override
    public void doAction(Context context){
        System.out.println("this is DoingState!");
        context.setState(new StopState());
    }
}
```

```java
public class StopState implements State{
    @Override
    public void doAction(Context context){
        System.out.println("this is StopState!");
        context.setState(new StartState());
    }
}
```

##### ④、测试类

```java
public class StateTest {
    public static void main(String[] args) {
        Context context = new Context();
        //起始状态
        context.setState(new StartState());
        //开始进行处理
        context.handel();
        context.handel();
        context.handel();
    }
}
```

### 3、中介者模式

负责对象之间的交互

对象关联中介者，不关联具体对象；

中介者转发对象的请求到指定对象

##### ①、抽象用户

```java
public abstract class User {
    protected AbstractMediator mediator = null;
    protected String name = null;
    public User(AbstractMediator mediator, String name){
        this.mediator = mediator;
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
    public User setMediator(AbstractMediator mediator){
        this.mediator = mediator;
        return this;
    }
    public void sentMessage(String to, String message){
        mediator.sentMessage(this.name,to,message);
    }
    public void receiveMessage(String message){
        System.out.println(message);
    }
}
```

##### ②、具体用户

```java
public class UserA extends User{
    public UserA(AbstractMediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void sentMessage(String to, String message) {
        System.out.println("this is userA, I will sent message!");
        super.sentMessage(to,message);
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println("this is userA, I will receive a message ：");
        super.receiveMessage(message);
    }
}
```

```JAVA
public class UserB extends User{
    public UserB(AbstractMediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void sentMessage(String to, String message) {
        System.out.println("this is userB, I will sent message!");
        super.sentMessage(to,message);
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println("this is userB, I will receive a message：");
        super.receiveMessage(message);
    }
}
```



##### ③、抽象中介者

```java
public abstract class AbstractMediator {
    //提供中介者通用业务
    public abstract AbstractMediator add(User user);
    public abstract void sentMessage(String from, String to, String message);
}
```

##### ④、具体中介者

```java
public class ConcreteMediator1 extends AbstractMediator{
    //实现具体中介者，包括对象组织形式，具体业务
    private  Map<String,User> users = new HashMap<>();

    @Override
    public AbstractMediator add(User user) {
        this.users.put(user.getName(),user);
        return this;
    }

    @Override
    public void sentMessage(String from, String to, String message) {
        if(users.containsKey(to)){
            users.get(to).receiveMessage(from +" sent you ： "+ message);
        }
    }
}
```

##### ⑤、测试类

```java
public class MeduatorTest {
    public static void main(String[] args) {
        //创建中介者
        AbstractMediator mediator = new ConcreteMediator1();
        //创建需要交互的对象
        User a = new UserA(mediator,"A");
        User b = new UserB(mediator,"B");
        //在中介注册
        mediator.add(a).add(b);
        //给对方发消息
        a.sentMessage("B","I love you!");
        b.sentMessage("A","I love you, too!");
    }
}
```

### 4、模板方法

委托子类实现算法的某一步骤；

与策略模式不同，策略模式是委托策略实现，是关联了抽象策略；

模板方法采用抽象模板定义算法，继承抽象模板实现某一步骤；

##### ①、抽象模板

```java
public abstract class AbstractTemplate {
    public void service(){
        a();
        b();
        c();
    }
    public void a(){
        System.out.println("this is AbstractTemplate a!");
    }
    public void b(){
        System.out.println("this is AbstractTemplate b!");
    }
    public abstract void c();
}
```

##### ②、具体模板

```java
public class ConcreteTemplate1 extends AbstractTemplate{
    @Override
    public void c() {
        System.out.println("this is ConcreteTemplate1 c!");
    }
}
```

```java
public class ConcreteTemplate2 extends AbstractTemplate{
    @Override
    public void c() {
        System.out.println("this is ConcreteTemplate2 c!");
    }
}
```

##### ③、测试类

```java
public class TemplateTest {
    public static void main(String[] args) {
        AbstractTemplate template = null;
        //具体实现1
        template= new ConcreteTemplate1();
        template.service();
        //具体实现2
        template = new ConcreteTemplate2();
        template.service();
    }
}
```

### 5、命令模式

请求与具体执行者的交互交给命令来完成；

请求不指定执行者，只需调用能完成请求的命令；

命令不关心请求的来源，只负责把本职工作交给具体执行者做；

执行者不关心什么请求，什么命令，只负责做自己的事情；

适合命令多的业务场景；

##### ①、抽象命令

```java
public interface AbstractCommand {
    AbstractCommand addReceiver(Receiver receiver);
    void execute();
}
```

##### ②、具体命令

```java
public class ConcreteCommand implements AbstractCommand{
    private Receiver receiver = null;
    public ConcreteCommand(Receiver receiver){
        this.receiver = receiver;
    }

    @Override
    public AbstractCommand addReceiver(Receiver receiver) {
        this.receiver = receiver;
        return this;
    }

    @Override
    public void execute() {
        System.out.println("command receive request!");
        receiver.execute();
    }
}
```

##### ③、命令调用者

```java
public class Invoker {
    private AbstractCommand command = null;
    public Invoker setCommand(AbstractCommand command){
        this.command = command;
        return this;
    }
    public void executeCommand(){
        System.out.println(" I will sent a request!");
        command.execute();
    }
}
```

##### ④、命令执行者

```java
public class Receiver {
    public void execute(){
        System.out.println("receive is working!");
    }
}
```

##### ⑤、测试类

```java
public class CommandTest {
    public static void main(String[] args) {
        Invoker invoker = new Invoker().setCommand(new ConcreteCommand(new Receiver()));

        invoker.executeCommand();
    }
}
```

### 6、迭代器模式

适合遍历集合，将集合的遍历与实现解耦；

迭代器不关心集合是如何存储数据的，只要集合能提供相关输入，就能实现遍历；

集合不关心遍历是如何实现的，只要有迭代器就能得到遍历结果；

##### ①、抽象迭代器

```java
public interface Iterator {
    boolean hasNext();
    Object next();
}
```

##### ②、具体迭代器

```java
public class UserListIterator implements Iterator{
    private UserList list;
    private int index;
    public UserListIterator(UserList list){
        this.list = list;
        this.index = 0;
    }

    @Override
    public boolean hasNext() {
        return index < list.getLength();
    }

    @Override
    public Object next() {
        return list.at(index++);
    }
}
```

##### ③、抽象集合

```java
public interface Collection {
    Iterator getIterator();
}
```

##### ④、具体集合

```java
public class UserList implements Collection{
    private List<User> users = new ArrayList<>();
    public UserList add(User user){
        this.users.add(user);
        return this;
    }
    @Override
    public Iterator getIterator() {
        return new UserListIterator(this);
    }

    public int getLength() {
        return users.size();
    }

    public User at(int index) {
        return users.get(index);
    }
}
```

##### ⑤、集合元素

```java
public class User {
    public void show(){
        System.out.println("this is user: " +hashCode());
    }
}
```

##### ⑥、测试类

```java
public class IteratorTest {
    public static void main(String[] args) {
        UserList list = new UserList().add(new User()).add(new User()).add(new User());
        //迭代器遍历
        Iterator iterator = list.getIterator();
        while(iterator.hasNext()){
            User next = (User) iterator.next();
            next.show();
        }
    }
}
```

### 7、责任链

持有自己的负责人，当无法处理的时候交给负责人处理

##### ①、抽象处理者

```java
public abstract class Handler {
    protected Handler nextHandler;
    public Handler setNextHandler(Handler handler){
        this.nextHandler = handler;
        return this;
    }
    public abstract void handle(String msg);
}
```

##### ②、具体处理者

```java
public class HandlerA extends Handler{
    @Override
    public void handle(String msg) {
        if(msg.equals("A")){
            System.out.println("this is HandleA working!");
        }else{
            nextHandler.handle(msg);
        }
    }
}
```

```java
public class HandlerB extends Handler{
    @Override
    public void handle(String msg) {
        if(msg.equals("B")){
            System.out.println("this is HandleB working!");
        }else{
            nextHandler.handle(msg);
        }
    }
}
```

```java
public class HandlerC extends Handler{
    @Override
    public void handle(String msg) {
        if(msg.equals("C")){
            System.out.println("this is HandleC working!");
        }else{
            nextHandler.handle(msg);
        }
    }
}
```

##### ③、测试类

```java
public class HandlerTest {
    public static void main(String[] args) {
        Handler a = null,b = null,c = null;
        //创建处理者
        a = new HandlerA();
        b = new HandlerB();
        c = new HandlerC();
        //设置链
        a.setNextHandler(b);
        b.setNextHandler(c);
        //处理请求
        a.handle("A");
        a.handle("B");
        a.handle("C");
    }
}
```

### 8、访问者模式

元素提供一个方法，接受访问者的访问，在这个方法中将自身的引用交给访问者，访问者想看什么就看什么；

访问者针对不同对象有不同的访问方法，每个方法都需要一个相应元素的形参，在方法内部访问元素；

元素有一个集合，统一接待访问者，将访问者分配给集合的元素；

缺点：当元素扩展子类，需要重改访问者所有的类，因为访问者接口不存在对该类的访问方法；

##### ①、抽象元素

```java
public abstract class Element {
    protected String fname;

    protected String lname;
    public Element(String fname, String lname){
        this.fname = fname;
        this.lname = lname;
    }
    public abstract void accept(Visitor visitor);
}
```

##### ②、具体元素

```java
public class ElementA extends Element{
    public ElementA(String fname, String lname) {
        super(fname, lname);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String  getfName(){
        return this.fname;
    }

    public String getlName(){
        return this.lname;
    }
}
```

```java
public class ElementB extends Element{
    public ElementB(String fname, String lname) {
        super(fname, lname);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String  getfName(){
        return this.fname;
    }

    public String getlName(){
        return this.lname;
    }
}
```

##### ③、元素集合

```java
public class ElementList {
    private List<Element> list;
    public ElementList(){
        list = new ArrayList<>();
        list.add(new ElementA("Af","Al"));
        list.add(new ElementB("Bf","Bl"));
    }
    public void accept(Visitor visitor){
        for (Element element : list) {
            element.accept(visitor);
        }
    }
}
```

##### ④、抽象访问者

```java
public interface Visitor {
    void visit(ElementA element);
    void visit(ElementB element);
}
```

##### ⑤、具体访问者

```java
public class Visitor1 implements Visitor{
    @Override
    public void visit(ElementA element) {
        System.out.println("visitorA visit A`s fname:" + element.getfName());
    }

    @Override
    public void visit(ElementB element) {
        System.out.println("visitorA visit B`s fname:" + element.getfName());
    }
}
```

```java
public class Visitor2 implements Visitor{
    @Override
    public void visit(ElementA element) {
        System.out.println("visitor2 visit A`s lname:" + element.getlName());
    }

    @Override
    public void visit(ElementB element) {
        System.out.println("visitor2 visit B`s lname:" + element.getlName());
    }
}
```

##### ⑥、测试类

```java
public class VisitorTest {
    public static void main(String[] args) {
        //创建元素集合
        ElementList list = new ElementList();
        //迎接不同的访问者
        list.accept(new Visitor1());
        list.accept(new Visitor2());
    }
}
```

### 9、解释器模式

对表达式进行解释，自定义语法规则

语法规则用非终结表达式表示，常量和变量用终结表达式表示；

环境表示解释的上下文，保存变量的值

核心方法是表达式类里的解释方法

##### ①、抽象表达式

```java
public interface Expression {
    //解释
    int interpreter(Context context);
    //表达
    String getStr();
}
```

##### ②、非终结表达式

```java
public class AddExp implements Expression{
    private Expression l,r;
    public AddExp(Expression l, Expression r){
        this.l = l;
        this.r = r;
    }
    @Override
    public int interpreter(Context context) {
        return l.interpreter(context) + r.interpreter(context);
    }

    @Override
    public String getStr() {
        return "(" +l.getStr() +"+"+ r.getStr() +")";
    }
}
```

```java
public class MinusExp implements Expression{
    private Expression l,r;
    public MinusExp(Expression l, Expression r){
        this.l = l;
        this.r = r;
    }
    @Override
    public int interpreter(Context context) {
        return l.interpreter(context) - r.interpreter(context);
    }

    @Override
    public String getStr() {
        return "(" +l.getStr() +"-"+ r.getStr() +")";
    }
}
```

##### ③、终结表达式

```java
public class Variable implements Expression{
    private String name;
    public Variable(String name){
        this.name = name;
    }
    @Override
    public int interpreter(Context context) {
        return context.getValue(this);
    }

    @Override
    public String getStr() {
        return this.name;
    }
}
```

```java
public class Constant implements Expression{
    private int value;
    public Constant(int value){
        this.value = value;
    }
    @Override
    public int interpreter(Context context) {
        return value;
    }

    @Override
    public String getStr() {
        return String.valueOf(value);
    }
}
```

##### ④、上下文环境

```java
public class Context {
    private Map<Variable,Integer> map = new HashMap<>();;
    public void setValue(Variable variable, int value){
        map.put(variable,value);
    }
    public int getValue(Variable variable){
        return map.get(variable);
    }
}
```

##### ⑤、测试类

```java
public class InterpreterTest {
    public static void main(String[] args) {
        //创建变量和常量
        Variable x = new Variable("x");
        Variable y = new Variable("y");
        Constant a = new Constant(10);
        Constant b = new Constant(20);
        //摄制环境，为变量赋值
        Context context = new Context();
        context.setValue(x,2);
        context.setValue(y,3);
        //构建复杂表达式
        Expression exp = new AddExp(new AddExp(x,a),new AddExp(y,new MinusExp(x,b)));
        //输出解释结果
        System.out.println(exp.getStr() +"=" + exp.interpreter(context));
    }
}
```

### 10、观察者模式

主题类有一个状态，关联了观察者集合，当主题状态改变时，通知关联的所有观察者进行处理；

观察者关联主题类，通过更新操作对主题新的状态进行处理；

##### ①、主题

```java
public class Subject {
    //关联观察者集合
    private List<Observer> observers = new ArrayList<>();
    //状态
    private String state;
	//订阅
    public void attach(Observer observer){
        observers.add(observer);
    }
    //取消订阅
    public void detach(Observer observer){
        observers.remove(observer);
    }
    //通知
    public void notifyAllObservers(){
        for(Observer observer : observers){
            observer.update();
        }
    }
    //获取状态
    public String getState(){
        return state;
    }
    //设置状态
    public void setState(String state){
        this.state = state;
        notifyAllObservers();
    }
}
```

##### ②、抽象观察者

```java
public abstract class Observer {
    //关联主题
    protected Subject subject;
    //处理通知
    public abstract void update();
}
```

##### ③、具体观察者

```java
public class Observer1 extends Observer{
    //订阅通知
    public Observer1(Subject subject){
        this.subject = subject;
        subject.attach(this);
    }
    @Override
    //对通知的具体处理
    public void update() {
        System.out.println("this is Object1: " +subject.getState());
    }
}
```

```java
public class Observer2 extends Observer{
    //订阅通知
    public Observer2(Subject subject){
        this.subject = subject;
        subject.attach(this);
    }
    @Override
    //对通知的具体处理
    public void update() {
        System.out.println("this is observer2: "+subject.getState());
    }
}
```

##### ④、测试类

```java
public class ObserverPatternTest {
    public static void main(String[] args) {
        //创建主题
        Subject subject = new Subject();
        //创建观察者并订阅主题
        new Observer1(subject);
        new Observer2(subject);
		//主题更新，自动通知观察者
        subject.setState("主题1！");
        subject.setState("主题2！");
    }
}
```



### 11、备忘录模式

原始类将内部状态暂存起来，以后需要恢复的时候传入备忘录恢复

原始类通过依赖的关系和备忘录产生关系，要么产生备忘录，要么依赖备忘录恢复；

备忘录不对外暴露，提供一个管理类对备忘录进行管理，管理类不能产生和修改备忘录。

##### ①、原始类

```java
public class Original {
    private String state;
    public void setState(String state){
        this.state = state;
    }
    public void restoreState(Memento memento){
        this.state = memento.getState();
    }
    public Memento createMemento(){
        return new Memento(state);
    }
    public void showState(){
        System.out.println("My state is " +state);
    }
}
```

##### ②、备忘录类

```java
class Memento {
    private String state;
    public Memento(String state){
        this.state = state;
    }
    public String getState(){
        return this.state;
    }
}
```

##### ③、备忘录管理类

```java
public class CareTaker {
    private Memento memento;
    public void setMemento(Memento memento){
        this.memento = memento;
    }
    public Memento getMemento(){
        return this.memento;
    }
}
```

##### ④、测试类

```java
public class MementorTest {
    public static void main(String[] args) {
        //创建初始状态
        Original original = new Original();
        original.setState("A");
        original.showState();
        //创建备忘录
        CareTaker careTaker = new CareTaker();
        careTaker.setMemento(original.createMemento());
        //更新状态
        original.setState("B");
        original.showState();
        //恢复状态
        original.restoreState(careTaker.getMemento());
        original.showState();
    }
}
```

