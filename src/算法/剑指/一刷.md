#### 1、[09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class CQueue {

    private int[] st1 = new int[10001];
    private int[] st2 = new int[10001];
    private int t1 = -1;
    private int t2 = -1;

    public CQueue() {

    }
    
    public void appendTail(int value) {
        st1[++t1] = value;
    }
    
    public int deleteHead() {
        if(t2 != -1){
            return st2[t2--];
        }
        if(t1 == -1){
            return -1;
        }
        while(t1 != -1){
            st2[++t2] = st1[t1--];
        }
        return st2[t2--];
    }
}
```

#### 2、[30. 包含min函数的栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class MinStack {

    private int[] st = new int[20000];
    private int t = -1;
    //记录最小值
    private int min = Integer.MAX_VALUE;
    public MinStack() {

    }
    
    public void push(int x) {
        st[++t] = x;
        //更新最小值
        min = Math.min(min, x);
    }
    
    public void pop() {
        if(t != -1){
            t--;
            //更新最小值
            if(st[t +1] == min){
                min = getmin();
            }
        }
    }
    //获取最小值
    public int getmin(){
        if(t == -1){
            return Integer.MAX_VALUE;
        }
        int min = Integer.MAX_VALUE;
        for(int i = 0; i <= t; i++){
            min = Math.min(min, st[i]);
        }
        return min;
    }
    
    public int top() {
        return st[t];
    }
    
    public int min() {
        return min;
    }
}
```

#### 3、[06. 从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        int[] nums = new int[10001];
        int i = 0;
        ListNode cur = head;
        //顺序记录
        while(cur != null){
            nums[i++] = cur.val;
            cur = cur.next;
        }
        //翻转
        reverse(nums, 0, i -1);
        return Arrays.copyOf(nums, i);
    }
    public void reverse(int[] nums, int l, int r){
        while(l < r){
            nums[l] ^= nums[r];
            nums[r] ^= nums[l];
            nums[l++] ^= nums[r--];
        }
    }
}
```

#### 4、[24. 反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode next = null;
        while(cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

#### 5、[35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public Node copyRandomList(Node head) {
        Map<Node, Node> map = new HashMap<>();
        Node res = new Node(0);
        Node cur = head;
        Node p = res;
        //构造映射
        while(cur != null){
            Node node = new Node(cur.val);
            map.put(cur, node);
            p.next = node;
            p = node;
            cur = cur.next;
        }
        p.next = null;
        p = res.next;
        cur = head;
        //连接随机指针
        while(p != null){
            if(cur.random == null){
                p.random = null;
            }else{
                p.random = map.get(cur.random);
            }
            p = p.next;
            cur = cur.next;
        }
        return res.next;
    }
}
```

#### 6、[ 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(char c : s.toCharArray()){
            if(c == ' '){
                sb.append("%20");
            }else{
                sb.append(c);
            }
        }
        return sb.toString();
    }
}
```

#### 7、[58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        char[] ss = s.toCharArray();
        int len =  ss.length;
        reverse(ss, 0, n -1);
        reverse(ss, n, len -1);
        reverse(ss, 0, len -1);
        return String.valueOf(ss);
    }
    public void reverse(char[] s, int l, int r){
        while(l < r){
            s[l] ^= s[r];
            s[r] ^= s[l];
            s[l++] ^= s[r--];
        }
    }
}
```

#### 8、[03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        boolean[] set = new boolean[nums.length];
        for(int v : nums){
            if(set[v]){
                return v;
            }
            set[v] = true;
        }
        return 0;
    }
}
```

#### 9、[53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if(n == 0){
            return 0;
        }
        //左右端点
        int l = 0;
        int r = n -1;
        while(l < r){
            //上取整
            int m = l +(r -l +1)/2;
            //整右边
            if(nums[m] > target){
                r = m -1;
            }else{
                l = m;
            }
        }
        //要么不存在，要么是最后一个的下标
        if(nums[l] != target){
            return 0;
        }
        int tarr = l;
        l = 0;
        while(l < r){
            //下取整
            int m = l +(r -l)/2;
            //整左边
            if(nums[m] < target){
                l = m +1;
            }else{
                r = m;
            }
        }
        //最后一个的下标和第一个的下标之间的距离
        return tarr -l +1;
    }
}
```

#### 10、[53 - II. 0～n-1中缺失的数字](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int l = 0;
        int r = n -1;
        while(l < r){
            int m = l + (r -l)/2;
            if(nums[m] == m){
                l = m +1;
            }else{
                r = m;
            }
        }
        //循环出来后，要么是第一个和下标不相等的下标，要么每一个都和下标相等，缺最大那个
        return l == nums[l] ? n : l;
    }
}
```

#### 11、[04. 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int m = matrix.length;
        if(m == 0){
            return false;
        }
        int n = matrix[0].length;
        if(n == 0){
            return false;
        }
        return find(matrix, new int[]{0, 0}, new int[]{m -1, n -1}, target) == target;
    }
    public int find(int[][] nums, int[] l, int[] r, int tar){
        //递归出口
        if(l[0] > r[0] || l[1] > r[1]){
            return nums[0][0];
        }
         if(l[0] == r[0] && l[1] == r[1]){
            return nums[l[0]][l[1]];
        }
        //边界记录
        int[] st = new int[2];
        int[] en = new int[2];
        st[0] = l[0];st[1] = l[1]; en[0] = r[0]; en[1] = r[1];
        //对角线二分
        while(l[0] < r[0] || l[1] < r[1]){
            int mh = l[0] + (r[0] -l[0])/2;
            int ml = l[1] + (r[1] -l[1])/2;
            if(nums[mh][ml] < tar){
                l[0] = Math.min(mh +1, r[0]);
                l[1] = Math.min(ml +1, r[1]);
            }else{
                r[0] = mh;
                r[1] = ml;
            }
        }
        //状态判定
        if(nums[l[0]][l[1]] == tar){
            return tar;
        }
        //搜索左下角和右上角
        if(find(nums, new int[]{st[0], l[1]}, new int[]{l[0] -1, en[1]}, tar) == tar){
            return tar;
        }
        return find(nums, new int[]{l[0], st[1]}, new int[]{en[0], l[1] -1}, tar);
    }
}
```

#### 12、[11. 旋转数组的最小数字](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int minArray(int[] numbers) {
        return help(numbers, 0, numbers.length -1);
    }
    public int help(int[] nums, int l, int r){
        //递归出口
        if(l == r){
            return nums[l];
        }
        int m = l + (r -l)/2;
        //状态分析，向左还是向右找，还是不确定在左边还是右边
        if(nums[m] < nums[r]){
            return help(nums, l, m);
        }else if(nums[m] > nums[r]){
            return help(nums, m +1, r);
        }else if(nums[m] < nums[l]){
            return help(nums, l, m);
        }else{
            return Math.min(help(nums, l, m), help(nums, m +1, r));
        }
    }
}
```

#### 13、[50. 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public char firstUniqChar(String s) {
        char[] ss = s.toCharArray();
        int[] count = new int[26];
        for(char c : ss){
            count[c -'a']++;
        }
        for(char c : ss){
            if(count[c -'a'] == 1){
                return c;
            }
        }
        return ' ';
    }
}
```

#### 14、[32 - I. 从上到下打印二叉树](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root == null){
            return new int[0];
        }
        //暂存值
        int[] res = new int[1001];
        int p = -1;
        //队列
        TreeNode[] q = new TreeNode[1001];
        int in = -1;
        int out = 0;
        q[++in] = root;
        while(in >= out){
            int size = in -out +1;
            //层遍历
            while(size-- > 0){
                TreeNode cur = q[out++];
                res[++p] = cur.val;
                if(cur.left != null){
                    q[++in] = cur.left;
                }
                if(cur.right != null){
                    q[++in] = cur.right;
                }
            }
        }
        return Arrays.copyOf(res, p +1);
    }
}
```

#### 15、[32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //暂存值
        List<List<Integer>> res = new ArrayList<>(); 
        //队列
        TreeNode[] q = new TreeNode[2001];
        int in = -1;
        int out = 0;
        if(root != null){
            q[++in] = root;
        }
        while(in >= out){
            int size = in -out +1;
            List<Integer> list = new ArrayList<>();
            //层遍历
            while(size-- > 0){
                TreeNode cur = q[out++];
                list.add(cur.val);
                if(cur.left != null){
                    q[++in] = cur.left;
                }
                if(cur.right != null){
                    q[++in] = cur.right;
                }
            }
            res.add(list);
        }
        return res;
    }
}
```

#### 16、[32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //暂存值
        List<List<Integer>> res = new ArrayList<>(); 
        //队列
        TreeNode[] q = new TreeNode[2001];
        int in = -1;
        int out = 0;
        if(root != null){
            q[++in] = root;
        }
        //加入方向，每层取反
        boolean left = true;
        while(in >= out){
            int size = in -out +1;
            LinkedList<Integer> list = new LinkedList<>();
            //层遍历
            while(size-- > 0){
                TreeNode cur = q[out++];
                //头插或者尾插
                if(left){
                    list.add(cur.val);
                }else{
                    list.addFirst(cur.val);
                }
                if(cur.left != null){
                    q[++in] = cur.left;
                }
                if(cur.right != null){
                    q[++in] = cur.right;
                }
            }
            res.add(list);
            left = !left;
        }
        return res;
    }
}
```

#### 17、[26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        //根节点不能为空
        if(A == null || B == null){
            return false;
        }
        return check(A, B);
    }
    public boolean check(TreeNode a, TreeNode b){
        //左子树有b的结构
        boolean l = a.left == null ? false : check(a.left, b);
        //右子树有b的结构
        boolean r = a.right == null ? false : check(a.right, b);
        //从当前结点开始是b的结构
        boolean cur = sameTop(a, b);
        return l || r || cur;
    }
    //从当前结点开始，自顶向下是a的一部分
    public boolean sameTop(TreeNode a, TreeNode b){
        //b空了，a空了就是相等，不空是部分，都应该是true
        if(b == null){
            return true;
        }
        //a空了，肯定不行；结点不相等，肯定不行
        if(a == null || a.val != b.val){
            return false;
        }
        //左子树和右子树在不为空前都要相等
        return sameTop(a.left, b.left) && sameTop(a.right, b.right);
    }
}
```

#### 18、[27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null){
            return root;
        }
        TreeNode l = root.left;
        TreeNode r = root.right;
        root.left = mirrorTree(r);
        root.right = mirrorTree(l);
        return root;
    }
}
```

#### 19、[28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        return check(root.left, root.right);
    }
    public boolean check(TreeNode a, TreeNode b){
        if(a == null && b == null){
            return true;
        }
        if(a == null || b == null || a.val != b.val){
            return false;
        }
        return check(a.left, b.right) && check(a.right, b.left);
    }
}
```

#### 20、[10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int fib(int n) {
        if(n == 0){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        int a = 0;
        int b = 1;
        int sum = 0;
        while(n-- > 1){
            sum = a +b;
            sum %= 1000000007;
            a = b;
            b = sum;
        }
        return sum;
    }
}
```

#### 21、[10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int numWays(int n) {
        if(n < 2){
            return 1;
        }
        int a = 1;
        int b = 1;
        int sum = 0;
        while(n-- > 1){
            sum = a +b;
            sum %= 1000000007;
            a = b;
            b = sum;
        }
        return sum;
    }
}
```

#### 22、[63. 股票的最大利润](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if(n < 2){
            return 0;
        }
        int hav = -prices[0];
        int no = 0;
        for(int i = 1; i < n; i++){
            no = Math.max(no, prices[i] + hav);
            hav = Math.max(hav, -prices[i]);
        }
        return no;
    }
}
```

#### 23、[42. 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int cur = nums[0];
        for(int i = 1; i < nums.length; i++){
            cur = Math.max(cur + nums[i], nums[i]);
            max = Math.max(max, cur);
        }
        return max;
    }
}
```

#### 24、[47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int maxValue(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m +1][n +1];
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                dp[i][j] = Math.max(dp[i -1][j], dp[i][j -1]) + grid[i -1][j -1];
            }
        }
        return dp[m][n];
    }
}
```

#### 25、[ 46. 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int translateNum(int num) {
        char[] s = String.valueOf(num).toCharArray();
        int  n = s.length;
        int[] dp = new  int[n +1];
        dp[1] = 1;
        dp[0] = 1;
        for(int i = 2; i <= n; i++){
            dp[i] = dp[i -1];
            if(s[i -2] == '1' || s[i -2] == '2' && s[i -1] <  '6'){
                dp[i] += dp[i -2];
            }
        }
        return dp[n];
    }
}
```

#### 26、[48. 最长不含重复字符的子字符串](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] ss = s.toCharArray();
        //历史最长不重复
        int max = 0;
        //前一个字符结尾的最长不重复长度
        int len = 0;
        for(int i = 0; i < ss.length; i++){
            //前一个字符结尾的最长，从后往前第一个和当前字符不相等的位置，就是当前字符结尾的最长串的左端点
            len = i -nosame(ss, i -len, i -1, ss[i]);
            max = Math.max(max, len);
        }
        return max;
    }
    public int nosame(char[] s, int l, int r, char tar){
        while(l <= r && s[r] != tar)    r--;
        return r;
    }
}
```

#### 27、[18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode nhead = new ListNode(0);
        nhead.next = head;
        ListNode p = nhead;
        while(p.next != null && p.next.val != val)  p = p.next;
        p.next = p.next.next;
        return nhead.next;
    }
}
```

#### 28、[22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode f = head;
        ListNode l = head;
        while(k-- > 0){
            f = f.next;
        }
        while(f != null){
            f = f.next;
            l = l.next;
        }
        return l;
    }
}
```

#### 29、[25. 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
 class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode nhead = new ListNode(0);
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode p = nhead;
        while(p1 != null && p2 != null){
            if(p1.val < p2.val){
                p.next = p1;
                p1 = p1.next;
            }else{
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        p.next = p1 == null ? p2 : p1;
        return nhead.next;
    }
}
```

#### 30、[52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;
        while(p1 != p2){
            if(p1 == null){
                p1 = headB;
            }else{
                p1 = p1.next;
            }
            if(p2 == null){
                p2 = headA;
            }else{
                p2 = p2.next;
            }
        }
        return p1;
    }
}
```

#### 31、[21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] exchange(int[] nums) {
        int l = 0;
        int r = nums.length -1;
        while(l < r){
            if(nums[l] %2 == 1){
                l++;
            }else if(nums[r] %2 ==0){
                r--;
            }else{
                nums[l] ^= nums[r];
                nums[r] ^= nums[l];
                nums[l++] ^= nums[r--];
            }
        }
        return nums;
    }
}
```

#### 32、[57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int l = 0;
        int r = nums.length -1;
        while(l < r){
            int d = target -nums[l];
            if(nums[r] > d){
                r--;
            }else if(nums[r] < d){
                l++;
            }else{
                return new int[]{nums[l], nums[r]};
            }
        }
        return null;
    }
}
```

#### 33、[58 - I. 翻转单词顺序](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public String reverseWords(String s) {
        char[] ss = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        int n = ss.length;
        //过滤后置空格
        int st = cat(ss, n -1);
        int en = st;
        //反序遍历
        while(st >= 0){
            //单词完整
            if(ss[st] == ' '){
                //添加单词
                add(ss, st +1, en, sb);
                sb.append(' ');
                //过滤空格
                st = cat(ss, st);
                en = st;
            }else{
                st--;
            }
        }
        //最后一个单词
        if(n > 0 && ss[0] != ' '){
            add(ss, 0, en, sb);
            sb.append(' ');
        }
        //删除末尾的空格
        if(sb.length() > 0){
            sb.deleteCharAt(sb.length() -1);
        }
        return sb.toString();
    }
    //过滤后置空格
    public int cat(char[] s, int i){
        while(i >= 0 && s[i] == ' ')  i--;
        return i;
    }
    //添加单词
    public void add(char[] s, int l, int r, StringBuilder sb){
        while(l <= r){
            sb.append(s[l++]);
        }
    }
}
```

#### 34、[12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private char[][] b;
    private boolean find = false;
    private char[] w;
    private boolean[][] visit;
    private int m;
    private int n;
    private int[][] d = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0,1}};
    public boolean exist(char[][] board, String word) {
        this.b = board;
        this.m = board.length;
        this.n = board[0].length;
        this.w = word.toCharArray();
        this.visit = new boolean[m][n];
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(board[i][j] == w[0] &&  backtracking(i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }
    public boolean backtracking(int i, int j, int k){
        if(k == w.length -1){
            return true;
        }
        visit[i][j] = true;
        for(int[] p : d){
            int h = i +p[0];
            int l = j +p[1];
            if(valid(h, l) && !visit[h][l] && w[k +1] == b[h][l] && backtracking(h, l, k +1)){
                return true;
            }
        }
        visit[i][j] = false;
        return false;
    }
    public boolean valid(int i, int j){
        return i >= 0 && i < m && j >= 0 && j < n;
    }
}
```

#### 35、[13. 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private int m;
    private int n;
    private int k;
    private int res;
    private boolean[][] visit;
    private int[][] d = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
    public int movingCount(int m, int n, int k) {
        this.m = m;
        this.n = n;
        this.k = k;
        this.visit = new boolean[m][n];
        backtracking(0, 0);
        return res;
    }
    public void backtracking(int i, int j){
        res++;
        visit[i][j] = true;
        for(int[] p : d){
            int h = i +p[0];
            int l = j +p[1];
            //坐标可行且未访问
            if(valid(h, l) && !visit[h][l]){
                backtracking(h, l);
            }
        }
    }
    //判断坐标是否可行
    public boolean valid(int i, int j){
        return i >= 0 && i < m && j >= 0 && j < n && calculate(i, j) <= k;
    }
    //计算坐标数位和
    public int calculate(int i, int j){
        int res = 0;
        while(i != 0){
            res += i %10;
            i /= 10;
        }
        while(j != 0){
            res += j %10;
            j /= 10;
        }
        return res;
    }
}
```

#### 36、[34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        if(root != null){
            dfs(root, target);
        }
        return res;
    }
    public void dfs(TreeNode r, int tar){
        //处理根节点
        path.add(r.val);
        //递归出口
        if(tar == r.val && r.left == null && r.right == null){
            res.add(new ArrayList<>(path));
        }else{
            tar -= r.val;
            //左递归
            if(r.left != null){
                dfs(r.left, tar);
            }
            //右递归
            if(r.right != null){
                dfs(r.right, tar);
            }
        }
        //回溯恢复现场
        path.remove(path.size() -1);
    }
}
```

#### 37、[36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private Node pre = null;
    private Node head = null;
    public Node treeToDoublyList(Node root) {
        //先序遍历，之后调整头尾结点指针
        if(root != null){
            preOrder(root);
            head.left = pre;
            pre.right = head;
        }
        return head;
    }
    public void preOrder(Node r){
        //左递归
        if(r.left != null){
            preOrder(r.left);
        }
        //根处理
        if(pre == null){
            head = r;
        }else{
            pre.right = r;
            r.left = pre;
        }
        pre = r;
        //右递归
        if(r.right != null){
            preOrder(r.right);
        }
    }
}
```

#### 38、[54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private int k;
    private boolean find = false;
    private int res = 0;
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        preOrder(root);
        return res;
    }
    private void preOrder(TreeNode r){
        //右递归
        if(!find && r.right != null){
            preOrder(r.right);
        }
        //根处理，第k个结点返回
        if(--k == 0){
            find = true;
            res = r.val;
            return;
        }
        //左递归
        if(!find && r.left != null){
            preOrder(r.left);
        }
    }
}
```

#### 39、[45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public String minNumber(int[] nums) {
        //包装原数组
        int n = nums.length;
        Integer[] nu = new Integer[n];
        for(int i = 0; i < n; i++){
            nu[i] = nums[i];
        }
        //按拼接非降序排列
        Arrays.sort(nu, (a,b)->{
            if(isFirstBig(a, b)){
                return 1;
            }
            return -1;
        });
        //按次序拼接
        StringBuilder sb = new StringBuilder();
        for(int v : nu){
            sb.append(String.valueOf(v));
        }
        return sb.toString();
    }
    //第一个元素是否更大
    public boolean isFirstBig(int a, int b){
        String astr = String.valueOf(a);
        String bstr = String.valueOf(b);
        //分别拼接
        char[] afirst = (astr +bstr).toCharArray();
        char[] bfirst = (bstr +astr).toCharArray();
        //比较大小
        for(int i = 0; i < afirst.length; i++){
            if(afirst[i] > bfirst[i]){
                return true;
            }else if(afirst[i] < bfirst[i]){
                return false;
            }
        }
        return false;
    }
}
```

#### 40、[61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean isStraight(int[] nums) {
        //排序
        Arrays.sort(nums);
        //王的个数
        int c0 = 0;
        int i = 0;
        //遍历
        while(i < 4){
            //王
            if(nums[i] == 0){
                c0++;
                i++;
            }
            //相同的牌
            else if(nums[i] == nums[i+1]){
                return false;
            }
            //不连着的牌，使用王增加一张下一个数的牌
            else if(nums[i] != nums[i +1] -1){
                //没有王了
                if(c0 <= 0){
                    return false;
                }
                c0--;
                nums[i]++;
            }
            //连着的牌
            else{
                i++;
            }
        }
        return true;
    }
}
```

#### 41、[40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        int n = arr.length;
        //insertSort(arr, 0, n -1);
        //selectSort(arr, 0, n -1);
        //bubbleSort(arr, 0, n -1);
        //mergeSort(arr, 0, n -1);
        //quickSort(arr, 0, n -1);
        //quickSortK(arr, 0, n -1, k);
        return heapSort(arr, k);
        //shellSort(arr, 0, n -1);
        //return Arrays.copyOf(arr, k);
        //return arr;
    }
    // *************************************************************************
    //插入排序
    public void insertSort(int[] nums, int l, int r){
        //每一个元素都在已经排好序的序列里找自己的位置
        for(int i = l; i <= r; i++){
            int j = i;
            while(j > l && nums[j] <= nums[j -1]){
                swap(nums, j, j -1);
                j -= 1;
            }
        }
    }
    // ****************************************************************************
    //希尔排序
    public void shellSort(int[] nums, int l, int r){
        //分组间隔，组内实现插入排序
        for(int gap = (r -l +1)/2; gap > 0; gap /= 2){
            //插入排序
            for(int i = gap; i <= r; i++){
                int j = gap;
                while(j > l && nums[j] <= nums[j -gap]){
                    swap(nums, j, j -gap);
                    j -= gap;
                }
            }
        }
    }
    // ***************************************************************************
    //选择排序
    public void selectSort(int[] nums, int l, int r){
        for(int i = l; i < r; i++){
            //选择n-1次最小元素，按顺序放置
            int m = i;
            for(int j = i +1; j <= r; j++){
                m = nums[j] < nums[m] ? j : m;
            }
            swap(nums, m, i);
        }
    }
    // ***************************************************************************
    //冒泡排序
    public void bubbleSort(int[] nums, int l, int r){
        for(int i = r; i > l; i--){
            //进行n- 1趟冒泡，每趟将最大元素按顺序放到后边
            for(int j = 0; j < i; j++){
                if(nums[j] > nums[j +1]){
                    swap(nums, j, j +1);
                }
            }
        }
    }
    // ****************************************************************************
    //归并排序
    public void mergeSort(int[] nums, int l, int r){
        if(l >= r){
            return;
        }
        int m = l +(r -l)/2;
        mergeSort(nums, l, m);
        mergeSort(nums, m +1, r);
        //merge
        int[] temp = Arrays.copyOf(nums, nums.length);
        int i = l;
        int j = m +1;
        int k = l;
        while(i <= m && j <= r){
            if(temp[i] < temp[j]){
                nums[k++] = temp[i++];
            }else{
                nums[k++] = temp[j++];
            }
        }
        while(i <= m){
            nums[k++] = temp[i++];
        }
        while(j <= r){
            nums[k++] = temp[j++];
        }
    }
    // **********************************************************************
    //快排
    public void quickSort(int[] nums, int l, int r){
        if(l >= r){
            return;
        }
        //一次分划
        int i = l;
        int j = r;
        while(i < j){
            while(j > i && nums[j] >= nums[l])  j--;
            while(j > i && nums[i] <= nums[l])  i++;
            swap(nums, i, j);
        }
        swap(nums, l, i);
        //递归排序左右两边
        quickSort(nums, l, i -1);
        quickSort(nums, i +1, r);
    }

    // ***********************************************************************
    //快排优化
    public void quickSortK(int[] nums, int l, int r, int k){
        if(l >= r || l >= k || r < k){
            return;
        }
        //一次分划
        int i = l;
        int j = r;
        while(i < j){
            while(j > i && nums[j] >= nums[l])  j--;
            while(j > i && nums[i] <= nums[l])  i++;
            swap(nums, i, j);
        }
        swap(nums, l, i);
        //递归排序左右两边
        quickSort(nums, l, i -1);
        quickSort(nums, i +1, r);
    }


// ***************************************************************************
    //堆排
    public int[] heapSort(int[] nums, int k){
        int[] res = new int[k];
        if(k == 0){
            return res;
        }
        for(int i = 0; i < k; i++){
            res[i] = nums[i];
        }
        //k个元素的大根堆
        buildHeap(res);
        //便利剩余元素,比堆的最大元素小的，都可以进堆，并调整堆保证最大元素在根结点
        for(int i = k; i < nums.length; i++){
            if(res[0] > nums[i]){
                res[0] = nums[i];
                adjust(res, 0);
            }
        }
        return res;
    }

    //建堆，只能保证每一个结点比它的子节点大，兄弟结点大小不确定
    //自底向上，每两个节点产生一个较大者，将所有非叶子结点视为根结点，调整堆结构
    public void buildHeap(int[] nums){
        for(int i = nums.length/2 -1; i >= 0; i--){
            adjust(nums, i);
        }
    }
    //堆替换根节点后，调整根节点，使堆保持结构
    public void adjust(int[] nums, int i){
        int max = i;
        int n = nums.length;
        int l = 2*i +1;
        int r = 2*i +2;
        if(l < n && nums[l] > nums[max])    max = l;
        if(r < n && nums[r] > nums[max])    max = r;
        if(i != max){   
            swap(nums, i, max);
            adjust(nums, max);
        }
    }

// ******************************************************************************
//交换位置
    public void swap(int[] nums, int i, int j){
        if(i != j){
            nums[i] ^= nums[j];
            nums[j] ^= nums[i];
            nums[i] ^= nums[j];
        }
    }
}

```

#### 42、[41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class MedianFinder {

    //q1为小根堆；q2为大根堆；小根堆的所有元素都大于大根堆
    //保证两个堆的元素个数相等或者小根堆多一个，两个堆顶就是中位数或者小根堆的堆顶就是中位数
    //当两个堆元素相等，应该使小根堆多一个元素，为保证这个元素比大根堆所有元素都大，应当先加入大根堆，再拿堆顶加入小根堆
    //当两个堆元素不相等，就是小根堆元素多一个，应当使两个堆元素相等，为了使加入大根堆的元素怒比小根堆所有元素都小，应当先将新元素加入小根堆，再将堆顶加入大根堆；
    private PriorityQueue<Integer> q1,q2;
    public MedianFinder() {
        q1 = new PriorityQueue<Integer>((a,b)->(a -b));
        q2 = new PriorityQueue<Integer>((a,b)->(b-a));
    }
    
    public void addNum(int num) {
        if(q1.size() != q2.size()){
            q1.add(num);
            q2.add(q1.poll());
        }else{
            q2.add(num);
            q1.add(q2.poll());
        }
    }

    public double findMedian() {
        //中位数有两个，两个堆顶取平均；否则取第一个堆顶
        if(q1.size() == q2.size()){
            return (q1.peek() +q2.peek())/2.0;
        }else{
            return q1.peek();
        }
    }
}
```

#### 43、[55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
    }
}
```

#### 44、[55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return help(root) != -1;
    }
    public int help(TreeNode root){
        if(root == null){
            return 0;
        }
        int l = help(root.left);
        int r = help(root.right);
        //左子树不平衡、右子树不平衡、当前结点为根的树不平衡
        if(l == -1 || r == -1 || Math.abs(l -r) > 1){
            return -1;
        }
        return Math.max(l, r) +1; 
    }
}
```

#### 45、[64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int sumNums(int n) {
        if(n == 1){
            return 1;
        }
        return sumNums(n -1) +n;
    }
}
```

#### 46、[68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //空结点返回空；当前结点是两个之一，当前结点就是最近公共祖先
        if(root == null || root.val == p.val || root.val == q.val){
            return root;
        }
        //在左右子树找两结点的最近公共祖先
        TreeNode l = lowestCommonAncestor(root.left, p, q);
        TreeNode r = lowestCommonAncestor(root.right, p, q);
        //其中一个为空，就是另外一个，两个都不为空，说明p,q存在于当前结点左右两侧
        return l == null ? r : r == null ? l : root;
    }
}
```

#### 47、[68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root.val == p.val || root.val == q.val){
            return root;
        }
        TreeNode l = lowestCommonAncestor(root.left, p, q);
        TreeNode r = lowestCommonAncestor(root.right, p, q);
        return l == null ? r : r == null ? l : root;
    }
}
```

#### 48、[ 07. 重建二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private int[] pre,in;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.pre = preorder;
        this.in = inorder;
        return build(0, pre.length -1, 0, in.length -1);
    }
    public TreeNode build(int pl, int pr, int il, int ir){
        if(pl > pr || il > ir){
            return null;
        }
        TreeNode root = new TreeNode(pre[pl]);
        int rootIndex = il;
        while(rootIndex <= ir && in[rootIndex] != root.val) rootIndex++;
        int d = rootIndex -il;
        root.left = build(pl +1, pl +d, il, rootIndex -1);
        root.right = build(pl +d +1, pr, rootIndex +1, ir);
        return root;
    }
}
```

#### 49、[16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public double myPow(double x, int n) {
        double res = 0;
        if(n == 0){
            return 1;
        }else if(n == Integer.MIN_VALUE){
            res = help(1/x, -(n +1))*(1/x);
        }else if(n < 0){
            res = help(1/x, -n);
        }else{
            res = help(x, n);
        }
        return res;
    }
    public double help(double x, int n){
        if(n == 1){
            return x;
        }
        double k = myPow(x, n/2);
        k *= k;
        if(n %2 == 1){
            k *= x;
        }
        return k;
    }
}
```

#### 50、[33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return check(postorder, 0, postorder.length -1);
    }
    //检查某区间内的树是不是二叉搜索树
    public boolean check(int[] nums, int l, int r){
        if(l >= r){
            return true;
        }
        //找左右子树分界点
        int i = l;
        while(i < r && nums[i] < nums[r])   i++;
        //看看右子树是不是都比根要大
        int j = i;
        while(j < r && nums[j] > nums[r])   j++;
        //看看左右子树是不是都平衡
        return j >= r && check(nums, l, i -1) && check(nums, i, r -1);
    }
}
```

#### 51、[15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while(n != 0){
            res++;
            n &= n -1;
        }
        return res;
    }
}
```

#### 52、[ 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int add(int a, int b) {
        if(b == 0){
            return a;
        }
        //二进制相加，对于每一位，相反相加取1，相同取0，即异或，但是没有进位；
        //只有两个都是1，相加才需要进位，即相与，不需要进位的位置都置零，然后将结果右移一位代替进位。
        //相与右移后，不需要进位的位置都是0；异或后，需要进位的位置都是0；将其相加就是两数之和；
        //由于不能使用加法，递归调用即可，出口为其中一个为0；
        return add(a^b, (a&b)<<1);
    }
}
```

#### 53、[56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        //两个只出现一次的数字的异或结果
        int k = 0;
        for(int v : nums){
            k ^= v;
        }
        //d是只有一个位置为1的数字，k的相同位置上为1，说明这两个不同的数字在这一位不相等；
        //将所有数字按照这一位是1还是0分组，出现2次的依然还在一组，出现一次的就分开了
        int d = 1;
        while((d&k) == 0){
            d = d<<1;
        }
        //分别对两组进行异或运算，每组的结果就是只出现一次的
        int a = 0;
        int b = 0;
        for(int v : nums){
            if((d&v) == 0){
                a ^= v;
            }else{
                b ^= v;
            }
        }
        return new int[]{a,b};
    }
}
```

#### 54、[56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int singleNumber(int[] nums) {
        //对于每一个二进制位，除去出现一次的数字外，所有数字在这个位置上的1或者0都是3的倍数；
        //因此，统计每一个位置上1的个数，对3取余，如果结果是0，说明只出现一次的数字在这个位置也是0，否则就是1；
        //故，每一个位置都进行这样的统计，最后每一个位置上剩下来的，就是只出现一次的数字在这个位置的取值；
        //对于某一个位置而言，每次输入一个1或者0，统计1的个数，然后对3取余，结果为0，1，2三种状态；
        //由于二进制一个位置只有2个状态，因此，需要两个二进制位才能记录这三个状态，故使用two one两位表示；
        //所有的位置同时进行统计，故使用twos ones两个整型数字表示所有位置的三种状态。
        //由于最终结果不会出现状态2，因此最终结果只在one位，故最终结果为ones
        //对于每一个位置的状态转化，输入为0或者1,初始状态为00，01，10，输出最终状态，画出转化表；
        //根据转化表得到与非表达式；
        int twos = 0;
        int ones = 0;
        for(int v : nums){
            ones = (ones^v) & ~twos;
            twos = (twos^v) & ~ones;
        }
        return ones;
    }
}
```

#### 55、[39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int majorityElement(int[] nums) {
        //超过一半，说明一对一拼杀，最后至少还剩一个
        int cur = 0;
        int count = 0;
        for(int v : nums){
            if(count == 0){
                cur = v;
                count = 1;
            }else if(cur == v){
                count++;
            }else{
                count--;
            }
        }
        return cur;
    }
}
```

#### 57、[66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] constructArr(int[] a) {
        int n = a.length;
        if(n == 0){
            return a;
        }
        //前缀积数组
        int[] pre = new int[n];
        //后缀积数组
        int[] last = new int[n];
        pre[0] = 1;
        last[n -1] = 1;
        for(int i = 1; i < n; i++){
            pre[i] = pre[i -1] *a[i -1];
        }
        for(int i = n -2; i >= 0; i--){
            last[i] = last[i +1] *a[i +1];
        }
        //每个位置的前缀积和后缀积相乘即为出去当前元素的2所有元素的积
        for(int i = 0; i < n; i++){
            pre[i] *= last[i];
        }
        return pre;
    }
}
```

#### 58、[14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int cuttingRope(int n) {
        if(n < 4){
            return n -1;
        }
        //根据均值不等式，切分长度相等才有可能最大；
        //问题转化为，切分长度为多少时乘积最大，列出函数表达式，求最值，最后得长度为e时最大
        //由于取整数，那就是3最大，2次之；
        //因此先按3切分，最后剩下0， 1， 2f分开讨论
        int a = n /3, b = n %3;
        int res = (int)Math.pow(3, a -1);
        return b == 0 ? res *3 : b == 1 ?  res *4 : res *6;
    }
}
```

#### 59、[57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int len = target/2 +2;
        //数组集合
        int[][] res = new int[len][];
        int p = 0;
        //最大数字是一半+1
        int[] nums = new int[len];
        for(int i = 1; i < len; i++){
            nums[i] = i;
        }
        //前缀和根左指针
        int[] pre = new int[len];
        int en = 0;
        for(int i = 1; i < len; i++){
            //计算前缀和
            pre[i] = pre[i -1] + i;
            //收缩左指针
            while(en < i -1 && pre[i] -pre[en] > target)   en++;
            //符合条件
            if(pre[i] -pre[en] == target){
                res[p++] = Arrays.copyOfRange(nums, en +1, i +1);
            }
        }
        return Arrays.copyOf(res, p);
    }
}
```

#### 60、[62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int lastRemaining(int n, int m) {
        //最后删除的数字下标
        int res = 0;
        //倒推，最后一次删除的下标肯定是0；
        //每一次删除，都是在剩余元素组成的数组里，顺数第m个
        //删除后，第m+1个元素就是下一轮删除的下标0；
        //反过来，当前元素下标加上m，同时对数组长度取模,就是上一次这个元素所在的位置下标
        //第一次的下标同时也是元素本身
        for(int i = 2; i <= n; i++){
            res = (res +m)%i;
        }
        return res;
    }
}
```

#### 61、[29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        int m = matrix.length;
        if(m == 0)  return new int[0];
        int n = matrix[0].length;
        int[] res = new int[m*n];
        int p = 0;
        int top = 0, but = m -1, l = 0, r = n -1;
        while(top <= but && l <= r){
            for(int i = l; i < r; i++){
                res[p++] = matrix[top][i];
            }
            for(int i = top; i < but; i++){
                res[p++] = matrix[i][r];
            }
            if(top == but)  break;
            for(int i = r; i > l; i--){
                res[p++] = matrix[but][i];
            }
            if(l == r)  break;
            for(int i = but; i > top; i--){
                res[p++] = matrix[i][l];
            }
            l++;
            r--;
            top++;
            but--;
        }
        if(p < m*n){
            res[p++] = matrix[but][r];
        }
        return res;
    }
}
```

#### 62、[31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        int n = pushed.length;
        //模拟入栈
        int[] st = new int[n];
        int top = -1, i = 0, j = 0;
        while(i < n && j < n){
            //还没到出栈的时候，继续入栈
            if(top == -1 || st[top] != popped[j]){
                st[++top] = pushed[i++];
            }
            //该出栈了
            else{
                j++;
                top--;
            }
        }
        //元素已经全部入栈，此时出栈次序必须相同，否则就不是正确顺序
        while(top != -1 && st[top] == popped[j]){
            j++;
            top--;
        }
        return top == -1;
    }
}
```

#### 63、[20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/)

```java
class Solution {
    public boolean isNumber(String s) {
        char[] ss = s.toCharArray();
        int i = 0, j = ss.length -1;
        //过滤空格
        while(i <= j && ss[i] == ' ')   i++;
        while(i <= j && ss[j] == ' ')   j--;
        //是否为空、是否有其它字母、是否是数值
        return i <= j && checkLetter(ss, i, j) && checkValue(ss, i, j);
    }
    //检查有没有其它字母
    public boolean checkLetter(char[] s, int l, int r){
        for(char c : s){
            if(c >= 'a' && c <= 'z' && c != 'e'){
                return false;
            }
            if(c >= 'A' && c <= 'Z' && c != 'E'){
                return false;
            }
        }
        return true;
    }
    //检查是不是数值
    public boolean checkValue(char[] s, int l, int r){
        //查找e的个数
        int e = findeEandPoint(s, l, r);
        //多个e
        if(e == -2) return false;
        //1个e
        if(e != -1){
            return isDecimalOrInteger(s, l, e -1) && isInteger(s, e +1, r);
        }
        //没有e
        return isDecimalOrInteger(s, l, r);
    }
    //判断是不是小数或者整数
    public boolean isDecimalOrInteger(char[] s, int l, int r){
        //达不到一位数字
        if(l > r)   return false;
        //去符号
        if(s[l] =='+' || s[l] == '-')   l++;
        //达不到一位数字
        if(l > r)   return false;


        //看看是不是全是数字，是的话是整数
        if(checkNumber(s, l, r)){
            return true;
        }

        //如果不是整数，看看有没有小数点
        int d = findDecimalPoint(s, l, r);
        //没有小数点，或者小数点多于1个，或者只有有小数点，但是没有数字了
        if(d < 0 || l == r)   return false;
        //检查小数点前后是不是都是数字
        return  checkNumber(s, l, d -1) && checkNumber(s, d +1, r);
    }

    //判断是不是整数
    public boolean isInteger(char[] s, int l, int r){
        //达不到一位数字
        if(l > r)   return false;
        //去符号
        if(s[l] =='+' || s[l] == '-')   l++;
        //达不到一位数字
        if(l > r)   return false;

        //检查是不是都是数字
        return checkNumber(s, l, r);
    }
    //检查是不是都是数字
    public boolean checkNumber(char[] s, int l, int r){
        for(int i = l; i <= r; i++){
            if(s[i] < '0' || s[i] > '9'){
                return false;
            }
        }
        return true;
    }


    //查找e的位置；若e个数大于1,返回-2作为false;
    public int findeEandPoint(char[] s, int l, int r){
        int e = -1;
        for(int i = l; i <= r; i++){
            if(s[i] == 'e' || s[i] == 'E'){
                if(e != -1){
                    return -2;
                }
                e = i;
            }
        }
        return e;
    }
    //查找小数点的位置，若多于一个，返回-2作为false
    public int findDecimalPoint(char[] s, int l, int r){
        int res = -1;
        for(int i = l; i <= r; i++){
            if(s[i] == '.'){
                if(res != -1){
                    return -2;
                }
                res = i;
            }
        }
        return res;
    }
}
```

```java
class Solution {
    public boolean isNumber(String s) {
        Map[] states = {
            new HashMap<>() {{ put(' ', 0); put('s', 1); put('d', 2); put('.', 4); }}, // 0.
            new HashMap<>() {{ put('d', 2); put('.', 4); }},                           // 1.
            new HashMap<>() {{ put('d', 2); put('.', 3); put('e', 5); put(' ', 8); }}, // 2.
            new HashMap<>() {{ put('d', 3); put('e', 5); put(' ', 8); }},              // 3.
            new HashMap<>() {{ put('d', 3); }},                                        // 4.
            new HashMap<>() {{ put('s', 6); put('d', 7); }},                           // 5.
            new HashMap<>() {{ put('d', 7); }},                                        // 6.
            new HashMap<>() {{ put('d', 7); put(' ', 8); }},                           // 7.
            new HashMap<>() {{ put(' ', 8); }}                                         // 8.
        };
        int p = 0;
        char t;
        for(char c : s.toCharArray()) {
            if(c >= '0' && c <= '9') t = 'd';
            else if(c == '+' || c == '-') t = 's';
            else if(c == 'e' || c == 'E') t = 'e';
            else if(c == '.' || c == ' ') t = c;
            else t = '?';
            if(!states[p].containsKey(t)) return false;
            p = (int)states[p].get(t);
        }
        return p == 2 || p == 3 || p == 7 || p == 8;
    }
}
```



#### 64、[67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int strToInt(String str) {
        char[] s = str.toCharArray();
        int i = 0, n = s.length;
        //过滤前导空格
        while(i < n && s[i] == ' ') i++;
        boolean sign = true;
        if(i >= n)  return 0;
        //判断符号
        if(s[i] == '+'){
            i++;
        }else if(s[i] == '-'){
            sign = false;
            i++;
        }
        int res = 0;
        //遍历数字
        while(i < n && s[i] >= '0' && s[i] <= '9'){
            if(sign){
                //正溢出
                if(res > (Integer.MAX_VALUE -(s[i] -'0'))/10){
                    return Integer.MAX_VALUE;
                }
            }else{
                //负溢出
                if(-res < (Integer.MIN_VALUE +(s[i] -'0'))/10){
                    return Integer.MIN_VALUE;
                }
            }
            //计算
            res *= 10;
            res += s[i++] -'0';
        }
        return sign ? res : -res;
    }
}
```

#### 65、[59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        //存储窗口最大值
        int[] res = new int[n -k +1];
        int p = 0;
        //单调升序栈
        int[] st = new int[n];
        int top = -1;
        int out = 0;
        //初始化
        for(int i = 0; i < k -1; i++){
            while(top >= out && nums[st[top]] <= nums[i])    top--;
            st[++top] = i;
        }
        //右边进栈，左边不在窗口内就出栈，从左边取窗口最大值
        for(int i = k -1; i < n; i++){
            if(st[out] +k <= i) out++;
            while(top >= out && nums[st[top]] <= nums[i])    top--;
            st[++top] = i;
            res[p++] = nums[st[out]];
        }
        return res;
    }
}
```

#### 66、[59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class MaxQueue {
    //队列
    private int[] q;
    private int qi = -1;
    private int qo = 0;
    //单调降序双端队列
    private int[] st;
    private int sti = -1;
    private int sto = 0;

    public MaxQueue() {
        q = new int[10001];
        st = new int[10001];
    }
    
    public int max_value() {
        return sti < sto ? -1 : st[sto];
    }
    
    public void push_back(int value) {
        q[++qi] = value;
        while(sti >= sto && st[sti] <= value)    sti--;
        st[++sti] = value;
    }
    
    public int pop_front() {
        if(sti >= sto && st[sto] == q[qo])  sto++;
        return qi < qo ? -1 :  q[qo++];
    }
}
```

#### 67、[38. 字符串的排列](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private StringBuilder sb = new StringBuilder();
    private List<String> res = new LinkedList<>();
    private boolean[] visit;
    public String[] permutation(String s) {
        char[] ss = s.toCharArray();
        Arrays.sort(ss);
        visit = new boolean[ss.length];
        backtracking(ss);
        return res.toArray(new String[0]);
    }
    public void backtracking(char[] s){
        if(sb.length() == s.length){
            res.add(sb.toString());
            return;
        }
        for(int i = 0; i < s.length; i++){
            //添加没有添加过的
            if(!visit[i]){
                //去重，重复元素只有在前者被访问的情况下才能访问
                if(i > 0 && !visit[i -1] && s[i] == s[i -1]){
                    continue;
                }
                sb.append(s[i]);
                visit[i] = true;
                backtracking(s);
                visit[i] = false;
                sb.deleteCharAt(sb.length() -1);
            }
        }
    }
}
```

#### 68、[37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
public class Codec {
    private int index;

    public String serialize(TreeNode root) {
        if(root == null)    return "";
        StringBuilder sb = new StringBuilder();
        preOrder(root, sb);
        sb.deleteCharAt(sb.length() -1);
        return sb.toString();
    }
    //前序遍历，记录了null的前序遍历可以唯一确定一棵二叉树
    public void preOrder(TreeNode r, StringBuilder sb){
        if(r == null){
            sb.append("*");
            sb.append(' ');
            return;
        }
        sb.append(String.valueOf(r.val));
        sb.append(' ');
        preOrder(r.left, sb);
        preOrder(r.right, sb);
    }
    public TreeNode deserialize(String data) {
        if(data == null || data.equals("")){
            return null;
        }
        index = 0;
        return build(data.split(" "));
    }
    //前序遍历构造树
    public TreeNode build(String[] s){
        if(s[index].equals("*")){
            index++;
            return null;
        }
        TreeNode r = new TreeNode(Integer.parseInt(s[index++]));
        r.left = build(s);
        r.right = build(s);
        return r;
    }
}
```

#### 69、[49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n +1];
        dp[1] = 1;
        //三指针，代表前三个转化而来的位置
        int p2 = 1, p3 = 1, p5 = 1;
        for(int i = 2; i <= n; i++){
            int num2 = dp[p2]*2;
            int num3 = dp[p3]*3;
            int num5 = dp[p5]*5;
            //取最小
            dp[i] = Math.min(num2, Math.min(num3, num5));
            //看看是哪个位置转化来的，将其移动到下一个位置，如果多个位置，一起移动
            if(dp[i] == num2){
                p2++;
            }
            if(dp[i] == num3){
                p3++;
            }
            if(dp[i] == num5){
                p5++;
            }
        }
        return dp[n];
    }
}
```

#### 70、[19. 正则表达式匹配](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public boolean isMatch(String s, String p) {
        char[] ss = s.toCharArray(), pp = p.toCharArray();
        int m = ss.length, n = pp.length;
        if(n == 0 && m == 0)    return true;
        if(n == 0)  return false;
        boolean[][] dp = new boolean[m +1][n +1];
        //空串无法比较，单独初始化
        dp[0][0] = true;
        for(int i = 1; i <= n; i++){
            if(pp[i -1] == '*'){
                dp[0][i] = dp[0][i -2];
            }
        }
        //递推
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                //当前匹配
                if(ss[i -1] == pp[j -1] || pp[j -1] == '.'){
                    dp[i][j] = dp[i -1][j -1];
                }
                //当前不匹配，但是出现*
                else if(pp[j -1] =='*'){
                    //无论p前一个字符和s当前字符相不相同，先直接丢弃前一个字符
                    dp[i][j] = dp[i][j -2];
                    //如果还没有比配，并且p前一个字符和s当前字符相同，还有机会：p让前一个字符出现一次，或者出现多次；
                    //出现一次，s和p一起丢弃最后一个字符；
                    //出现多次，让p保留*，s丢弃最后一个字符，也就是p复制了一个字符，同时保持了复制能力，可以再次进行复制。
                    if((ss[i -1] == pp[j -2] || pp[j -2] == '.') && !dp[i][j]){
                        dp[i][j] = dp[i -1][j -2] || dp[i -1][j];
                    }
                }
            }
        }
        return dp[m][n];
    }
}
```

#### 71、[ 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public double[] dicesProbability(int n) {
        int len = 6*n +1;
        double all = Math.pow(6, n);
        int[] dp = new int[len];
        for(int i = 1; i <= 6; i++)  dp[i] = 1;
        //骰子个数从小往大，前i个骰子投出点数x的组合数，需要前i-1个骰子的点数的组合数递推
        for(int i = 2; i <= n; i++){
            //滚动数组，需要左上方数据，从右往左遍历
            for(int j = 6*i; j >= i; j--){
                dp[j] = 0;
                //前i -1个骰子的最低点数，再少就是前i -2个骰子的遗留数据了
                int min = j -i +1;
                //前i -1个骰子得到的点数，加上第i个骰子的点数，就是前i个骰子得到的。
                for(int k = 1; k <= 6 && k <= min; k++){
                    dp[j] += dp[j -k];
                }
            }
        }
        double[] res = new double[len -n];
        //古典概型，样本除以总数
        for(int i = 0; i < res.length; i++){
            res[i] = dp[i +n]/all;
        }
        return res;
    }
}
```

#### 72、[17. 打印从1到最大的n位数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int[] printNumbers(int n) {
        // int max = (int)Math.pow(10, n);
        // int[] res = new int[max -1];
        // for(int i = 1; i < max; i++){
        //     res[i -1] = i;
        // }
        // return res;

        //大数版
        String[] nums = printBignumber(n);
        int[] res = new int[nums.length];
        for(int i = 0; i < res.length; i++){
            res[i] = Integer.parseInt(nums[i]);
        }
        return res;
    }
    //大数版: 回溯
    private List<String> list = new LinkedList<>();
    private StringBuilder path = new StringBuilder();
    public String[] printBignumber(int n) {
        backtracking(n, 1);
        return list.toArray(new String[0]);
    }
    public void backtracking(int n, int cur){
        //递归出口
        if(cur > n){
            if(path.length() > 0)   list.add(path.toString());
            return;
        }
        //填充每一位的数字
        for(int i = 0; i <= 9; i++){
            //不允许前导0
            if(path.length() == 0 && i == 0){
                backtracking(n, cur +1);
            }
            //递归，回溯
            else{
                path.append(i);
                backtracking(n, cur +1);
                path.deleteCharAt(path.length() -1);
            }
        }
    }
}
```

#### 73、[51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    private int ans = 0;
    private int n = 0;
    private int[] temp;
    public int reversePairs(int[] nums) {
        this.n = nums.length;
        temp = new int[n];
        mergeSort(nums, 0, n -1);
        return ans;
    }
    public void mergeSort(int[] nums, int l, int r){
        if(l >= r)  {return;}
        int m = l + (r -l)/2;
        mergeSort(nums, l, m);
        mergeSort(nums, m+1, r);
        for(int i = l; i <= r; i++) temp[i] = nums[i];
        int i = l,j = m +1,p = l;
        while(i <= m && j <= r){
            if(temp[i] <= temp[j]){
                nums[p++] = temp[i++];
            }else{
                //归并排序左边子数组元素大于右边子数组元素，则左边从当前元素开始的所有元素都大于右边当前元素，都与其构成逆序对
                ans += m -i +1;
                nums[p++] = temp[j++];
            }
        }
        while(i <= m){
            nums[p++] = temp[i++];
        }
        while(j <= r){
            nums[p++] = temp[j++];
        }
    }
}
```

#### 74、[14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3){
            return n -1;
        }
        int k = n %3;
        int t = n /3;
        long res = 1;
        //只能少乘一次，最后一次根余数一起算
        //否则需要除以3，当取余后对三作除法，得到的值和没有乘3取余前是不一样的！
        for(int i = 1; i < t; i++){
            res *= 3;
            res %= 1000000007;
        }
        res *= k == 0 ? 3 : k == 1 ? 4 : 6;
        return (int)(res %1000000007);
    }
}
```

#### 75、[43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int countDigitOne(int n) {
        //当前位的数字
        int cur = n %10;
        //当前位之前的数字
        int high = n /10;
        //当前位之后的数字
        int low = 0;
        //当前位的权重
        int digit = 1;
        //统计每一位是1的时候会有多少种情况，累加
        int res = 0;
        while(low != n){
            //当前位之前的数字个数 -1，乘以当前位置之后的所有数字个数，就是至少有的组合
            res += high *digit;
            if(cur == 1){
                //当前位置是1，之前的还能多一种组合，但是后面不能拿满了，只能是多少就拿到多少
                res += low +1;
            }else if(cur > 1){
                //当前位置比1大，之后的数字个数可以拿满
                res += digit;
            }
            digit *= 10;
            cur = high %10;
            low = n %digit;
            high = n /digit;
            high /= 10;
        }
        return res;
    }
}
```

#### 76、[44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/description/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4che3pm)

```java
class Solution {
    public int findNthDigit(int n) {
        int digit = 1;
        long start = 1;
        long count = 9;
        while (n > count) { // 1.
            n -= count;
            digit += 1;
            start *= 10;
            count = digit * start * 9;
        }
        long num = start + (n - 1) / digit; // 2.
        return Long.toString(num).charAt((n - 1) % digit) - '0'; // 3.
    }
}
```

#### 77、[001. 整数除法](https://leetcode.cn/problems/xoh6Oh/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    private int max = Integer.MAX_VALUE;
    private int min = Integer.MIN_VALUE;
    public int divide(int a, int b) {
        if(a == 0)  return 0;
        //处理溢出
        if(a == min && b == -1) return max;
        //确定符号
        boolean sign = true;
        if((a < 0 && b > 0) || (a > 0 && b < 0))    sign = false;
        //变成负数计算
        if(a > 0) a = -a;
        if(b > 0) b = -b;
        return sign ? help(a,b) : -help(a,b);
    }
    public int help(int a, int b){
        //出口
        if(a > b)   return 0;
        if(a == b)  return 1;
        int res = 1;
        int cur = b;
        //快速幂
        while(cur > a -cur){
            cur += cur;
            res += res;
        }
        return res +help(a -cur, b);
    }
}
```

#### 78、[002. 二进制加法](https://leetcode.cn/problems/JFETK5/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public String addBinary(String a, String b) {
        //字符数组
        char[] s = a.toCharArray();
        char[] t = b.toCharArray();
        //长度
        int m = s.length;
        int n = t.length;
        //进位
        int in = 0;
        //遍历指针
        int i = m -1;
        int j = n -1;
        //结果
        StringBuilder sb = new StringBuilder();
        //当前位相加的和
        int sum = 0;
        //逐位相加
        while(i >= 0 && j >= 0){
            sum = (s[i--] -'0') +(t[j--] -'0') +in;
            in = sum /2;
            sb.append(sum %2);
        }
        //单位相加
        while(i >= 0){
            sum = (s[i--] -'0') +in;
            in = sum /2;
            sb.append(sum %2);
        }
        //单位相加
        while(j >= 0){
            sum = (t[j--] -'0') +in;
            in = sum /2;
            sb.append(sum %2);
        }
        //处理进位
        if(in > 0)  sb.append(in);
        return sb.reverse().toString();
    }
}
```

#### 79、[003. 前 n 个数字二进制中 1 的个数](https://leetcode.cn/problems/w3tCBm/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n +1];
        double base = Math.log(2);
        for(int i = 1; i <= n; i++){
            //与前一个数异或，得到最后边不相同的位数，结果都是111..的形式,最高位的1是i的，其余是i -1的，计算差值即可
            res[i] = res[i -1] +1 - (int)(Math.log(i^(i -1))/base);
        }
        return res;
    }
}
```

#### 80、[004. 只出现一次的数字](https://leetcode.cn/problems/WGki4K/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int one = 0;
        int two = 0;
        for(int in : nums){
            one = (in^one)&(~two);
            two = (in^two)&(~one);
        }
        return one;
    }
}
```

#### 81、[005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int maxProduct(String[] words) {
        //掩码数组
        int[] keys = new int[1000];
        //对于的长度数组
        int[] values = new int[1000];
        int p = 0;
        //为每一个字符串计算掩码
        for(String s : words){
            int value = 0;
            //从低到高用一个二进制位代表一个字母
            for(int c : s.toCharArray()){
                value |= (1 << (c -'a'));
            }
            keys[p] = value;
            values[p++] = s.length();
        }
        int max = 0;
        //比较所有字符串的掩码
        for(int i = 0; i < p; i++){
            for(int j = 0; j < i; j++){
                //相与为0，说明没有一个二进制位都是1的，即没有相同字母
                if((keys[i]&keys[j]) == 0){
                    max = Math.max(max, values[i]*values[j]);
                }
            }
        }
        return max;
    }
}
```

#### 82、[006. 排序数组中两个数字之和](https://leetcode.cn/problems/kLl5u1/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length -1, sum;
        while(l < r){
            sum = numbers[l] + numbers[r];
            if(sum < target){
                l++;
            }else if(sum > target){
                r--;
            }else{
                return new int[]{l, r};
            }
        }
        return null;
    }
}
```

#### 83、[II 007. 数组中和为 0 的三个数](https://leetcode.cn/problems/1fGaJU/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int l = 0, r = 0, sum = 0;
        for(int i = 0; i < n -2; i++){
            if(nums[i] > 0)   break;
            if(i > 0 && nums[i] == nums[i -1])  continue;
            l = i +1; r = n -1;
            while(l < r){
                sum = nums[l] + nums[r] + nums[i];
                if(sum > 0){
                    r--;
                }else if(sum < 0){
                    l++;
                }else{
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]); list.add(nums[l]); list.add(nums[r]);
                    res.add(list);
                    while(l < r && nums[l] == nums[l +1])   l++;
                    while(l < r && nums[r] == nums[r -1])   r--;
                    l++; r--;
                }
            }
        }
        return res;
    }
}
```

#### 84、[008. 和大于等于 target 的最短子数组](https://leetcode.cn/problems/2VG8Kg/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int l = 0, r = 0, winValue = 0, n = nums.length, min = Integer.MAX_VALUE;
        while(r < n){
            //窗口右更新
            while(r < n && winValue < target)   winValue += nums[r++];
            if(winValue >= target){
                //窗口左更新
                while(l < r && winValue >= target) winValue -= nums[l++];
                //窗口记录
                min = Math.min(min, r -l +1);
            }
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}
```

#### 85、[009. 乘积小于 K 的子数组](https://leetcode.cn/problems/ZVAVXX/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int n = nums.length, l = 0, r = 0, winValue = 1, res = 0;
        while(r < n){
            //右窗口更新
            winValue *= nums[r++];
            //左窗口更新
            while(l < r && winValue >= k)   winValue /= nums[l++];
            res += r -l;
        }
        return res;
    }
}
```

#### 86、[010. 和为 k 的子数组](https://leetcode.cn/problems/QTMn0o/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        //前缀和
        int res = 0, n = nums.length, preSum = 0;
        //从下标0到某个位置的前缀和的数值为key,这个数值出现的次数为value
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for(int i = 0; i < n; i++){
            //更新前缀和
            preSum += nums[i];
            //计算匹配的个数
            res += map.getOrDefault(preSum -k,0);
            //更新前缀和哈希表
            map.put(preSum, map.getOrDefault(preSum,0) +1);
        }
        return res;
    }
}
```

#### 88、[011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int n = nums.length;
        int pre = n, res = 0;
        //从0到某个位置的01分值为key,这个位置下标为value
        int[] map = new int[2*n +2];
        //初始化表示不存在
        Arrays.fill(map, -2);
        map[pre] = -1;
        for(int i = 0; i < n; i++){
            //计算从0开始，以当前结尾的分值
            pre += nums[i] == 0 ? 1 : -1;
            //如果之前没有出现过这个分，说明不存在能够平衡的区间
            if(map[pre] == -2)   map[pre] = i;
            //如果之前存在这个分值，说明在之前那个分的下标到当前下标，01平衡
            else    res = Math.max(res, i -map[pre]);
        }
        return res;
    }
}
```

#### 89、[012. 左右两边子数组的和相等](https://leetcode.cn/problems/tvdfij/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int n = nums.length;
        //前缀和
        int[] lsum = new int[n +2];
        for(int i = 1; i <= n; i++)  lsum[i] +=lsum[i -1] + nums[i -1];
        //从左往右第一个前缀和等于后缀和的元素
        for(int i = 0; i < n; i++)  if(lsum[i +1] == lsum[n] -lsum[i])  return i;
        return -1;
    }
}
```

#### 90、[013. 二维子矩阵的和](https://leetcode.cn/problems/O4NDxx/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class NumMatrix {
    private int[][] dp;
    public NumMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        dp = new int[m +1][n +1];
        //以原点为左上角，计算所有区域
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                dp[i][j] = dp[i -1][j] + dp[i][j -1] -dp[i -1][j -1] 
                            +matrix[i -1][j -1];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        row2++; col2++;
        return dp[row2][col2] -dp[row1][col2] -dp[row2][col1] +dp[row1][col1];
    }
}
```

#### 91、[014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        //字符数组转化
        char[] t = s1.toCharArray();
        char[] s = s2.toCharArray();
        //长度，游标
        int m = s1.length(), n = s2.length(), l = 0, r = 0;
        //窗口，目标
        int[] winValue = new int[26], k = new int[26];
        //初始化目标
        for(char c  : t)    k[c -'a']++;
        while(r < n){
            //更新右窗口使窗口包含目标
            while(r < n && !contain(winValue, k)) winValue[s[r++] -'a']++;
            //更新左窗口使目标和窗口长度相等
            while(l < r -m)  winValue[s[l++] -'a']--;
            //检查是否还包含
            if(contain(winValue, k))    return true;
        }
        return false;
    }
    public boolean contain(int[] a, int[] b){
        for(int i = 0; i < 26; i++) if(a[i] < b[i])    return false;
        return true;
    }
}
```

#### 92、[015. 字符串中的所有变位词](https://leetcode.cn/problems/VabMRr/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        //字符数组转化
        char[] pp = p.toCharArray();
        char[] ss = s.toCharArray();
        List<Integer> res = new ArrayList<>();
        //长度，游标
        int m = p.length(), n = s.length(), l = 0, r = 0;
        //窗口，目标
        int[] winValue = new int[26], k = new int[26];
        //初始化目标
        for(char c  : pp)    k[c -'a']++;
        while(r < n){
            //更新右窗口使窗口包含目标
            while(r < n && !contain(winValue, k)) winValue[ss[r++] -'a']++;
            //更新左窗口使目标和窗口长度相等
            while(l < r -m)  winValue[ss[l++] -'a']--;
            //检查是否还包含
            if(contain(winValue, k))    res.add(l);
            winValue[ss[l++] -'a']--;
        }
        return res;
    }
    public boolean contain(int[] a, int[] b){
        for(int i = 0; i < 26; i++) if(a[i] < b[i])    return false;
        return true;
    }
}
```

#### 93、[016. 不含重复字符的最长子字符串](https://leetcode.cn/problems/wtcaE1/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6&languageTags=java)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        //窗口，数组模拟哈希表，表示128个acsll字符
        boolean[] win = new boolean[128];
        //字符数组
        char[] ss = s.toCharArray();
        //最大长度，左右指针，数组长度
        int max = 0, l = 0, r = 0, n = ss.length;
        while(r < n){
            //更新右指针，能装多大装多大
            while(r < n && !win[ss[r]]) win[ss[r++]] = true;
            //更新最长
            max = Math.max(max, r -l);
            //更新左指针，直到右指针能放进窗口为止
            if(r < n)   while(win[ss[r]])  win[ss[l++]] = false;
        }
        return max;
    }
}
```

#### 94、[018. 有效的回文](https://leetcode.cn/problems/XltzEq/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public boolean isPalindrome(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        int l = 0, r = n -1, d = 'A' -'a';
        while(l < r){
            //过滤无关字符
            while(l < r && !check(ss[l]))    l++;
            while(l < r && !check(ss[r]))    r--;
            //无需比较
            if(l >= r)  return true;
            //数字的失败比较
            if(ss[l] >= '0' && ss[l] <= '9' && ss[l] != ss[r]){
                return false;
            }
            //回文成功，下一次循环
            else if(ss[l] == ss[r] || ss[l] +d == ss[r] || ss[l] == ss[r] +d){
                l++;
                r--;
                continue;
            }
            //回文失败
            return false;
        }
        return true;
    }
    //是否需要比较
    public boolean check(char c){
        if(c >= '0' && c <= '9')    return true;
        if(c >= 'a' && c <= 'z')    return true;
        if(c >= 'A' && c <= 'Z')    return true;
        return false;
    }
}
```

#### 95、[019. 最多删除一个字符得到回文](https://leetcode.cn/problems/RQku0D/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public boolean validPalindrome(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        int l = 0, r = n -1;
        boolean flag = false;
        while(l < r){
            if(ss[l++] != ss[r--])  return tryDelete(ss, l, r +1) || tryDelete(ss, l -1, r);
        }
        return true;
    }
    public boolean tryDelete(char[] s, int l, int r){
        while(l < r){
            if(s[l++] != s[r--])    return false;
        }
        return true;
    }
}
```

#### 96、[020. 回文子字符串的个数](https://leetcode.cn/problems/a7VOhD/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public int countSubstrings(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length, res = 0;
        boolean[][] dp = new boolean[n][n];
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(j == i)  dp[i][j] = true;
                else if(j -i == 1 && ss[i] == ss[j])    dp[i][j] = true;
                else if(ss[i] == ss[j])   dp[i][j] = dp[i +1][j -1];  
                if(dp[i][j])    res += 1;
            }
        }
        return res;
    }
}
```

#### 97、[ 017. 含有所有字符的最短字符串](https://leetcode.cn/problems/M1oyTv/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public String minWindow(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int m = ss.length, n = tt.length;
        if(m < n)   return "";
        //最短
        int[] min = new int[]{-1, m +1};
        //目标
        int[] tmap = new int[60];
        for(char c : tt) tmap[c -'A']++;
        //窗口
        int[] map = new int[60];
        int l = 0, r = 0;
        //滑动窗口
        while(r < m){
            //更新右端
            while(r < m && !contain(map, tmap)){
                map[ss[r++] -'A']++;
            }
            if(contain(map, tmap)){
                //更新左窗口
                while(contain(map, tmap)){
                    map[ss[l++] -'A']--;
                }
                //更新最短
                if(min[1] -min[0] > r -l +1){    
                    min[0] = l -1;
                    min[1] = r;
                }
            }
        }
        return min[0] == -1 ? "" : s.substring(min[0], min[1]);
    }
    //当前窗口是否包含全部字符
    public boolean contain(int[] map, int[] tar){
        for(int i = 0; i < 60; i++){
            if(map[i] < tar[i]) return false;
        }
        return true;
    }
}
```

#### 98、[021. 删除链表的倒数第 n 个结点](https://leetcode.cn/problems/SLwz0R/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode nhead = new ListNode();
        nhead.next = head;
        ListNode f = head, l = nhead;
        for(int i = 0; i < n; i++)  f = f.next;
        while(f != null){
            f = f.next;
            l = l.next;
        }
        l.next= l.next.next;
        return nhead.next;
    }
}
```

#### 99、[022. 链表中环的入口节点](https://leetcode.cn/problems/c32eOV/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        //空处理
        if(head == null)    return null;
        //是否成环
        ListNode f = head.next, l = head;
        while(f != null && f.next != null && f != l){
            f = f.next.next;
            l = l.next;
        }
        //不成环
        if(f == null || f.next == null) return null;
        //找第一个交点
        ListNode h1 = head, h2 = f.next, tail = f, c1 = h1, c2 = h2;
        while(c1 != c2){
            if(c1 == tail)  c1 = h2;
            else    c1 = c1.next;
            if(c2 == tail)  c2 = h1;
            else    c2 = c2.next;
        }
        return c1;
    }
}
```

#### 100、[023. 两个链表的第一个重合节点](https://leetcode.cn/problems/3u1WK4/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode c1 = headA, c2 = headB;
        while(c1 != c2){
            if(c1 == null)  c1 = headB;
            else    c1 = c1.next;
            if(c2 == null)  c2 = headA;
            else    c2 = c2.next;
        }
        return c1;
    }
}
```

#### 101、[024. 反转链表](https://leetcode.cn/problems/UHnkqh/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null, cur = head, next = null;
        while(cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

#### 102、[025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //结点栈
        int[] st1 = new int[100];
        int[] st2 = new int[100];
        int t1 = -1, t2 = -1;
        //将链表入栈
        ListNode cur = l1;
        while(cur != null)  {st1[++t1] = cur.val;   cur = cur.next;}
        cur = l2;
        while(cur != null)  {st2[++t2] = cur.val;   cur = cur.next;}
        //计算同位相加之和
        int sum = 0, in = 0;
        while(t1 != -1 && t2 != -1){
            sum = st1[t1--] + st2[t2--] + in;
            in = sum /10;
            sum %= 10;
            ListNode node = new ListNode(sum);
            node.next = cur;
            cur = node;
        }
        //计算只有一边的和
        while(t1 != -1){
            sum = st1[t1--] + in;
            in = sum /10;
            sum %= 10;
            ListNode node = new ListNode(sum);
            node.next = cur;
            cur = node;
        }
        while(t2 != -1){
            sum = st2[t2--] + in;
            in = sum /10;
            sum %= 10;
            ListNode node = new ListNode(sum);
            node.next = cur;
            cur = node;
        }
        //处理进位
        if(in != 0){
            ListNode node = new ListNode(in);
            node.next = cur;
            cur = node;
        }
        return cur;
    }
}
```

#### 103、[026. 重排链表](https://leetcode.cn/problems/LGjMqU/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public void reorderList(ListNode head) {
        //对半分
        ListNode f = head.next, l = head;
        while(f != null && f.next != null){
            f = f.next.next;
            l = l.next;
        }
        //链表尾处理，后半段翻转
        ListNode pre = null, cur = l.next, next = null;
        l.next = null;
        while(cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        //将后半段逐个写入前半段
        ListNode a = head, b = pre, anext = null, bnext = null;
        while(b != null){
            anext = a.next;
            bnext = b.next;
            a.next = b;
            b.next = anext;
            a = anext;
            b = bnext;
        }
    }
}
```

#### 104、[027. 回文链表](https://leetcode.cn/problems/aMhZSa/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        //对半分
        ListNode f = head.next, l = head;
        while(f != null && f.next != null){
            f = f.next.next;
            l = l.next;
        }
        //后半段翻转
        ListNode pre = null, cur = l.next, next = null;
        while(cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        //逐一比较是否相等
        ListNode a = head, b = pre;
        while(b != null){
            if(a.val != b.val)  return false;
            a = a.next;
            b = b.next;
        }
        return true;
    }
}
```

#### 105、[028. 展平多级双向链表](https://leetcode.cn/problems/Qv1Da2/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public Node flatten(Node head) {
        //空结点不用展开
        if(head == null)    return head;
        //分别展开子结点和后结点
        Node cnext = flatten(head.child);
        Node nnext = flatten(head.next);
        Node cur = head;
        //先接上展开的子节点
        if(cnext != null){
            cur.next = cnext;
            cnext.prev = cur;
            cur.child = null;
            //移动到新链表最后一个结点
            while(cur.next != null)  cur = cur.next;
        }
        //再接上展开的后结点
        if(nnext != null){
            cur.next = nnext;
            nnext.prev = cur;
        }
        return head;
    }
}
```

#### 106、[029. 排序的循环链表](https://leetcode.cn/problems/4ueAj6/description/?envType=study-plan&id=lcof-ii&plan=lcof&plan_progress=1soffs6)

```java
class Solution {
    public Node insert(Node head, int insertVal) {
        //新建结点
        Node node = new Node(insertVal);
        //空链表
        if(head == null){
            node.next = node;
            return node;
        }
        //找链表起始和中止位置（最大、最小）
        Node f = head;
        while(f.next.val >= f.val && f.next != head)   f = f.next;
        //全是相等的结点
        if(f.next.val == f.val && f.next == head){
            f.next = node;
            node.next = head;
            return head;
        }
        Node tail = f, h = f.next;
        //插入值在链表两端
        if(insertVal <= h.val || insertVal >= tail.val){
            tail.next = node;
            node.next = h;
            return head;
        }
        //寻找插入点
        f = h;
        while(f.next.val <= insertVal)    f = f.next;
        //插入结点
        node.next = f.next;
        f.next = node;
        return head;
    }
}
```

#### 107、[]()

```java

```

#### 108、[]()

```java

```

#### 109、[]()

```java

```

#### 110、[]()

```java

```

#### 111、[]()

```java

```

#### 112、[]()

```java

```

#### 113、[]()

```java

```

#### 114、[]()

```java

```

#### 115、[]()

```java

```

#### 116、[]()

```java

```

