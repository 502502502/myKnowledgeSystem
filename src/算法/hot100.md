#### 1、[85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

单调栈

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] h = new int[n +2];
        Arrays.fill(h,0);
        int max = 0;
        //以每一行为底边的最大矩形
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                h[j+1] = matrix[i][j] == '0' ? 0 : h[j+1] +1;
            }
            max = Math.max(max, find(h));
        }
        return max;
    }
    //最大矩形
    public int find(int[] nums){
        int n = nums.length;
        int[] st = new int[n];
        int top = -1;
        int max = 0;
        for(int i = 0; i < n; i++){
            while(top >= 0 && nums[st[top]] > nums[i]){
                int r = i -1;
                int l = top == 0 ? st[top] : st[top -1] +1;
                int h = nums[st[top--]];
                max = Math.max(max, h*(r -l +1));
            }
            st[++top] = i;
        }
        return max;
    }
}
```

#### 2、[最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)

递归

```java
class Solution {
    //全局最大路径和
    private int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        help(root);
        return max;
    }
    public int help(TreeNode root){
        if(root == null)    return 0;
        //经过左儿子的最大和
        int l = help(root.left);
        //经过右儿子的最大和
        int r = help(root.right);
        //经过当前结点且直走一边的最大和
        int cur = Math.max(r +root.val,
                            Math.max(root.val, l +root.val));
        //两边都走的和可能更大，但是上层结点不能同时走两边，因此不返回，直接取最大
        max = Math.max(max, Math.max(cur,l +r+root.val));
        return cur;
    }
}
```



#### 3、[LRU算法模拟](https://leetcode.cn/problems/lru-cache/description/?languageTags=java)

lru算法

```java
class LRUCache {

    private class Node{
        public int key;
        public int val;
        public Node next;
        public Node pre;
        public Node(){
            val = 0;
            next = null;
            pre = null;
        }
        public Node(int k, int v){
            key = k;
            val = v;
            next = null;
            pre = null;
        }
    }
    private Map<Integer,Node> map = new HashMap<>();
    private int cap;

    private Node head = new Node();
    private Node tail = new Node();

    public LRUCache(int capacity) {
        cap = capacity;
        this.head.next = tail;
        this.tail.pre = head;
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if(node == null){
            return -1;
        }
        //原位置删除
        delete(node);
        //头部添加
        addHead(node);
        return  node.val;
    }
    //原位置删除
    public void delete(Node node){
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
    }
    //头部插入
    public void addHead(Node node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    //添加结点
    public void put(int key, int value) {
        //已经存在结点
        if(map.containsKey(key)){
            Node node = map.get(key);
            node.val = value;
            //原位置删除
            delete(node);
            //头部添加
            addHead(node);
        }else{
            //新结点
            Node node = new Node(key, value);
            map.put(key, node);
            //插入头部
            addHead(node);
            //超出容量
            if(map.size() > cap){
                map.remove(tail.pre.key);
                delete(tail.pre);
            }
        }
    }
}
```



#### 4、[前缀树](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)

前缀树

```java
class Trie {
    private class Node{
        public boolean end = false;
        public Node[] next = new Node[26];
    }
    private Node root = new Node();

    public Trie() {}
    
    public void insert(String word) {
        Node cur = root;
        for(char c : word.toCharArray()){
            if(cur.next[c -'a'] == null)     cur.next[c -'a'] = new Node();
            cur = cur.next[c -'a'];
        }
        cur.end = true;
    }
    
    public boolean search(String word) {
        Node cur = root;
        for(char c : word.toCharArray()){
            cur = cur.next[c-'a'];
            if(cur == null)    return false;
        }
        return cur.end;
    }
    
    public boolean startsWith(String prefix) {
        Node cur = root;
        for(char c : prefix.toCharArray()){
            cur = cur.next[c-'a'];
            if(cur == null)    return false;
        }
        return true;
    }
}
```



#### 5、[数字重复](https://leetcode.cn/problems/find-the-duplicate-number/description/)

链表成环

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int fast = nums[nums[0]];
        int slow = nums[0];
        int n = nums.length;
        //将数组看成链表，next下表为nums[i]的值
        //会有两个位置的next相等，即成环
        while(fast != slow){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        //从相遇点y走到环起点x与从起始点0到环起x点的距离相等
        //证明：
        //slow: 0-x-y;  fast:0-x-y-x-y
        //2*slow = fast: 0-x = y-x
        int pre1 = 0;
        int pre2 = slow;
        while(pre1 != pre2){
            pre1 = nums[pre1];
            pre2 = nums[pre2];
        }
        return pre1;
    }
}
```



#### 6、[删除无效括号](https://leetcode.cn/problems/remove-invalid-parentheses/description/)

回溯剪枝

```java
class Solution {
    private Set<String> set = new HashSet();
    private int maxlen = 0;
    private int maxnum = 0;
    private char[] s;
    public List<String> removeInvalidParentheses(String s) {
        int l = 0, r = 0;
        this.s = s.toCharArray();
        for(char c : this.s){
            if(c == '(')    l++;
            if(c == ')')    r++;
        }
        maxnum = Math.min(l,r);
        dfs(0,"",0);
        List<String> res = new ArrayList<>();
        for(String str : set){
            res.add(str);
        }
        return res;
    }
    public void dfs(int score, String cur, int index){
        //遍历完成
        if(index == s.length){
            //不是合法的
            if(score != 0)  return;
            //是最长的
            if(cur.length() > maxlen){
                set.clear();
                set.add(cur);
                maxlen = cur.length();
            }
            //和最长一样长
            else if(cur.length() == maxlen){
                set.add(cur);
            }
            return;
        }
        //再继续下去也不会成功闭合
        if(s.length -index < score) return;
        //再继续下去也不会比达到历史最长
        if(s.length -index < maxlen -cur.length())  return;
        //已经不合法了
        if(score < 0)   return;

        //枚举当前字符类型
        if(s[index] == '('){
            //未闭合的左括号小于理论最值，不删除
            if(score +1 <= maxnum){
                dfs(score +1, cur +'(',index+1);
            }
            //删除
            dfs(score,cur,index+1);
        }else if(s[index] == ')'){
            //还有左括号匹配，不删除
            if(score > 0){
                dfs(score -1,cur+')',index+1);
            }
            dfs(score,cur,index+1);
        }else{
            dfs(score,cur+s[index], index+1);
        }
    }
}
```



#### 7、[戳爆气球](https://leetcode.cn/problems/burst-balloons/description/)

动态规划

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n +2][n +2];
        int[] nu = new int[n +2];
        for(int i = 1; i <= n; i++) nu[i] = nums[i -1];
        nu[0] = 1;
        nu[n+1] = 1;
        for(int i = n+1; i >= 0; i--){
            for(int j = i+1; j <= n+1; j++){
                for(int k = i +1; k < j; k++){
                    dp[i][j] = Math.max(dp[i][j],dp[i][k]+dp[k][j]+nu[k]*nu[i]*nu[j]);
                }
            }
        }
        return dp[0][n +1];
    }
}
```



#### 8、[字符串解码](https://leetcode.cn/problems/decode-string/description/)

栈

```java
class Solution {
    public String decodeString(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        int[] stnum = new int[n];
        int tn = -1;
        String[] sts = new String[n];
        int ts = -1;
        int i = 0;
        String res = "";
        int k = 0;
        while(i < n){
            if(ss[i] == ']'){
                int p = stnum[tn--];
                String cur = sts[ts--];
                while(p-- > 0){
                    cur += res;
                }
                res = cur;
            }else if(ss[i] == '['){
                stnum[++tn] = k;
                sts[++ts] = res;
                res = "";
                k = 0;
            }else if(ss[i] >= '0' && ss[i] <= '9'){
                k *= 10;
                k += ss[i] -'0';
            }else{
                res += ss[i];
            }
            i++;
        }
        return res;
    }
}
```



#### 9、[除法求值](https://leetcode.cn/problems/evaluate-division/description/)

查并集

```java
class Solution {
    private double[] w;
    private int[] p;
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int n = equations.size();
        //权值
        w = new double[2*n];
        //父节点
        p = new int[2*n];
        //初始化
        for(int i = 0; i < 2*n; i++){
            p[i] = i;
            w[i] = 1d;
        }
        //映射为int
        Map<String, Integer> map = new HashMap<>();
        int id = 0;
        int i = 0;
        for(List<String> li : equations){
            if(!map.containsKey(li.get(0))){
                map.put(li.get(0), id++);
            }
            if(!map.containsKey(li.get(1))){
                map.put(li.get(1), id++);
            }
            //合并
            union(map.get(li.get(0)), map.get(li.get(1)), values[i++]);
        }
        int m = queries.size();
        i = 0;
        double[] res = new double[m];
        //计算
        for(List<String> li : queries){
            Integer x = map.get(li.get(0));
            Integer y = map.get(li.get(1));
            //不存在的变量
            if(x == null || y == null){
                res[i] = -1d;
            }else{
                //不在一个集合的变量
                if(find(x) != find(y)){
                    res[i] = -1d;
                }
                //在一个集合，利用公共变量计算
                else{
                    res[i] = w[x]/w[y];
                }
            }
            i++;
        }
        return res;
    }
    //将两个变量合并
    public void union(int x, int y, double value){
        int rx = find(x);
        int ry = find(y);
        if(rx == ry)    return;
        p[rx] = ry;
        w[rx] = value*w[y]/w[x];
    }
    //查找公共变量
    public int find(int x){
        if(p[x] == x)    return x;
        int k = p[x];
        //路径压缩
        p[x] = find(k);
        w[x] *= w[k];
        return p[x];
    }
}
```



#### 10、[消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/)

原地哈希

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        //每个索引都应该有值对应，将有值对应的索引的值增加，第二次遍历值没有增加的就是没有值对应的索引。
        for(int v : nums){
            if(v > n){
                nums[(v%(n+1)) -1] += n +1;
            }else{
                nums[v -1] += n +1;
            }
        }
        List<Integer> res = new ArrayList<>();
        for(int i = 0; i < n; i++){
            if(nums[i] <= n){
                res.add(i +1);
            }
        }
        return res;
    }
}
```



#### 11、[路径总和](https://leetcode.cn/problems/path-sum-iii/description/)



```java
class Solution {
    private int res = 0;
    private int target;
    private TreeNode root;
    public int pathSum(TreeNode root, int targetSum) {
        target =targetSum;
        this.root = root;
        post(root);
        return res;
    }
    public void post(TreeNode r){
        if(r == null)   return;
        post(r.left);
        post(r.right);
        help(r, 0);
    }
    public void help(TreeNode r, long sum){
        if(r == null)   return;
        sum += r.val;
        if(sum == target) res++;
        help(r.left, sum);
        help(r.right, sum);
    }
}
```



#### 12、[二分图](https://leetcode.cn/problems/vEAB3K/description/)



```java
class Solution {
    public int[] color;
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color = new int[n];
        Arrays.fill(color, -1);
        //对每一个独立的集合进行染色
        for(int i = 0; i < n; i++){
            if(color[i] == -1){
                if(!dfs(graph, i, 0)){
                    return false;
                }
            }
        }
        return true;
    }
    //将结点及其关联的结点都进行染色
    public boolean dfs(int[][] graph, int cur, int co){
        if(color[cur] != -1)    return color[cur] == co;
        color[cur] = co;
        for(int v : graph[cur]){
            if(!dfs(graph, v, 1 -co)){
                return false;
            }
        }
        return true;
    }
}
```



#### 13、[重排文本](https://leetcode.cn/problems/text-justification/description/)



```java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        int n = words.length;
        List<String> res = new ArrayList<>();
        for(int i = 0; i < n;){
            //单行单词数量
            List<String> li = new ArrayList<>();
            int len = 0;
            while(i < n && len +words[i].length() <= maxWidth){
                len += words[i].length() +1;
                li.add(words[i++]);
            }
            StringBuilder sb = new StringBuilder();
            //最后一行
            if(i == n){
                for(String s : li){
                    sb.append(s);
                    sb.append(' ');
                }
                if(len > maxWidth)  sb.deleteCharAt(sb.length() -1);
                while(sb.length() < maxWidth)   sb.append(' ');
            }
            //一行一个单词
            else if(li.size() == 1){
                sb.append(li.get(0));
                while(sb.length() < maxWidth)   sb.append(' ');
            }
            //一行多个单词
            else{
                int size = li.size();
                int wlen = len -(size);
                int slen = maxWidth -wlen;
                int d = slen/(size -1);
                int ex = slen -d*(size -1);
                for(int k = 0; k < size -1; k++){
                    sb.append(li.get(k));
                    for(int j = 0; j < d; j++){
                        sb.append(' ');
                    }
                    if(ex-- > 0)    sb.append(' ');
                }
                sb.append(li.get(size -1));
            }
            res.add(sb.toString());
        }
        return res;
    }
}
```



#### 14、[数字容器](https://leetcode.cn/problems/design-a-number-container-system/description/)

```java
class NumberContainers {
    private Map<Integer, Integer> nums;
    private Map<Integer, TreeSet<Integer>> pos;

    public NumberContainers() {
        nums = new HashMap<Integer, Integer>();
        pos = new HashMap<Integer, TreeSet<Integer>>();
    }
    
    public void change(int index, int number) {
        //已经存在
        if(nums.containsKey(index)){
            //移除原来的映射
            pos.get(nums.get(index)).remove(index);
            if(pos.get(nums.get(index)).isEmpty())  pos.remove(nums.get(index));
        }
        //新增值到下标的映射
        if(pos.containsKey(number)){
            pos.get(number).add(index);
        }else{
            TreeSet<Integer> set = new TreeSet<>();
            set.add(index);
            pos.put(number, set);
        }
        nums.put(index, number);
    }
    
    public int find(int number) {
        if(!pos.containsKey(number))    return -1;
        return pos.get(number).first();
    }
}
```



#### 15、[字串最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)

```java
class Solution {
    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        //窗口内字母数量
        Map<Character, Integer> map = new HashMap<>();
        //字串出现次数
        Map<String, Integer> cou = new HashMap<>();
        //初始化
        for(int i = 0; i < minSize -1; i++){
            map.put(ss[i], map.getOrDefault(ss[i], 0) +1);
        }
        for(int i = minSize -1; i < n; i++){
            //更新右端点
            map.put(ss[i], map.getOrDefault(ss[i], 0) +1);
            //符合条件
            if(map.size() <= maxLetters){
                String key = s.substring(i -minSize +1, i +1);
                key.intern();
                cou.put(key, cou.getOrDefault(key, 0) +1);
            }
            //更新左端点
            int c = map.get(ss[i -minSize +1]);
            map.put(ss[i -minSize +1], c -1);
            if(c-1 == 0){
                map.remove(ss[i -minSize +1]);
            }
        }
        //最大次数
        int max = 0;
        for(Map.Entry<String, Integer> entry : cou.entrySet()){
            max = Math.max(max, entry.getValue());
        }
        return max;
    }
}
```



#### 16、[丑数](https://leetcode.cn/problems/ugly-number/description/)

```java
class Solution {
    public boolean isUgly(int n) {
        if(n <= 0)  return false;
        while(n%2 == 0) n /= 2;
        while(n%3 == 0) n /= 3;
        while(n%5 == 0) n /= 5;
        return n == 1;
    }
}
```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```



#### 14、

```java

```

