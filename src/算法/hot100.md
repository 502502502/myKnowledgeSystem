#### 1、[85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

单调栈

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] h = new int[n +2];
        Arrays.fill(h,0);
        int max = 0;
        //以每一行为底边的最大矩形
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                h[j+1] = matrix[i][j] == '0' ? 0 : h[j+1] +1;
            }
            max = Math.max(max, find(h));
        }
        return max;
    }
    //最大矩形
    public int find(int[] nums){
        int n = nums.length;
        int[] st = new int[n];
        int top = -1;
        int max = 0;
        for(int i = 0; i < n; i++){
            while(top >= 0 && nums[st[top]] > nums[i]){
                int r = i -1;
                int l = top == 0 ? st[top] : st[top -1] +1;
                int h = nums[st[top--]];
                max = Math.max(max, h*(r -l +1));
            }
            st[++top] = i;
        }
        return max;
    }
}
```

#### 2、[最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)

递归

```java
class Solution {
    //全局最大路径和
    private int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        help(root);
        return max;
    }
    public int help(TreeNode root){
        if(root == null)    return 0;
        //经过左儿子的最大和
        int l = help(root.left);
        //经过右儿子的最大和
        int r = help(root.right);
        //经过当前结点且直走一边的最大和
        int cur = Math.max(r +root.val,
                            Math.max(root.val, l +root.val));
        //两边都走的和可能更大，但是上层结点不能同时走两边，因此不返回，直接取最大
        max = Math.max(max, Math.max(cur,l +r+root.val));
        return cur;
    }
}
```



#### 3、[LRU算法模拟](https://leetcode.cn/problems/lru-cache/description/?languageTags=java)

lru算法

```java
class LRUCache {

    private class Node{
        public int key;
        public int val;
        public Node next;
        public Node pre;
        public Node(){
            val = 0;
            next = null;
            pre = null;
        }
        public Node(int k, int v){
            key = k;
            val = v;
            next = null;
            pre = null;
        }
    }
    private Map<Integer,Node> map = new HashMap<>();
    private int cap;

    private Node head = new Node();
    private Node tail = new Node();

    public LRUCache(int capacity) {
        cap = capacity;
        this.head.next = tail;
        this.tail.pre = head;
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if(node == null){
            return -1;
        }
        //原位置删除
        delete(node);
        //头部添加
        addHead(node);
        return  node.val;
    }
    //原位置删除
    public void delete(Node node){
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
    }
    //头部插入
    public void addHead(Node node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    //添加结点
    public void put(int key, int value) {
        //已经存在结点
        if(map.containsKey(key)){
            Node node = map.get(key);
            node.val = value;
            //原位置删除
            delete(node);
            //头部添加
            addHead(node);
        }else{
            //新结点
            Node node = new Node(key, value);
            map.put(key, node);
            //插入头部
            addHead(node);
            //超出容量
            if(map.size() > cap){
                map.remove(tail.pre.key);
                delete(tail.pre);
            }
        }
    }
}
```



#### 4、[前缀树](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)

前缀树

```java
class Trie {
    private class Node{
        public boolean end = false;
        public Node[] next = new Node[26];
    }
    private Node root = new Node();

    public Trie() {}
    
    public void insert(String word) {
        Node cur = root;
        for(char c : word.toCharArray()){
            if(cur.next[c -'a'] == null)     cur.next[c -'a'] = new Node();
            cur = cur.next[c -'a'];
        }
        cur.end = true;
    }
    
    public boolean search(String word) {
        Node cur = root;
        for(char c : word.toCharArray()){
            cur = cur.next[c-'a'];
            if(cur == null)    return false;
        }
        return cur.end;
    }
    
    public boolean startsWith(String prefix) {
        Node cur = root;
        for(char c : prefix.toCharArray()){
            cur = cur.next[c-'a'];
            if(cur == null)    return false;
        }
        return true;
    }
}
```



#### 5、[数字重复](https://leetcode.cn/problems/find-the-duplicate-number/description/)

链表成环

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int fast = nums[nums[0]];
        int slow = nums[0];
        int n = nums.length;
        //将数组看成链表，next下表为nums[i]的值
        //会有两个位置的next相等，即成环
        while(fast != slow){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        //从相遇点y走到环起点x与从起始点0到环起x点的距离相等
        //证明：
        //slow: 0-x-y;  fast:0-x-y-x-y
        //2*slow = fast: 0-x = y-x
        int pre1 = 0;
        int pre2 = slow;
        while(pre1 != pre2){
            pre1 = nums[pre1];
            pre2 = nums[pre2];
        }
        return pre1;
    }
}
```



#### 6、[删除无效括号](https://leetcode.cn/problems/remove-invalid-parentheses/description/)

回溯剪枝

```java
class Solution {
    private Set<String> set = new HashSet();
    private int maxlen = 0;
    private int maxnum = 0;
    private char[] s;
    public List<String> removeInvalidParentheses(String s) {
        int l = 0, r = 0;
        this.s = s.toCharArray();
        for(char c : this.s){
            if(c == '(')    l++;
            if(c == ')')    r++;
        }
        maxnum = Math.min(l,r);
        dfs(0,"",0);
        List<String> res = new ArrayList<>();
        for(String str : set){
            res.add(str);
        }
        return res;
    }
    public void dfs(int score, String cur, int index){
        //遍历完成
        if(index == s.length){
            //不是合法的
            if(score != 0)  return;
            //是最长的
            if(cur.length() > maxlen){
                set.clear();
                set.add(cur);
                maxlen = cur.length();
            }
            //和最长一样长
            else if(cur.length() == maxlen){
                set.add(cur);
            }
            return;
        }
        //再继续下去也不会成功闭合
        if(s.length -index < score) return;
        //再继续下去也不会比达到历史最长
        if(s.length -index < maxlen -cur.length())  return;
        //已经不合法了
        if(score < 0)   return;

        //枚举当前字符类型
        if(s[index] == '('){
            //未闭合的左括号小于理论最值，不删除
            if(score +1 <= maxnum){
                dfs(score +1, cur +'(',index+1);
            }
            //删除
            dfs(score,cur,index+1);
        }else if(s[index] == ')'){
            //还有左括号匹配，不删除
            if(score > 0){
                dfs(score -1,cur+')',index+1);
            }
            dfs(score,cur,index+1);
        }else{
            dfs(score,cur+s[index], index+1);
        }
    }
}
```



#### 7、[戳爆气球](https://leetcode.cn/problems/burst-balloons/description/)

动态规划

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n +2][n +2];
        int[] nu = new int[n +2];
        for(int i = 1; i <= n; i++) nu[i] = nums[i -1];
        nu[0] = 1;
        nu[n+1] = 1;
        for(int i = n+1; i >= 0; i--){
            for(int j = i+1; j <= n+1; j++){
                for(int k = i +1; k < j; k++){
                    dp[i][j] = Math.max(dp[i][j],dp[i][k]+dp[k][j]+nu[k]*nu[i]*nu[j]);
                }
            }
        }
        return dp[0][n +1];
    }
}
```



#### 8、[字符串解码](https://leetcode.cn/problems/decode-string/description/)

栈

```java
class Solution {
    public String decodeString(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        int[] stnum = new int[n];
        int tn = -1;
        String[] sts = new String[n];
        int ts = -1;
        int i = 0;
        String res = "";
        int k = 0;
        while(i < n){
            if(ss[i] == ']'){
                int p = stnum[tn--];
                String cur = sts[ts--];
                while(p-- > 0){
                    cur += res;
                }
                res = cur;
            }else if(ss[i] == '['){
                stnum[++tn] = k;
                sts[++ts] = res;
                res = "";
                k = 0;
            }else if(ss[i] >= '0' && ss[i] <= '9'){
                k *= 10;
                k += ss[i] -'0';
            }else{
                res += ss[i];
            }
            i++;
        }
        return res;
    }
}
```



#### 9、[除法求值](https://leetcode.cn/problems/evaluate-division/description/)

查并集

```java
class Solution {
    private double[] w;
    private int[] p;
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int n = equations.size();
        //权值
        w = new double[2*n];
        //父节点
        p = new int[2*n];
        //初始化
        for(int i = 0; i < 2*n; i++){
            p[i] = i;
            w[i] = 1d;
        }
        //映射为int
        Map<String, Integer> map = new HashMap<>();
        int id = 0;
        int i = 0;
        for(List<String> li : equations){
            if(!map.containsKey(li.get(0))){
                map.put(li.get(0), id++);
            }
            if(!map.containsKey(li.get(1))){
                map.put(li.get(1), id++);
            }
            //合并
            union(map.get(li.get(0)), map.get(li.get(1)), values[i++]);
        }
        int m = queries.size();
        i = 0;
        double[] res = new double[m];
        //计算
        for(List<String> li : queries){
            Integer x = map.get(li.get(0));
            Integer y = map.get(li.get(1));
            //不存在的变量
            if(x == null || y == null){
                res[i] = -1d;
            }else{
                //不在一个集合的变量
                if(find(x) != find(y)){
                    res[i] = -1d;
                }
                //在一个集合，利用公共变量计算
                else{
                    res[i] = w[x]/w[y];
                }
            }
            i++;
        }
        return res;
    }
    //将两个变量合并
    public void union(int x, int y, double value){
        int rx = find(x);
        int ry = find(y);
        if(rx == ry)    return;
        p[rx] = ry;
        w[rx] = value*w[y]/w[x];
    }
    //查找公共变量
    public int find(int x){
        if(p[x] == x)    return x;
        int k = p[x];
        //路径压缩
        p[x] = find(k);
        w[x] *= w[k];
        return p[x];
    }
}
```



#### 10、



```java

```



#### 11、



```java

```



#### 12、



```java

```



#### 13、



```java

```



#### 