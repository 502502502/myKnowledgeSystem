#### 1、[85.最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] h = new int[n +2];
        Arrays.fill(h,0);
        int max = 0;
        //以每一行为底边的最大矩形
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                h[j+1] = matrix[i][j] == '0' ? 0 : h[j+1] +1;
            }
            max = Math.max(max, find(h));
        }
        return max;
    }
    //最大矩形
    public int find(int[] nums){
        int n = nums.length;
        int[] st = new int[n];
        int top = -1;
        int max = 0;
        for(int i = 0; i < n; i++){
            while(top >= 0 && nums[st[top]] > nums[i]){
                int r = i -1;
                int l = top == 0 ? st[top] : st[top -1] +1;
                int h = nums[st[top--]];
                max = Math.max(max, h*(r -l +1));
            }
            st[++top] = i;
        }
        return max;
    }
}
```

#### 2、[最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)



```java
class Solution {
    //全局最大路径和
    private int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        help(root);
        return max;
    }
    public int help(TreeNode root){
        if(root == null)    return 0;
        //经过左儿子的最大和
        int l = help(root.left);
        //经过右儿子的最大和
        int r = help(root.right);
        //经过当前结点且直走一边的最大和
        int cur = Math.max(r +root.val,
                            Math.max(root.val, l +root.val));
        //两边都走的和可能更大，但是上层结点不能同时走两边，因此不返回，直接取最大
        max = Math.max(max, Math.max(cur,l +r+root.val));
        return cur;
    }
}
```



#### 3、[LRU算法模拟](https://leetcode.cn/problems/lru-cache/description/?languageTags=java)



```java
class LRUCache {

    private class Node{
        public int key;
        public int val;
        public Node next;
        public Node pre;
        public Node(){
            val = 0;
            next = null;
            pre = null;
        }
        public Node(int k, int v){
            key = k;
            val = v;
            next = null;
            pre = null;
        }
    }
    private Map<Integer,Node> map = new HashMap<>();
    private int cap;

    private Node head = new Node();
    private Node tail = new Node();

    public LRUCache(int capacity) {
        cap = capacity;
        this.head.next = tail;
        this.tail.pre = head;
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if(node == null){
            return -1;
        }
        //原位置删除
        delete(node);
        //头部添加
        addHead(node);
        return  node.val;
    }
    //原位置删除
    public void delete(Node node){
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
    }
    //头部插入
    public void addHead(Node node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    //添加结点
    public void put(int key, int value) {
        //已经存在结点
        if(map.containsKey(key)){
            Node node = map.get(key);
            node.val = value;
            //原位置删除
            delete(node);
            //头部添加
            addHead(node);
        }else{
            //新结点
            Node node = new Node(key, value);
            map.put(key, node);
            //插入头部
            addHead(node);
            //超出容量
            if(map.size() > cap){
                map.remove(tail.pre.key);
                delete(tail.pre);
            }
        }
    }
}
```



#### 4、



```java

```



#### 5、



```java

```



#### 6、



```java

```



#### 7、



```java

```



#### 8、



```java

```



#### 9、



```java

```



#### 10、



```java

```



#### 11、



```java

```



#### 12、



```java

```



#### 13、



```java

```



#### 