# 九、动态规划

## 1、斐波那契数列

### ①、[题目链接](https://leetcode.cn/problems/fibonacci-number/)

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

 

示例 1：

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3


提示：

0 <= n <= 30



### ②、思路

动态规划，由前面的状态递推而得

由于递推元素不需要之前所有状态，使用dp变量递推即可



### ③、代码

```java
class Solution {
    public int fib(int n) {
        if(n < 2){
            return n;
        }
        int dp = 1;
        int pre = 0;
        int temp;
        for(int i = 2; i <= n; i++){
            temp = dp;
            dp = dp + pre;
            pre = temp;
        }
        return dp;
    }
}
```



## 2、爬楼梯

### ①、[题目链接](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶


提示：

1 <= n <= 45



### ②、思路

有多少种方法来到前一阶，或者前两阶，就有多少种方法来到当前阶，因为当前台阶只可能是前一阶迈一步，或者前两阶迈两步来到的。

故递推关系式得到；

由于只使用前两个状态，使用变量暂存即可



### ③、代码

```java
class Solution {
    public int climbStairs(int n) {
        int dp = 1;
        int pre = 1;
        int temp;
        for(int i = 2; i <= n; i++){
            temp = dp;
            dp += pre;
            pre = temp;
        }
        return dp;
    }
}
```



## 3、最小花费爬楼梯

### ①、[题目链接](https://leetcode.cn/problems/min-cost-climbing-stairs/)

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。


提示：

2 <= cost.length <= 1000
0 <= cost[i] <= 999



### ②、思路

要么从前一阶来，要么从前两阶来；

来到前一阶的花费和从前一阶出发的花费，来到前两阶的花费加上从前两阶出发的花费

取一个最小的，就是来到当前台阶的最小花费；

故递归关系式得出，

只需要前两个状态，使用变量暂存



### ③、代码

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int dp = 0;
        int pre = 0;
        int temp;
        for(int i = 2; i <= cost.length; i++){
            temp = Math.min(dp +cost[i -1], pre +cost[i -2]);
            pre = dp;
            dp = temp;
        }
        return dp;
    }
}
```



## 4、不同路径

### ①、[题目链接](https://leetcode.cn/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：


输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6


提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 109



### ②、思路

每一个位置只能从上边或者左边来，因此，来到当前位置的路径数量就是来到上边的，加上来到左边的。

避免边界判断，dp数组多加一行一列；



### ③、代码

```java
 public int uniquePaths(int m, int n) {
        int[][] dp = new int[m +1][n +1];
        dp[0][1] = 1;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                dp[i][j] = dp[i -1][j] +dp[i][j -1];
            }
        }
        return dp[m][n];
    }
```



## 5、不同路径Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

 

示例 1：


输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
示例 2：


输入：obstacleGrid = [[0,1],[0,0]]
输出：1


提示：

m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] 为 0 或 1



### ②、思路

如果当前位置有障碍物，来到当前位置的路径就是0；

否则就是上边来的或者左边来的。



### ③、代码

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m +1][n +1];
        dp[0][1] = obstacleGrid[0][0] == 1 ? 0 : 1;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(obstacleGrid[i -1][j -1] != 1){
                    dp[i][j] = dp[i -1][j] +dp[i][j -1];
                }
            }
        }
        return dp[m][n];
    }
}
```

## 6、整数拆分

### ①、[题目链接](https://leetcode.cn/problems/integer-break/)

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

示例 1:

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。


提示:

2 <= n <= 58



### ②、思路

将当前整数 i 的和看成两部分，一部分是从1到 i -1；

另一部分是 i 减去前一部分这个数字本身，或者拆分i 减去前一部分这个数字后得到的最大乘积

两部分数字就是当前数字可能的一个拆分组合

从1 到i -1 遍历，看看那个拆分组合的乘积是最大的即可

### ③、代码

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n +1];
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            int max = 0;
            for(int j = 1; j < i; j++){
                max = Math.max(max, dp[i -j] *j);
                max = Math.max(max, (i -j) *j);
            }
            dp[i] = max;
        }
        return dp[n];
    }
}
```



## 7、* 不同的二叉搜索树

### ①、[题目链接](https://leetcode.cn/problems/unique-binary-search-trees/)

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 

示例 1：


输入：n = 3
输出：5
示例 2：

输入：n = 1
输出：1


提示：

1 <= n <= 19



### ②、思路

注意，种类与结点编号无关，只和结点个数有关

1~5 号结点的二叉搜索树种类和5 ~9结点的二叉搜索树种类一样！

所以，加入当前结点时，分别从1 到当前结点编号的结点都可以成为根节点，而且两侧的编号都是连续的！！！

故左右子树都符合 相应个数的结点种类。

左子树的种类乘以右子树的，就是当前根下的所有种类。



### ③、代码

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n +1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j -1] *dp[i -j];
            }
        }
        return dp[n];
    }
}
```



## 8、* 分割等和子集

### ①、[题目链接](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
示例 2：

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。


提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100



### ②、思路

背包是和，货物是元素，即，是否能在总和一半这个背包，找到能够填充满的组合，且货物唯一，01背包

递推：dp[j] = max(dp[j -weigh[i]] +value[i])

遍历顺序：要看最后一个货物放不放，所以每一个容量都要比较三个货物，先遍历货物；

​						 为了不重复放入物品，容量从后往前遍历；如果从前往后，由于递推式需要用到之前的容量，这个容量可能被刚刚更新过，即刚刚已经放入货物；当然，也可以在每次遍历前构造一个数据副本



### ③、代码

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i : nums){
            sum += i;
        }
        if(sum %2 == 1){
            return false;
        }
        int[] dp = new int[sum/2 +1];
        //nums[i]是货物，j是背包，dp[j]是以j为背包，货物的最大填充量
        //以总和一半为背包，有没有货物可以填满？
        for(int i : nums){
            for(int j = sum/2; j >= i; j--){
                    dp[j] = Math.max(dp[j], dp[j -i] +i);
                }
        }
        return dp[sum/2] == sum/2;
    }
}
```



## 9、* 最后一块石头重量

### ①、[题目链接](https://leetcode.cn/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
示例 2：

输入：stones = [31,26,33,21,40]
输出：5


提示：

1 <= stones.length <= 30
1 <= stones[i] <= 100



### ②、思路

是否存在一种货物组合，背包是总和的一半，看看这个背包下的最大货物量是多少
货物是石头，背包是和，不能重复选用，01背包



递推式：dp[i] = max(dp[i], dp[i -stones[j]] +stones[j]), j是货物，即，对当前货物来讲，不放或者放，取一个最大，所有货物						取一个最大

遍历顺序：先货物后背包，背包从后往前

遍历剪枝



### ③、代码

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for(int i : stones){
            sum += i;
        }
        int[] dp= new int[sum/2 +1];
        for(int i : stones){
            for(int j = sum/2; j >= i; j--){
                dp[j] = Math.max(dp[j], dp[j -i] +i);
            }
        }
        return sum -2*dp[sum/2];
    }
}
```



## 10、* 目标和

### ①、[题目链接](https://leetcode.cn/problems/target-sum/)

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

 

示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
示例 2：

输入：nums = [1], target = 1
输出：1


提示：

1 <= nums.length <= 20
0 <= nums[i] <= 1000
0 <= sum(nums[i]) <= 1000
-1000 <= target <= 1000



### ②、思路

dp[ i ] [ j ] :      0~i内的元素任意符号组合得到j的方法数
 递推：           0~i -1所有组合j加nums[i]或者减nums[i]就是dp[i] [j +nums[i]]和dp[i] [j -nums[i]]；

​								即前一位能组合到的和j加上当前元素后的和的方案数和前一位得到j的方案数是一样的。

注意，前一位能组合到的j，现在不一定能组合得到，因为不能每一位都要参与运算，根范围内的和不一样；

### ③、代码

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        //dp[i][j]: 0~i内的元素任意符号组合得到j的方法数
        //递推：0~i -1所有组合j加nums[i]或者减nums[i]就是dp[i][j +nums[i]]和dp[i][j -nums[i]];
        //      即，前一位能组合到的和j加上当前元素后的和的方案数和前一位得到j的方案数是一样的
        int[] dp = new int[2001];
        int sum = 1000 +nums[0];
        dp[nums[0] +1000] += 1;
        dp[-nums[0] +1000] += 1;
        for(int i = 1; i < nums.length; i++){
            int[] ndp = new int[2001];
            for(int j = 2000 -sum; j <= sum; j++){
                if(dp[j] != 0){
                    ndp[j +nums[i]] += dp[j];
                    ndp[j -nums[i]] += dp[j];
                }
            }
            sum += nums[i];
            dp = ndp;
        }
        return dp[target +1000];
    }
}
```

## 11、* 一和零

### ①、[题目链接](https://leetcode.cn/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

 

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
示例 2：

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。


提示：

1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] 仅由 '0' 和 '1' 组成
1 <= m, n <= 100



### ②、思路

和背包问题相同，只不过限制条件变成两个

货物是str（0个数， 1个数）



含义：dp [ i ] [ j ]:  背包（i,j）下最大长度 


递推：dp [i] [j] = max(dp [i] [j], dp [i -0] [ j -1] +1)



遍历顺序：货物不重复，01背包，先货物后背包，背包从后往前防止重复



### ③、代码

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m +1][n +1];
        for(String str : strs){
            int c0 = 0;
            int c1 = 0;
            for(int i = 0; i < str.length(); i++){
                if(str.charAt(i) == '0'){
                    c0++;
                }
                else{
                    c1++;
                }
            }
            for(int i = m; i >= c0; i--){
                for(int j = n; j >= c1; j--){
                    dp[i][j] = Math.max(dp[i][j], dp[i -c0][j -c1] +1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 12、* 零钱兑换Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/coin-change-2/)

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 

示例 1：

输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2：

输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
示例 3：

输入：amount = 10, coins = [10] 
输出：1


提示：

1 <= coins.length <= 300
1 <= coins[i] <= 5000
coins 中的所有值 互不相同
0 <= amount <= 5000



### ②、思路

dp[i]：能凑出i的组合总数

递推：dp[i] = sum(dp[i -coins[j]])

注意：应该先遍历货币，再遍历金额；当遍历货币i时，当前dp里所有金额的数量代表只用之前的货币能凑出来的数量，那么加上当前货币后多出来的组合，就不会和之前的有重复



### ③、代码

```java
class Solution {
    public int change(int amount, int[] coins) {
        //dp[i]：能凑出i的组合总数
        //递推：dp[i] = sum(dp[i -coins[j]])
        int[] dp = new int[amount +1];
        dp[0] = 1;
        for(int v : coins){
            for(int i = 1; i <= amount; i++){
                if(i -v >= 0){
                    dp[i] += dp[i -v];
                }
            }
        }
        return dp[amount];
    }
}
```



## 13、组合总和Ⅳ

### ①、[题目链接](https://leetcode.cn/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

示例 1：

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
示例 2：

输入：nums = [9], target = 3
输出：0


提示：

1 <= nums.length <= 200
1 <= nums[i] <= 1000
nums 中的所有元素 互不相同
1 <= target <= 1000


进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

### ②、思路


求排列数，先遍历背包，再遍历货物



### ③、代码

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target +1];
        dp[0] = 1;
        for(int i = 1; i <= target; i++){
            for(int j : nums){
                if(i -j >= 0){
                    dp[i] += dp[i -j];
                }
            }
        }
        return dp[target];
    }
}
```



## 14、零钱兑换

### ①、[题目链接](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0


提示：

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104



### ②、思路

无论排列还是组合，最小的就好

当然，排列会遍历一些重复的，因此组合方式更快，即外货物，内背包



### ③、代码

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //dp[i]：凑出i的最少硬币数
        //递推：dp[i] = min(dp[i], dp[i -cons[j] +1])；
        int[] dp = new int[amount +1];
        Arrays.fill(dp, amount +1);
        dp[0] = 0;
        for(int j : coins){
            for(int i = 1; i <= amount; i++){
                if(i -j >= 0){
                    dp[i] = Math.min(dp[i], dp[i -j] +1);
                }
            }
        }
        return dp[amount] == amount +1 ? -1 : dp[amount];
    }
}
```



## 15、完全平方数

### ①、[题目链接](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 

示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9

提示：

1 <= n <= 104



### ②、思路

平方数是货物，和是背包，求最少货物数量，能够组合成相应背包容量

### ③、代码

```java
class Solution {
    public int numSquares(int n) {
        //货物
        int[] nums = new int[101];
        for(int i = 1; i <= 100; i++){
            nums[i] = i*i;
        }
        //容量为j的背包容纳的最小货物数
        int[] dp =  new int[n +1];
        //初始化
        Arrays.fill(dp, n +1);
        dp[0] = 0;
        //组合方式递推
        for(int i = 1; nums[i] <= n; i++){
            for(int j = nums[i]; j <= n; j++){
                    dp[j] = Math.min(dp[j], dp[j -nums[i]] +1);
            }
        }
        return dp[n];
    }
}
```

## 16、* 单词拆分

### ①、[题目链接](https://leetcode.cn/problems/word-break/)

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false


提示：

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s 和 wordDict[i] 仅有小写英文字母组成
wordDict 中的所有字符串 互不相同



### ②、思路

字典里的单词是货物，字符串是背包，字符串包含单词，该单词就能放进背包，单词可重复，完全背包

dp[i]：0~i字符串能不能由单词重组

递推：dp[i] =  exit(dp[i   -  单词] if   单词可以放进背包)

遍历顺序：由于不是简单的按照长度放入背包，不适合先货物后背包，因为每次都是检查字符串末尾是否是单词，

所以先背包，后货物。



### ③、代码

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        //dp[i]：下标从0~i的单词能不能被字典重组
        //单词是货物，字符串是背包，货物可重复，完全背包
        //遍历顺序：先货物后背包，从前往后可重复，剪枝
        int n = s.length();
        boolean[] dp = new boolean[n +1];
        //初始化
        dp[0] = true;
        char[] strs = s.toCharArray();
        List<char[]> wordD = new ArrayList<>();
        for(String str : wordDict){
            wordD.add(str.toCharArray());
        }
        //递推，先背包后货物
        for(int i = 1; i <= n; i++){
            for(char[] str : wordD){
                //剪枝
                if(i < str.length){
                    continue;
                }
                //检查当前货物满足条件
                boolean f = true;
                for(int j = 0; j < str.length; j++){
                    if(str[j] != strs[i +j -str.length]){
                        f = false;
                        break;
                    }
                }
                //当前货物满足，之前也满足那就满足，之前不满足就不满足
                if(f){
                    dp[i] = dp[i] || dp[i -str.length];
                }
            }
        }
        return dp[n];
    }
}
```



## 17、打家劫舍

### ①、[题目链接](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 400




### ②、思路

走楼梯问题

dp[i] ：0~i范围内能偷到的最大金额

 递推：dp[i] = max (dp[i -1], dp[i -2] +nums[i])，即，当前偷不偷还得看之前两个，当前不偷，那之前一个的最大收获就是当前收获，当前偷，那之前两个的最大收获加上当前偷的就是当前最大收获



### ③、代码

```java
class Solution {
    public int rob(int[] nums) {
        //dp[i] 0~i范围内能偷到的最大金额
        //递推：dp[i] = max (dp[i -1], dp[i -2] +nums[i])
        int cur = nums[0];
        int pre = 0;
        int temp = 0;
        for(int i = 1; i < nums.length; i++){
            temp = cur;
            cur = Math.max(cur, pre +nums[i]);
            pre = temp;
        }
        return cur;
    }
}
```



## 18、打家劫舍Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/house-robber-ii/submissions/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：

输入：nums = [1,2,3]
输出：3


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 1000



### ②、思路

两次打家劫舍，分别不要第一个和最后一个，最大值肯定在这两者之一，因为第一个和最后一个不可以一起选



### ③、代码

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1){
            return nums[0];
        }
        int temp = 0;
        int pre = 0;
        int cur1 = 0;
        int cur2 = 0;
        for(int i = 0; i < nums.length -1; i++){
            temp = cur1;
            cur1 = Math.max(cur1, pre +nums[i]);
            pre = temp;
        }
        pre = 0;
        for(int i = 1; i < nums.length; i++){
            temp = cur2;
            cur2 = Math.max(cur2, pre +nums[i]);
            pre = temp;
        }
        return Math.max(cur1, cur2);
    }
}
```



## 19、* 打家劫舍Ⅲ

### ①、[题目链接](https://leetcode.cn/problems/house-robber-iii/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

 

示例 1:



输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
示例 2:



输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9


提示：

树的节点数在 [1, 104] 范围内
0 <= Node.val <= 104

### ②、思路

以当前节点为根的最大收益，要么是偷当前节点，不偷子节点，要么是不偷当前节点，偷子节点；

所以，需要知道不偷两个子节点的收益、子节点的最大收益包括不包括子节点本身。

在数组的时候，不包括前一个元素的收益，可以从前两个找，但是这里，前两个是四个孙子节点，不好判断，因此，状态应该包括当前节点偷的最大收益，还有不偷的最大收益，方便判断子节点究竟是偷了还是没偷；

故dp[i]是一个两元素的数组；

先偷完子节点，再判断投不投根节点，选择后序遍历；

由于非递归的后序遍历前驱后继之间可能没有关系，因此不存在递推关系，只能选用递归；



### ③、代码

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = help(root);
        return Math.max(res[0], res[1]);
    }
    public int[] help(TreeNode cur){
        if(cur == null){
            return new int[]{0, 0};
        }
        int[] left = help(cur.left);
        int[] right = help(cur.right);
        int val1 = cur.val +left[0] +right[0];
        int val2 = Math.max(left[0], left[1]) +Math.max(right[0], right[1]);
        return new int[]{val2, val1};
    }
}
```



## 20、*买卖股票的最佳时机

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104




### ②、思路

分析每天的状态

分析状态的转化

考虑压缩维度

### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        //每天的状态：持股、不持股
        //手里的现金：初始为0；
        //dp[i][j]：0~i天内，下标为i的那天状态是j时的手里最多能有的现金
        int n = prices.length;
        int hav = -prices[0];
        int nohav = 0;
        int temp;
        for(int i = 1; i < prices.length; i++){
            temp = hav;
            hav = Math.max(hav, -prices[i]);
            nohav = Math.max(temp +prices[i], nohav);
        }
        return nohav;
    }
}
```

## 21、买卖股票的最佳时机 II

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 

示例 1：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
示例 3：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。


提示：

1 <= prices.length <= 3 * 104
0 <= prices[i] <= 104




### ②、思路



### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        //每天的状态：持股，不持股
        //dp[i][0]：下标为i那天持股时手上的最大现金
        //dp[i][1]: 下标为i那天不持股时手上的最大现金
        int n = prices.length;
        int hav = -prices[0];
        int nohav = 0;
        int temp = 0;
        for(int i = 1; i < n; i++){
            temp = hav;
            hav = Math.max(nohav -prices[i], hav);
            nohav = Math.max(nohav, temp +prices[i]);
        }
        return nohav;
    }
}
```



## 22、*买卖股票的最佳时机 III

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3：

输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
示例 4：

输入：prices = [1]
输出：0


提示：

1 <= prices.length <= 105
0 <= prices[i] <= 105




### ②、思路

分析每天状态，第一次和第二次分开，因为计算方法不一样；

初始化：注意第二次的初始化，和第一次初始化一样，可以把第一次看成当前买入卖出，为0；

递推：

### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        //每天的状态：第一次持股、第二次持股、第一次卖出后不持股，第二次卖出后不持股
        int n = prices.length;
        int hav1 = -prices[0];
        int hav2 = -prices[0];
        int no1 = 0;
        int no2 = 0;
        int temp1 = 0;
        int temp2 = 0;
        for(int i = 1; i < n; i++){
            temp1 = hav1;
            temp2 = no1;
            hav1 = Math.max(hav1, -prices[i]);
            no1 = Math.max(no1, temp1 +prices[i]);
            temp1 = hav2;
            hav2 = Math.max(hav2, temp2 -prices[i]);
            no2 = Math.max(no2, temp1 +prices[i]);
        }
        return no2;
    }
}
```



## 23、*买卖股票的最佳时机 IV

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2：

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。


提示：

0 <= k <= 100
0 <= prices.length <= 1000
0 <= prices[i] <= 1000




### ②、思路

分析状态：第j次持股，第j次卖出后不持股



除了第一笔交易递推公式不一样，其余都一样

和两笔的一样，只不过分别有k个递推变量；

从后往前遍历，第j比交易就能得到j-1笔的信息，不用暂存；

如果从前往后遍历，第j -1笔状态先改变，第j笔需要的又是之前的第j-1笔，需要暂存

第一笔单独计算

### ③、代码

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        int[] hav = new int[k];
        Arrays.fill(hav, -prices[0]);
        int[] no = new int[k];
        for(int i = 1; i < n; i++){
            for(int j = k -1; j > 0; j--){
                no[j] = Math.max(hav[j] +prices[i], no[j]);
                hav[j] = Math.max(hav[j], no[j -1] -prices[i]);
            }
            no[0] = Math.max(no[0], hav[0] +prices[i]);
            hav[0] = Math.max(hav[0], -prices[i]);
        }
        return no[k -1];
    }
}
```



## 24、 最佳买卖股票时机含冷冻期

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
示例 2:

输入: prices = [1]
输出: 0


提示：

1 <= prices.length <= 5000
0 <= prices[i] <= 1000



### ②、思路

分析状态

状态转化



### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        //状态：持股，卖出不持股，冷冻不持股， 不冰冻不持股
        int n = prices.length;
        int hav = -prices[0];
        int sell = 0;
        int bin = 0;
        int free = 0;
        for(int i = 1; i < n; i++){
            free = bin;
            bin = sell;
            sell = Math.max(sell, hav +prices[i]);
            hav = Math.max(hav, free -prices[i]);
        }
        return sell;
    }
}
```



## 25、买卖股票的最佳时机含手续费

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

示例 1：

输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
示例 2：

输入：prices = [1,3,7,5,10,3], fee = 3
输出：6


提示：

1 <= prices.length <= 5 * 104
1 <= prices[i] < 5 * 104
0 <= fee < 5 * 104




### ②、思路

分析状态种类

状态转化递归



### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int hav = -prices[0] -fee;
        int no = 0;
        int temp = 0;
        for(int i = 0; i < n; i++){
            temp = no;
            no = Math.max(no, hav +prices[i]);
            hav = Math.max(hav, temp -prices[i] -fee);
        }
        return no;
    }
}
```



## 26、最长递增子序列

### ①、[题目链接](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1


提示：

1 <= nums.length <= 2500
-104 <= nums[i] <= 104


进阶：

你能将算法的时间复杂度降低到 O(n log(n)) 吗?



### ②、思路

以i结尾的最长，每次状态更新都遍历之前所有dp



### ③、代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        //dp[i]：以nums[i]为最后一个元素的最长递增序列长度；
        int[] dp = new int[nums.length];
        int max = 0;
        for(int i = 1; i < nums.length; i++){
            for(int j = i -1; j >= dp[i]; j--){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i], dp[j] +1);
                }
            }
            max = Math.max(max, dp[i]);
        }
        return max +1;
    }
}
```



## 27、最长连续递增序列

### ①、[题目链接](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

示例 1：

输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：

输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。


提示：

1 <= nums.length <= 104
-109 <= nums[i] <= 109



### ②、思路

连续子序列，只由前一个状态递推即可

### ③、代码

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int dp = 1;
        int max = 1;
        for(int i = 1; i < nums.length; i++){
            if(nums[i] > nums[i -1]){
                dp++;
                max = Math.max(dp, max);
            }
            else{
                dp = 1;
            }
        }
        return max;
    }
}
```



## 28、最长重复子数组

### ①、[题目链接](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。

 

示例 1：

输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
示例 2：

输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5


提示：

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 100



### ②、思路

子序列分别以ij结尾

状态转化，如果当前两个结尾相等，那就是前一位的最长加上1；否则就是0

初始化

### ③、代码

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        //dp[i][j]：nums1以i结尾，nums2以j结尾的最长公共子数组长度
        int m = nums1.length;
        int n = nums2.length;
        int[][] dp = new int[m][n];
        int max = 0;
        for(int i = 0; i < m; i++){
            if(nums1[i] == nums2[0]){
                dp[i][0] = 1;
                max = 1;
            }
        }
        for(int j = 1; j < n; j++){
            if(nums1[0] == nums2[j]){
                dp[0][j] = 1;
                max = 1;
            }
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j <n; j++){
                if(nums1[i] == nums2[j]){
                    dp[i][j] = dp[i -1][j -1] +1;
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        return max;
    }
}	
```



## 29、最长公共子序列

### ①、[题目链接](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
示例 2：

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
示例 3：

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。


提示：

1 <= text1.length, text2.length <= 1000
text1 和 text2 仅由小写英文字符组成。



### ②、思路

以ij结尾为状态；

初始化

递推



### ③、代码

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] t1 = text1.toCharArray();
        char[] t2 = text2.toCharArray();
        int n1 = t1.length;
        int n2 = t2.length;
        //dp[i][j]：t1 在i内，t2在j内的最长公共子序列
        int[][] dp = new int[n1][n2];
        //初始化
        if(t1[0] == t2[0]){
            dp[0][0] =1;
        }
        for(int i= 1; i < n1; i++){
            if(t1[i] == t2[0]){
                dp[i][0] = 1;
            }
            else{
                dp[i][0] = dp[i -1][0];
            }
        }
        for(int i= 1; i < n2; i++){
            if(t2[i] == t1[0]){
                dp[0][i] = 1;
            }
            else{
                dp[0][i] = dp[0][i -1];
            }
        }
        //递推
        for(int i = 1; i < n1; i++){
            for(int j = 1; j < n2; j++){
                if(t1[i] == t2[j]){
                    dp[i][j] = dp[i -1][j -1] +1;
                }
                else{
                    dp[i][j] = Math.max(dp[i -1][j], dp[i][j -1]);
                }
            }
        }
        return dp[n1 -1][n2 -1];
    }
}
```



## 30、不相交的线

### ①、[题目链接](https://leetcode.cn/problems/uncrossed-lines/)

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

 

示例 1：


输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
示例 2：

输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3
示例 3：

输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2


提示：

1 <= nums1.length, nums2.length <= 500
1 <= nums1[i], nums2[j] <= 2000



### ②、思路

就是最长公共序列，不要求连续，但是要按顺序

分析含义

初始化

状态转化



### ③、代码

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int n1 = nums1.length;
        int n2 = nums2.length;
        int[][] dp = new int[n1][n2];
        //初始化
        if(nums1[0] == nums2[0]){
            dp[0][0] = 1;
        }
        for(int i = 1; i < n1; i++){
            if(nums1[i] == nums2[0]){
                dp[i][0] = 1;
            }
            else{
                dp[i][0] = dp[i -1][0];
            }
        }
        for(int i = 1; i < n2; i++){
            if(nums2[i] == nums1[0]){
                dp[0][i] = 1;
            }
            else{
                dp[0][i] = dp[0][i -1];
            }
        }
        //递推
        for(int i = 1; i < n1; i++){
            for(int j = 1; j < n2; j++){
                if(nums1[i] == nums2[j]){
                    dp[i][j] = dp[i -1][j -1] +1;
                }
                else{
                    dp[i][j] = Math.max(dp[i -1][j], dp[i][j -1]);
                }
            }
        }
        return dp[n1 -1][n2 -1];
    }
}
```



## 31、最大子数组和

### ①、[题目链接](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104


进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。



### ②、思路

以i结尾为状态

初始化

状态转化只需要前一个，因为是连续的



### ③、代码

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //dp[i]：以i结尾的最大连续子数组和
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int max = dp[0];
        for(int i = 1; i < nums.length; i++){
            dp[i] = Math.max(dp[i -1] +nums[i], nums[i]);
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```



## 32、判断子序列

### ①、[题目链接](https://leetcode.cn/problems/is-subsequence/)

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

 

示例 1：

输入：s = "abc", t = "ahbgdc"
输出：true
示例 2：

输入：s = "axc", t = "ahbgdc"
输出：false


提示：

0 <= s.length <= 100
0 <= t.length <= 10^4
两个字符串都只由小写字符组成。



### ②、思路

最长公共子序列长度是否等于s

分别以ij结尾为状态

初始化

状态转化，不是连续的，也不需要递增，取前一个的最大值或者前一个加1

### ③、代码

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] t1 = s.toCharArray();
        char[] t2 = t.toCharArray();
        int n1 = t1.length;
        int n2 = t2.length;
        if(n1 == 0){
            return true;
        }
        if(n2 == 0){
            return false;
        }
        //dp[i][j]：t1 在i内，t2在j内的最长公共子序列
        int[][] dp = new int[n1][n2];
        //初始化
        if(t1[0] == t2[0]){
            dp[0][0] =1;
        }
        for(int i= 1; i < n1; i++){
            if(t1[i] == t2[0]){
                dp[i][0] = 1;
            }
            else{
                dp[i][0] = dp[i -1][0];
            }
        }
        for(int i= 1; i < n2; i++){
            if(t2[i] == t1[0]){
                dp[0][i] = 1;
            }
            else{
                dp[0][i] = dp[0][i -1];
            }
        }
        //递推
        for(int i = 1; i < n1; i++){
            for(int j = 1; j < n2; j++){
                if(t1[i] == t2[j]){
                    dp[i][j] = dp[i -1][j -1] +1;
                }
                else{
                    dp[i][j] = Math.max(dp[i -1][j], dp[i][j -1]);
                }
            }
        }
        return dp[n1 -1][n2 -1] == n1;
    }
}
```



## 33、*不同的子序列

### ①、[题目链接](https://leetcode.cn/problems/distinct-subsequences/)

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

 

示例 1：

输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
示例 2：

输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
babgbag
babgbag
babgbag
babgbag
babgbag


提示：

0 <= s.length, t.length <= 1000
s 和 t 由英文字母组成



### ②、思路

以ij为状态

初始化

递推的时候，注意当前位置相等时，i -1 和j -1有多少种，i和j就有多少种，同时i -1和j 有多少种，i和j也有多少种；



### ③、代码

```java
class Solution {
    public int numDistinct(String s, String t) {
        //dp[i][j]：在si里，可以得到tj的方案数
        char[] chs = s.toCharArray();
        char[] cht = t.toCharArray();
        int n1 = chs.length;
        int n2 = cht.length;
        int[][] dp = new int[n1][n2];
        if(chs[0] == cht[0]){
            dp[0][0] = 1;
        }
        for(int i = 1; i < n1; i++){
            if(chs[i] == cht[0]){
                dp[i][0] = dp[i -1][0] +1;
            }
            else{
                dp[i][0] = dp[i -1][0];
            }
        }
        //递推
        for(int j = 1; j < n2; j++){
            for(int i = j; i < n1; i++){
                if(chs[i] == cht[j]){
                    dp[i][j] = dp[i -1][j] + dp[i -1][j -1] ;
                }
                else{
                    dp[i][j] = dp[i -1][j];
                }
            }
        }
        return dp[n1 -1][n2 -1];
    }
}
```

## 34、* 两个字符串的删除操作

### ①、[题目链接](https://leetcode.cn/problems/delete-operation-for-two-strings/)

给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。

每步 可以删除任意一个字符串中的一个字符。

 

示例 1：

输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
示例  2:

输入：word1 = "leetcode", word2 = "etco"
输出：4


提示：

1 <= word1.length, word2.length <= 500
word1 和 word2 只包含小写英文字母



### ②、思路

以ij为状态，不必要求ij结尾

初始化

状态转化



### ③、代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        //dp[i][j]：从0 ~i转化到0 ~j所需的最小步数
        char[] w1 = word1.toCharArray();
        char[] w2 = word2.toCharArray();
        int n1 = w1.length;
        int n2 = w2.length;
        int[][] dp = new int[n1][n2];
        //初始化
        if(w1[0] != w2[0]){
            dp[0][0] = 2;
        }
        for(int i = 1; i < n1; i++){
            if(w1[i] == w2[0]){
                dp[i][0] = i;
            }
            else{
                dp[i][0] = dp[i -1][0] +1;
            }
        }
        for(int i = 1; i < n2; i++){
            if(w2[i] == w1[0]){
                dp[0][i] = i;
            }
            else{
                dp[0][i] = dp[0][i -1] +1;
            }
        }
        //递推 
        for(int i = 1; i < n1; i++){
            for(int j = 1; j < n2; j++){
                if(w1[i] == w2[j]){
                    dp[i][j] = dp[i -1][j -1];
                }
                else{
                    dp[i][j] = Math.min(dp[i -1][j], dp[i][j -1]) +1;
                }
            }
        }
        return dp[n1 -1][n2 -1];
    }
}
```



## 35、编辑距离

### ①、[题目链接](https://leetcode.cn/problems/edit-distance/)

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')


提示：

0 <= word1.length, word2.length <= 500
word1 和 word2 由小写英文字母组成



### ②、思路

以ij为状态

分析状态转化，当前相等时怎么样转最小，不相等时怎么转最小



### ③、代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        //dp[i][j]：从0 ~i转化到0 ~j所需的最小步数
        char[] w1 = word1.toCharArray();
        char[] w2 = word2.toCharArray();
        int n1 = w1.length;
        int n2 = w2.length;
        if(n1 == 0){
            return n2;
        }
        if(n2 == 0){
            return n1;
        }
        int[][] dp = new int[n1][n2];
        //初始化
        if(w1[0] != w2[0]){
            dp[0][0] = 1;
        }
        for(int i = 1; i < n1; i++){
            if(w1[i] == w2[0]){
                dp[i][0] = i;
            }
            else{
                dp[i][0] = dp[i -1][0] +1;
            }
        }
        for(int i = 1; i < n2; i++){
            if(w2[i] == w1[0]){
                dp[0][i] = i;
            }
            else{
                dp[0][i] = dp[0][i -1] +1;
            }
        }
        //递推 
        for(int i = 1; i < n1; i++){
            for(int j = 1; j < n2; j++){
               if(w1[i] == w2[j]){
                   dp[i][j] = dp[i -1][j -1];
               }
               else{
                   dp[i][j] = Math.min(dp[i -1][j], Math.min(dp[i][j -1], dp[i -1][j -1])) +1;
               }
            }
        }
        return dp[n1 -1][n2 -1];
    }
}
```



## 36、*回文子串

### ①、[题目链接](https://leetcode.cn/problems/palindromic-substrings/)

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

示例 1：

输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"


提示：

1 <= s.length <= 1000
s 由小写英文字母组成



### ②、思路

ij范围是不是回文的为状态

状态转化

初始化

遍历顺序，看递推前状态在矩阵当前待推状态的哪个方向

如果在左边，从前往后遍历；

如果在右边，从后往前遍历；

如果在上边，从前往后遍历；

如果在下边，从后往前遍历；



### ③、代码

```java
class Solution {
    public int countSubstrings(String s) {
        char[] str = s.toCharArray();
        int n = str.length;
        boolean[][] dp = new boolean[n][n];
        int count = 0;
        //dp[i][j]：从i到j，是不是回文
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
               if(str[i] == str[j]){
                   if(j -i <= 1){
                       dp[i][j] = true;
                       count++;
                   }
                   else if(dp[i +1][j -1]){
                        dp[i][j] = true;
                        count++;
                   }
               }
            }
        }
        return count;
    }
}
```



## 37、*最长回文子序列

### ①、[题目链接](https://leetcode.cn/problems/longest-palindromic-subsequence/)

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 

示例 1：

输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
示例 2：

输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。


提示：

1 <= s.length <= 1000
s 仅由小写英文字母组成



### ②、思路

ij内最长回文长度为状态

递推：ij相等，ij不相等

遍历顺序：看递推前状态位于哪个位置

初始化或者进行边界处理

### ③、代码

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        char[] str = s.toCharArray();
        int n = str.length;
        int[][] dp = new int[n][n];
        //dp[i][j]：从i到j的最大回文子序列长度
        //递推：如果当前i和j相等，那i +1到j-1的最长加上2就是ij的最长
        //如果不相等，那就左边缩一个，右边缩一个，取最大
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(str[i] == str[j]){
                    if(j -i <= 1){
                        dp[i][j] = j -i +1;
                    }
                    else{
                        dp[i][j] = dp[i +1][j -1] +2;
                    }
                }
                else{
                    if(i < n -1){
                        dp[i][j] = dp[i +1][j];
                    }
                    if(j > 0){
                        dp[i][j] = Math.max(dp[i][j], dp[i][j -1]);
                    }
                }
            }
        }
        return dp[0][n -1];
    }
}
```



