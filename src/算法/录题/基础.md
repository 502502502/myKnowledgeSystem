# 一、数组

## 1、二分查找

### ①、[704. 二分查找 ](https://leetcode.cn/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```text
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

示例 2:

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

### ②、思路

`特征`：在**有序集合**中寻找元素-->二分法



`步骤`：

+ 预处理
  
  + 特殊情况处理
  
    > 当区间很大的时候，判断是否在区间内只需要两次判断，但是进入二分法会判断lnN次，因此预处理是有必要的
    
  + 设置左右端点
    
    + 闭区间
  
+ 不取等循环
  
  + 退出循环后左右端点相等
  
    > 这样退出循环后只有一种情况，left=right，不用分类讨论
    
  + 边界处理策略
  
    先做排除，`排除mid`以及某一边区间，当答案不可能取mid以及某一边的时候可以排除；
  
    上取整还是下取整取决于排除哪一边的区间，排除右边需要上取整，避免死循环。
  
    > 举个例子，下取整的某一时刻left = mid ，right = left +1，且target刚好在mid的位置。
    >
    > 若选择做排除右边判断，此时mid不会被排除掉，执行left = mid；
    >
    > 下一次循环还是这样的情况，即陷入死循环。
  
    + 排右上：先排除mid以及右边区间，上取整
    + 排左下：先排除mid以及左边区间，下取整
  
+ 尾处理
  
  + 选中结果是否是目标



### ③、代码

```java
class Solution {
    public int search(int[] nums, int target) {
        //1、预处理
        //①、特殊情况
        if(target < nums[0] || target > nums[nums.length -1])
            return -1;
        //②、设置左右端点
        int left = 0;
        int right = nums.length -1;
        //2、不取等循环
        while(left < right){
        	//边界处理策略：排右上
            int mid = left +((right -left +1) >>1);
            if(nums[mid] > target){
                right = mid -1;
            }
            else
                left = mid;
        }
        //3、尾处理
        return nums[left] == target ? left : -1;
    }
}
```

### ④、类似题

#### Ⅰ、[35. 搜索插入位置 ](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

示例 1:

```text
输入: nums = [1,3,5,6], target = 5
输出: 2
```


示例 2:

```text
输入: nums = [1,3,5,6], target = 2
输出: 1
```


示例 3:

```text
输入: nums = [1,3,5,6], target = 7
输出: 4
```

提示:

+ 1 <= nums.length <= 104
+ -104 <= nums[i] <= 104
+ nums 为 无重复元素 的 升序 排列数组
+ -104 <= target <= 104

**思路**：

不存在就找插入位置，那挪位置的元素肯定是比target大的，等价于`找最小元素，其值大于等于target`



**代码**：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        //1、预处理
        //①、特殊情况
        if(target < nums[0]){
            return 0;
        }
        else if(target > nums[nums.length -1]){
            return nums.length;
        }
        //②、设置左右区间
        int left = 0;
        int right = nums.length -1;
        //2、不取等循环
        while(left < right){
            //边界处理逻辑：排左下
            int mid = left +((right -left) >>1);
            if(nums[mid] < target){
                left = mid +1;
            }
            else{
                right = mid;
            }
        }
        //3、尾处理
        return left;
    }
}
```



#### Ⅱ、[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

示例 1：

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```


示例 2：

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```


示例 3：

```
输入：nums = [], target = 0
输出：[-1,-1]
```


提示：

+ 0 <= nums.length <= 105
+ -109 <= nums[i] <= 109
+ nums 是一个非递减数组
+ -109 <= target <= 109



**思路**

在有序集合寻找元素区间，可以先找一个区间端点，然后沿着端点找区间，故等价于找区间端点。

​				

若找左端点，即`找最大元素，其值比target小`；

​				

若找右端点，即`找最小元素，其值比target大`。



**代码**：

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        //1、预处理
        //①、特殊情况
        if(nums.length == 0 || target < nums[0] || target > nums[nums.length -1]){
            return new int[]{-1,-1};
        }
        //②、设置左右端点
        int left = 0;
        int right = nums.length -1;
        //2、不取等循环
        while(left < right){
            //边界处理策略：排右上
            int mid = left +((right -left +1) >>1);
            if(nums[mid] >= target){
                right = mid -1;
            }
            else{
                left = mid;
            }
        }
        //3、尾处理
        if(nums[left] != target){
            ++left;
            ++right;
        }
        while(++right < nums.length && nums[right] == target){}
        return --right >= left && nums[left] == target ? new int[]{left, right} : new int[]{-1, -1};
    }
}
```



#### Ⅲ、[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

```
输入：x = 4
输出：2
```


示例 2：

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```


提示：

+ 0 <= x <= 231 - 1



**思路**

`找最大的元素，其平方比x小`；

​				\

判断溢出：

使用long保存当前元素平方，与`integer最大值`比较；

使用int，与`integer最大值/当前元素`比较



**代码**：

```java
class Solution {
    public int mySqrt(int x) {
        //1、预处理、
        //①、特殊情况
        if(x < 2){
            return x;
        }
        //②、设置左右端点
        int left = 1;
        int right = (x >>1);
        //2、不取等循环
        while(left < right){
            //边界处理策略：排右上
            int mid = left +((right -left +1) >>1);
            if(mid > Integer.MAX_VALUE /mid || mid*mid > x){
                right = mid -1;
            }
            else{
                left = mid;
            }
        }
        //3、尾处理
        return left;
    }
}
```

#### Ⅳ、[367. 有效的完全平方数 ](https://leetcode.cn/problems/valid-perfect-square/)

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 

进阶：不要 使用任何内置的库函数，如  sqrt 。

示例 1：

```
输入：num = 16
输出：true
```


示例 2：

```
输入：num = 14
输出：false
```


提示：

+ 1 <= num <= 2^31 - 1

**思路**

`找最大的元素，其平方小于等于x`；

​				

判断溢出：

使用long保存当前元素平方，与`integer最大值`比较；

使用int，与`integer最大值/当前元素`比较



**代码**：

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        //1、预处理
        //①、特殊情况
        if(num == 1){
            return true;
        }
        //②、设置左右区间
        int left = 1;
        int right = (num >>1);
        //2、不取等循环
        while(left < right){
            //边界处理策略：排右上
            int mid = left +((right -left +1) >>1);
            if(mid > Integer.MAX_VALUE /mid || mid *mid > num){
                right = mid -1;
            }
            else{
                left = mid;
            }
        }
        //3、尾处理
        return left *left == num;
    }
}
```



## 2、移除元素

### ①、[27. 移除元素](https://leetcode.cn/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


示例 1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```


示例 2：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```


提示：

+ 0 <= nums.length <= 100
+ 0 <= nums[i] <= 50
+ 0 <= val <= 100



### ②、思路

`特征`：操作集合元素-->双指针



`步骤`：

+ 预处理

  + 处理特殊情况

  > 当特殊情况引起边界问题时，需要预先处理

  + 设置双指针

    + 快慢指针

      > 一前一后，快指针遍历，慢指针操作
      >
      > 遍历方向可以由左到右或者由右到左
      >
      > 结果保持原来次序

    + 左右指针

      > 一左一右，都找不同类型的第一个，进行操作
      >
      > 结果不会保持原来次序
      >
      > 操作次数少

  + 设置标记变量

  + 设置容器

+ 循环

  + 操作逻辑
    + 直接处理
    + 寻找第一个
    + 找到后处理

+ 尾处理



### ③、代码



**快慢指针**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //1、预处理、
        //①、设置快慢指针
        int slow = 0;
        int fast = 0;
        //2、循环
        while(fast < nums.length){
            //操作逻辑
            if(nums[fast++] != val){
                nums[slow++] = nums[fast -1];
            }
        }
        //3、尾处理
        return slow;
    }
}
```

**左右指针**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //1、预处理
        //①、特殊情况
        if(nums.length == 0){
            return 0;
        }
        if(nums.length == 1){
            return nums[0] == val ? 0 : 1;
        }
        //②、设置左右指针
        int left = 0;
        int right = nums.length -1;
        //2、循环
        while(left < right){
            //操作逻辑
            //①、从前往后找第一个要删除的元素
            while(left < nums.length && nums[left] != val){
                left++;
            }
            //②、从后往前找第一个要不需要删除的
            while(right >= 0 && nums[right] == val){
                right--;
            }
            //③、交换位置
             if(left < right){
                nums[left] = nums[left]^nums[right];
            	nums[right] = nums[left]^nums[right];
            	nums[left] = nums[left]^nums[right];  
            }
        }
        //3、尾处理
        return right +1;
    }
}		
```



### ④、类似题

#### Ⅰ、[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```


示例 2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```


提示：

+ 1 <= nums.length <= 3 * 104
+ -104 <= nums[i] <= 104
+ nums 已按 升序 排列



**思路**

删除集合元素，即操作集合元素

​				

集合有序，元素与附近元素有关系，设置快慢指针

​				

**代码**

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //1、预处理
        //①、设置快慢指针
        int slow = 0;
        int fast = 1;
        //2、循环
        while(fast < nums.length){
            //操作逻辑
            if(nums[fast++] != nums[slow]){
                nums[++slow] = nums[fast -1];
            }
        }
        //3、尾处理
        return slow +1;
    }
}
```



#### Ⅱ、[283. 移动零 ](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

示例 1:

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```


示例 2:

```
输入: nums = [0]
输出: [0]
```


提示:

+ 1 <= nums.length <= 104
+ -231 <= nums[i] <= 231 - 1



**思路**

移动集合元素，即操作集合元素

​				

操作有明显的左右区分，使用左右指针或者快慢指针都行

​				

但是本题要求保持原来次序，左右指针会复杂



**代码**

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //1、预处理
        //①、设置快慢指针
        int slow = 0;
        int fast = 0;
        //2、循环
        while(fast < nums.length){
            //操作逻辑
            if(nums[fast++] != 0){
                nums[slow++] = nums[fast -1];
            }
        }
        //3、尾处理
        while(slow < nums.length){
            nums[slow++] = 0;
        }
    }
}
```



#### Ⅲ、[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

示例 1：

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```


示例 2：

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```


示例 3：

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```


提示：

+ 1 <= s.length, t.length <= 200
+ s 和 t 只含有小写字母以及字符 '#'


进阶：

你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？



**思路**：

#符号操作元素的退格与否，即一个#号移除一个左边的元素，若按正常思路使用快慢指针，由于不知道还会碰到多				少个#，当前元素保留与否不确定，因此快慢指针从左遍历失效；

​				

若从右边往左遍历，当前元素如果不是#，而且当前元素之前没有未使用的#的时候，当前元素确定被保留，因此，				快慢指针仍然有效；



**代码**

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        //1、预处理
        //①、设置计数指针
        int sc= 0;
        int tc = 0;
        int sCur = s.length() -1;
        int tCur = t.length() -1;
        //2、循环
        while(sCur >= 0 || tCur >= 0){
            //操作逻辑
            //①、获取第一个保留的字符
            while(sCur >= 0){
                char sChar = s.charAt(sCur);
                if(sChar == '#'){
                    sc++;
                    sCur--;
                    continue;
                }
                if(sc > 0){
                    sc--;
                    sCur--;
                    continue;
                }
                break;
            }
            //②、获取第一个保留的字符
            while(tCur >= 0){
                char tChar = t.charAt(tCur);
                if(tChar == '#'){
                    tc++;
                    tCur--;
                    continue;
                }
                if(tc > 0){
                    tc--;
                    tCur--;
                    continue;
                }
                break;
            }
            //③、查看当前保留字符是否相等
            if((sCur >= 0 && tCur < 0) || (sCur < 0 && tCur >= 0)){
                return false;
            }
            if(sCur >= 0 && tCur >= 0 && s.charAt(sCur) != t.charAt(tCur)){
                return false;
            }
            tCur--;
            sCur--;
        }
        //3、尾处理
        return true;
    }
}
```



#### Ⅳ、[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

 

示例 1：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```


示例 2：

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```


提示：

+ 1 <= nums.length <= 104
+ -104 <= nums[i] <= 104
+ nums 已按 非递减顺序 排序


进阶：

请你设计时间复杂度为 O(n) 的算法解决本问题



**思路**

根据平方和大小移动元素，本质上还是移动元素，可以使用双指针，由于平方的非负性，最大的平方只可能出现在排序数组的两边，因此使用左右指针是合适的。



**代码**

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        //1、预处理
        //①、创建新数组
        int[] newNums = new int[nums.length];
        int cur = nums.length -1;
        //②、设置左右双指针
        int left = 0;
        int right = nums.length -1;
        //2、循环
        while(left < right){
            //操作逻辑
            if(nums[left]*nums[left] > nums[right]*nums[right]){
               newNums[cur--] = nums[left]*nums[left];
               left++;
            }
            else{
                newNums[cur--] = nums[right]*nums[right];
                right--;
            }
        }
        //3、尾处理
        newNums[cur] =  nums[left]*nums[left];
        return newNums;
    }
}
```



## 3、长度最小子数组

### ①、[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```


示例 2：

```
输入：target = 4, nums = [1,4,4]
输出：1
```


示例 3：

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```


提示：

+ 1 <= target <= 109
+ 1 <= nums.length <= 105
+ 1 <= nums[i] <= 105


进阶：

如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。



### ②、思路

`特征`

连续子数组问题-->滑动窗口

`步骤`

+ 预处理
  + 设置历史最值

  + 设置窗口左右端点

  + 设置窗口值

    > 若窗口值为窗口长度可不设置，利用左右端点

  + 设置辅助变量，容器等

    > 若逻辑简单，无需设置
+ 循环
  + 处理逻辑
    + 更新窗口值，辅助量
    + 更新左边界，辅助量
    + 更新历史最值
+ 尾处理



### ③、代码

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //1、预处理
        //①、设置历史最值
        int minLen = nums.length +1;
        //②、设置窗口左右端点
        int left = 0;
        int right = 0;
        //③、设置窗口值
        int value = 0;
        //2、循环
        while(right < nums.length){
            //操作逻辑
            //①、移动右边界，更新窗口值
            value += nums[right++];
            //②、移动左边界，更新窗口长度
            while(value -nums[left] >= target){
                value -= nums[left++];
            }
            //③、更新历史最值
            if(value >= target){
                minLen = minLen > right -left ? right -left : minLen;
            }
        }
        //3、尾处理
        return minLen == nums.length +1 ? 0 : minLen;
    }
}
```



### ④、类似题

#### Ⅰ、[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。

 

示例 1：

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```


示例 2：

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```


示例 3：

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```


示例 4：

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```


提示：

+ 1 <= fruits.length <= 105
+ 0 <= fruits[i] < fruits.length



**思路**

连续子数组问题-->滑动窗口



**代码**

```java
class Solution {
    public int totalFruit(int[] fruits) {
        //1、预处理
        //①、设置历史最值
        int maxlen = 0;
        //②、设置左右边界
        int left = 0;
        int right = 0;
        //③、设置辅助容器
        Map<Integer, Integer> map = new HashMap<>();
        //2、循环
        while(right < fruits.length){
            //操作逻辑
            //①、移动右边界，更新辅助容器
            map.put(fruits[right] ,map.getOrDefault(fruits[right], 0) +1);
            right++;
            //②、移动左边界，更新辅助容器
            while(left < right && map.size() > 2){
                if(map.get(fruits[left]) == 1){
                    map.remove(fruits[left++]);
                }
                else{
                    map.put(fruits[left], map.get(fruits[left++]) -1);
                }
            }
            //③、更新历史最值
            maxlen = maxlen < right -left ? right -left : maxlen;
        }
        //3、尾处理
        return maxlen;
    }
}
```



#### Ⅱ、[76. 最小覆盖子串 ](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：

+ 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
+ 如果 s 中存在这样的子串，我们保证它是唯一的答案。


示例 1：

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```


示例 2：

```
输入：s = "a", t = "a"
输出："a"
```


示例 3:

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```


提示：

+ 1 <= s.length, t.length <= 105
+ s 和 t 由英文字母组成



**思路**

连续子数组-->滑动窗口

若t长度比s长，那没有继续下去的必要了，因此需要特殊情况处理；

由于返回的是子串本身，而不是长度，因此记录历史最值时需要记录边界；

由于覆盖本身没有顺序要求，并且重复字母需要计数，因此不仅需要比较字母，又需要计数，使用辅助Map;

**代码**

```java
class Solution {
    public String minWindow(String s, String t) {
        //1、预处理
        //①、特殊情况
        if(t.length() > s.length()){
            return "";
        }
        //②、设置历史最值
        int minlen = s.length() +1;
        int minlenLeft = 0;
        int minlenRight = 0;
        //③、设置左右边界
        int left = 0;
        int right = 0;
        //④、设置辅助量
        Map<Character, Integer> smap = new HashMap();
        Map<Character, Integer> tmap = new HashMap();
        int count = 0;
        for(int i = 0 ; i < t.length(); i++){
            char ch = t.charAt(i);
            tmap.put(ch, tmap.getOrDefault(ch, 0) +1);
        }
        //2、循环
        while(right < s.length()){
            //操作逻辑
            //①、移动右边界，更新信息
            char ch = s.charAt(right++);
            if(tmap.containsKey(ch)){
                smap.put(ch, smap.getOrDefault(ch, 0) +1);
                if(smap.get(ch) <= tmap.get(ch)){
                    count++;
                }
            }
            //②、移动左边界，更新信息
            while(left < right && count == t.length()){
                ch = s.charAt(left);
                if(!tmap.containsKey(ch)){
                    left++;
                }
                else if(smap.get(ch) > tmap.get(ch)){
                    smap.put(ch, smap.get(ch) -1);
                    left++;
                }
                else{
                    //③、更新历史最值
                    if(minlen > right -left){
                        minlen = right -left;
                        minlenLeft = left;
                        minlenRight = right;
                    }
                    break;
                }
            }
        }
        //3、尾处理
        return minlen == s.length() +1 ? "" : s.substring(minlenLeft, minlenRight);
    }
}
```



## 4、螺旋矩阵

### ①、[59. 螺旋矩阵 II ](https://leetcode.cn/problems/spiral-matrix-ii/submissions/)

### ②、思路

`特征`

矩阵遍历

`步骤`

+ 预处理

  + 处理特殊情况
  + 设置位置指针
  + 设置辅助量

+ 循环

  + 操作逻辑

    <img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220725222215356.png" alt="image-20220725222215356" style="zoom:33%;" />

  + 更新信息

+ 尾处理



**代码模板**

```java
        //1、预处理
	        //①、特殊情况处理
	        //②、设置位置指针
	        //③、设置辅助量
				//Ⅰ、矩阵大小
				//Ⅱ、辅助容器
				//Ⅲ、容器指针
				//Ⅳ、判断标记
        //2、循环
			//①、信息初始化
	        //②、操作逻辑
				//Ⅰ、右
				//Ⅱ、下
				//Ⅲ、单行判断
				//Ⅳ、左
				//Ⅴ、单列判断
				//Ⅵ、上
			//③、更新信息
        //3、尾处理
			//①、是否完整
			//②、返回
```



### ③、代码

```java
class Solution {
    public int[][] generateMatrix(int n) {
        //1、预处理
        //①、设置位置指针
        int x = 0;
        int y = 0;
        //②、设置辅助量
        int[][] res = new int[n][n];
        int count = 0;
        int cur = 1;
        //2、循环
        while(cur < n*n){
            //操作逻辑
            //①、从左往右
            while(x < n -count -1){
                res[y][x++] = cur++;
            }
            //②、从上往下
            while(y < n -count -1){
                res[y++][x] = cur++;
            }
            //③、从右往左
            while(x > count){
                res[y][x--] = cur++;
            }
            //④、从下往上
            while(y > count){
                res[y--][x] = cur++;
            }
            //⑤、更新信息
            x++;
            y++;
            count++;
        } 
        //3、尾处理
        if(n %2 == 1){
            res[n/2][n/2] = n*n;
        }
        return res;
    }
}
```



### ④、类似题

#### Ⅰ、[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/submissions/)

**思路**

遍历矩阵，左下右上

若只有当行或者单列，只需要进行左下即可

**代码**

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        //1、预处理
        //①、设置位置双指针
        int x = 0;
        int y = 0;
        //②、设置辅助量
        int xlen = matrix[0].length;
        int ylen = matrix.length;
        int count = 0;
        List<Integer> res = new ArrayList<Integer>();
        boolean flagx = false;
        boolean flagy = false;
        //2、循环
        while(res.size() < xlen *ylen -1){
            //①、操作逻辑
            while(x < xlen -count -1){
                res.add(matrix[y][x++]);
                flagy = true;
            }
             while(y < ylen -count -1){
                res.add(matrix[y++][x]);
                flagx = true;
            }
            //若只有单行或者单列，之后的循环不用走了
            if(!flagx){
                break;
            }
             while(x > count){
                res.add(matrix[y][x--]);
            }
            if(!flagy){
                break;
            }
             while(y > count){
                res.add(matrix[y--][x]);
            }
            //②、更新信息
            x++;
            y++;
            count++;
            flagx = flagy = false;
        }
        //3、尾处理
        if(res.size() < xlen*ylen){
            res.add(matrix[y][x]);
        }
        return res;
    }
}
```



#### Ⅱ、[offer29.顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

 

示例 1：

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```


示例 2：

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```


限制：

+ 0 <= matrix.length <= 100
+ 0 <= matrix[i].length <= 100



**思路**

按步骤即可

**代码**

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        //1、预处理
	        //①、特殊情况处理
        if(matrix.length == 0){
            return new int[0];
        }
	        //②、设置位置指针
        int x = 0;
        int y = 0;
	        //③、设置辅助量
        int xlen = matrix[0].length;
        int ylen = matrix.length;
        int sum = xlen *ylen;
        int[] res = new int[sum];
        int cur = 0;
        int count = 0;
        boolean flagx = true;
        boolean flagy = true;
        //2、循环
        while(cur < sum -1){
            //①、信息初始化
            if(x == xlen/2){
                flagy = false;
            }
            if(y == ylen/2){
                flagx = false;
            }
            //②、操作逻辑
				//Ⅰ、右
            while(x < xlen -count -1){
                res[cur++] = matrix[y][x++];
            }
				//Ⅱ、下
            while(y < ylen -count -1){
                res[cur++] = matrix[y++][x];
            }
				//Ⅲ、单行判断
            if(!flagx){
                break;
            }
				//Ⅳ、左
            while(x > count){
                res[cur++] = matrix[y][x--];
            }
                //Ⅴ、单列判断
            if(!flagy){
                break;
            }
				//Ⅵ、上
            while(y > count){
                res[cur++] = matrix[y--][x];
            }
			//③、更新信息
            x++;
            y++;
            count++;
        }
        //3、尾处理
        if(cur < sum){
            res[cur] = matrix[y][x];
        }
        return res;
    }
}
```



# 二、链表

**代码模板**

```java
		//1、预处理
        //①、特殊情况
        //②、虚拟头结点
        //③、遍历指针（左右指针）
        //④、前后指针
        //⑤、辅助量
        //2、循环
        while(){
            //①、保存信息
            //②、操作逻辑
            //③、更新信息

        }
        //3、尾处理
        return
```



## 1、移除元素

### ①、[203. 移除链表元素 ](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。


示例 1：

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```


示例 2：

```
输入：head = [], val = 1
输出：[]
```


示例 3：

```
输入：head = [7,7,7,7], val = 7
输出：[]
```


提示：

+ 列表中的节点数目在范围 [0, 104] 内
+ 1 <= Node.val <= 50
+ 0 <= val <= 50

### ②、思路

`特征`

虚拟头结点

一个原则：拿到被操作元素，以及它的前后元素，据此设置指针以及设计操作逻辑

若问题可拆分，可以分步进行，重复步骤

`步骤`

+ 预处理
  + 处理特殊情况

  + 设置虚拟头结点

    > 涉及变更头结点时使用

  + 设置遍历指针

    + 单指针

      >  每条链一个遍历指针

    + 双指针

      > 每条链两个遍历指针

      + 快慢指针-->成环问题
      + 先后指针-->次序问题
      + 左右指针-->子链问题

  + 设置前后指针

    > 一般需要操作元素时使用

  + 设置辅助量
    + 标记量
      + 标记头结点
      + 标记尾结点
      + 一些断言
    + 容器

+ 循环遍历
  + 保存信息
  + 操作逻辑
  + 更新信息
  
+ 尾处理



### ③、代码

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //1、预处理
        //①、设置虚头结点
        ListNode nhead = new ListNode();
        nhead.next = head;
        //②、设置遍历指针
        ListNode cur = nhead;
        //2、循环
        while(cur != null && cur.next != null){
            //①、操作逻辑
            if(cur.next.val == val){
                cur.next = cur.next.next;
            }
            //②、更新信息
            else{
                cur = cur.next;
            }
        }
        //4、尾处理
        return nhead.next;
    }
}
```

## 2、设计链表

### ①、[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

+ get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
+ addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
+ addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
+ addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
+ deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。


示例：

```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```


提示：

+ 所有val值都在 [1, 1000] 之内。
+ 操作次数将在  [1, 1000] 之内。
+ 请不要使用内置的 LinkedList 库。



### ②、思路

+ 结点定义
+ 虚拟头结点定义
+ 构造函数定义
+ add
  + 预处理
    + 设置遍历指针
    + 设置前后指针
  + 循环
    + 保存信息
    + 操作逻辑
    + 更新信息
  + 尾处理
+ get
+ delete

### ③、代码

```java
class MyLinkedList {
    //结点定义
    class ListNode{
        int val;
        ListNode next;
        ListNode(){
           
        }
        ListNode(int val){
             this.val = val;
        }
        ListNode(int val, ListNode next){
             this.val = val;
             this.next = next;
        }
    }
    //虚拟头结点
    ListNode nhead;

    public MyLinkedList() {
        nhead= new ListNode();
    }
    //get
    public int get(int index) {
        //1、预处理
        //①、设置遍历指针
        ListNode cur = nhead;
        //2、循环遍历
        while(cur != null && index-- >= 0){
            //①、更新信息
            cur = cur.next;
        }
        //3、尾处理
        return cur == null ?  -1 : cur.val;
    }
    //add
    public void addAtHead(int val) {
        //3、尾处理
        ListNode node = new ListNode(val);
        node.next = nhead.next;
        nhead.next = node;
    }
    
    public void addAtTail(int val) {
        //1、预处理
        //①、设置遍历指针
        ListNode cur = nhead;
        //2、循环遍历
        while(cur != null && cur.next != null){
            //①、更新信息
            cur = cur.next;
        }
        //3、尾处理
        ListNode node = new ListNode(val);
        node.next = cur.next;
        cur.next = node;
    }
    
    public void addAtIndex(int index, int val) {
        //1、预处理
        //①、设置遍历指针
        ListNode cur = nhead;
        //2、循环遍历
        while(cur != null && index-- > 0){
            //①、更新信息
            cur = cur.next;
        }
        //3、尾处理
        if(cur != null){
            ListNode node = new ListNode(val);
            node.next = cur.next;
            cur.next = node;
        }
    }
    //delete
    public void deleteAtIndex(int index) {
        //1、预处理
        //①、设置遍历指针
        ListNode cur = nhead;
        //2、循环遍历
        while(cur != null && index-- > 0){
            //①、更新信息
            cur = cur.next;
        }
        //3、尾处理
        if(cur != null){
            cur.next = cur.next == null ? null :cur.next.next;
        }
    }
}
```

## 3、翻转链表

### ①、[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。


示例 1：

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```


示例 2：

```
输入：head = [1,2]
输出：[2,1]
```


示例 3：

```
输入：head = []
输出：[]
```


提示：

+ 链表中节点的数目范围是 [0, 5000]
+ -5000 <= Node.val <= 5000





### ②、思路

+ 预处理
  + 设置遍历指针
  + 设置前后指针
+ 遍历
  + 保存信息
  + 操作逻辑
  + 更新信息
+ 尾处理



### ③、代码

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        //1、预处理
        //①、设置遍历指针
        ListNode cur = head;
        //②、设置前置指针
        ListNode curPre = null;
        //③、设置后置指针
        ListNode curNext = null;
        while(cur != null){
            //①、保存信息
            curNext = cur.next;
            //②、操作逻辑
            cur.next = curPre;
            //③、更新信息
            curPre = cur;
            cur = curNext;
        }
        //3、尾处理
        return curPre;
    }
}
```



## 4、两两交换

### ①、[24. 两两交换链表中的节点 ](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

示例 1：

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```


示例 2：

```
输入：head = []
输出：[]
```


示例 3：

```
输入：head = [1]
输出：[1]
```


提示：

+ 链表中节点的数目在范围 [0, 100] 内
+ 0 <= Node.val <= 100



### ②、思路

获取操作区间左右端点以及区间的前后元素即可

### ③、代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        //1、预处理
        //①、设置虚拟头结点
        ListNode nhead = new ListNode();
        nhead.next = head;
        //②、设置左指针
        ListNode left = head;
        //③、设置前置指针
        ListNode leftPre = nhead;
        //④、设置右指针
        ListNode right = null;
        //⑤、设置后置指针
        ListNode rightNext = null;
        //2、循环遍历
        while(left != null && left.next != null){
            //①、保存信息
            rightNext = left.next.next;
            right = left.next;
            //②、操作逻辑
            leftPre.next = right;
            right.next = left;
            left.next = rightNext;
            //②、更新信息
            leftPre = left;
            left = rightNext;
        }
        //3、尾处理
        return nhead.next;
    }
}
```



## 5、删除倒数第N

### ①、[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

 

示例 1：

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```


示例 2：

```
输入：head = [1], n = 1
输出：[]
```


示例 3：

```
输入：head = [1,2], n = 1
输出：[1]
```


提示：

链表中结点的数目为 sz

+ 1 <= sz <= 30
+ 0 <= Node.val <= 100
+ 1 <= n <= sz



### ②、思路

由于遍历指针不能完成计数功能，故使用左右指针

### ③、代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //1、预处理
        //②、虚拟头结点
        ListNode nhead = new ListNode();
        nhead.next = head;
        //③、遍历指针（左右指针）
        ListNode left = nhead;
        ListNode right = nhead;
        //2、循环
        while(right.next != null){
            //②、操作逻辑
            if(n-- > 0){
                right = right.next;
            }
            //③、更新信息
            else{
                left = left.next;
                right = right.next;
            }
        }
        //3、尾处理
        left.next = left.next.next;
        return nhead.next;
    }
}
```



## 6、链表相交

### ①、[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：



题目数据 保证 整个链式结构中不存在环。

>  注意，函数返回结果后，链表必须 保持其原始结构 。

 

示例 1：



```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```


示例 2：



```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```


示例 3：



```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```


提示：

+ listA 中节点数目为 m
+ listB 中节点数目为 n
+ 0 <= m, n <= 3 * 104
+ 1 <= Node.val <= 105
+ 0 <= skipA <= m
+ 0 <= skipB <= n
+ 如果 listA 和 listB 没有交点，intersectVal 为 0
+ 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]




### ②、思路

循环完自己循环另一条，若无交点退出循环时两个遍历指针都是null

### ③、代码

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //1、预处理
        //③、遍历指针（左右指针）
        ListNode curA = headA;
        ListNode curB = headB;
        //2、循环
        while(curA != curB){
            //③、更新信息
            curA = curA == null ? headB : curA.next;
            curB = curB == null ? headA : curB.next;
        }
        //3、尾处理
        return curA;
    }
}
```



## 7、环形链表

### ①、[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 

示例 1：



```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```


示例 2：



```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```


示例 3：



```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```


提示：

+ 链表中节点的数目范围在范围 [0, 104] 内
+ -105 <= Node.val <= 105
+ pos 的值为 -1 或者链表中的一个有效索引


进阶：你是否可以使用 O(1) 空间解决此题？





### ②、思路

成环问题-->快慢指针

之后转化成双链表交点问题即可

### ③、代码

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        /*********判断链表成环******************* */
        //1、预处理
        //②、虚拟头结点
        ListNode nhead = new ListNode();
        nhead.next = head;
        //③、遍历指针（左右指针）
        ListNode left = nhead;
        ListNode right = head;
        //2、循环
        while(left != right){
            //①、保存信息
            //②、操作逻辑
            //③、更新信息
            left = left == null ? null : left.next;
            right = right != null && right.next != null ? right.next.next : null;
        }
        //3、尾处理
        if(left == null){
            return null;
        }

        /***********链表相交找交点********************************************* */
        //1、预处理
        //⑤、辅助量
        ListNode tail = null;
        ListNode headB = null;
        tail = left;
        headB = left.next;
        //③、遍历指针
        ListNode curA = head;
        ListNode curB = headB;
        //2、循环
        while(curA != curB){
            curA = curA == tail ? headB : curA.next;
            curB = curB == tail ? head : curB.next;
        }
        //3、尾处理
        return curA;
    }
}
```



# 三、哈希表

**代码模板**

```java
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
	        //③、设置辅助量
			//④、初始化
				//Ⅰ、排序
				//Ⅱ、初值
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
	        //①、获取kv
	        //②、操作逻辑
	        //③、更新kv
        //3、尾处理
			//①、初始化参数
			//②、构建答案
			//③、返回
```



## 1、有效字母异位

### ①、[242. 有效的字母异位词 ](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

```
输入: s = "anagram", t = "nagaram"
输出: true
```


示例 2:

```
输入: s = "rat", t = "car"
输出: false
```


提示:

+ 1 <= s.length, t.length <= 5 * 104
+ s 和 t 仅包含小写字母



### ②、思路

元素计数-->map

元素存在-->set/map



### ③、代码

```java
class Solution {
    public boolean isAnagram(String s, String t) {
          //1、预处理
        //①、特殊情况处理
        if(s.length() != t.length()){
            return false;
        }
        //②、设置哈希表
        int[] map = new int[26];
        //2、循环
        for(int i = 0; i < s.length(); i++){
            int indexs = s.charAt(i) -'a';
            int indext = t.charAt(i) -'a';
            //①、操作逻辑
            map[indexs]++;
            map[indext]--;
        }
        //3、尾处理
        for(int i = 0; i < 26; i++){
            if(map[i] != 0){
                return false;
            }
        }
        return true;

    }
}
```



### ④、类似题

#### Ⅰ、[383.赎金信](https://leetcode.cn/problems/ransom-note/)

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

 

示例 1：

```
输入：ransomNote = "a", magazine = "b"
输出：false
```


示例 2：

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```


示例 3：

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```


提示：

+ 1 <= ransomNote.length, magazine.length <= 105
+ ransomNote 和 magazine 由小写英文字母组成



**思路**

计数问题--> map

**代码**

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        //1、预处理
	        //①、特殊情况
        if(ransomNote.length() > magazine.length()){
            return false;
        }
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
        int[] map = new int[26];
	        //③、设置辅助量
        //2、循环
        for(int i = 0; i < ransomNote.length(); i++){
	        //①、获取kv
            int index = ransomNote.charAt(i) -'a';
	        //②、操作逻辑
	        //③、更新kv
            map[index]++;
        }
        for(int i = 0; i < magazine.length(); i++){
	        //①、获取kv
            int index = magazine.charAt(i) -'a';
	        //②、操作逻辑
	        //③、更新kv
            map[index]--;
        }
        //3、尾处理
        for(int i = 0; i < ransomNote.length(); i++){
	        //①、获取kv
            int index = ransomNote.charAt(i) -'a';
	        //②、操作逻辑
	        if(map[index] > 0){
                return false;
            }
        }
        return true;
    }
}
```



#### Ⅱ、[43.字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

 

示例 1:

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```


示例 2:

```
输入: strs = [""]
输出: [[""]]
```


示例 3:

```
输入: strs = ["a"]
输出: [["a"]]
```


提示：

+ 1 <= strs.length <= 104
+ 0 <= strs[i].length <= 100
+ strs[i] 仅包含小写字母



**思路**

本题仍然是异位词，但是具体和谁比是一个问题

显然应该和每一组的标准作异位词比较

比较过程可以用之前的异位词比较方法

问题在于必须遍历已经存在的组，一一比较，符合就入组，否则自己成组，这样可以，但是每次都需要遍历所有分组，效率低下。



标准是否存在即存在问题，可以用set判断，但是还需要用到key对应的value，故还是得用map

那标准如何确定呢？异位词始终是相同的字母，排序一下都是相等的，所以查找排序后的key是否存在即可

由于查找时已经与分组标准比较了，故不再需要之前的map计数方法比较当前词和标准是否是异位词了。



```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
            Map<String, List<String>>  map = new HashMap<>();
		        //Ⅱ、数组模拟
	        //③、设置辅助量
            List<List<String>> res = new ArrayList<>();
        //2、循环
        for(int i = 0; i < strs.length; i++){
	        //①、获取kv
            char[] curstr = strs[i].toCharArray();
            Arrays.sort(curstr);
            String sortstr = String.valueOf(curstr);
	        //②、操作逻辑
            List<String> value = map.getOrDefault(sortstr, new ArrayList<String>());
            value.add(strs[i]);
	        //③、更新kv
            map.put(sortstr, value);
        }
        //3、尾处理
        for(List<String> v : map.values()){
            res.add(v);
        }
        return res;
    }
}
```



#### Ⅲ、[438.字符串中所有异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

示例 1:

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```


 示例 2:

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```


提示:

+ 1 <= s.length, p.length <= 3 * 104
+ s 和 p 仅包含小写字母



**思路**

异位词比较，用map计数即可

问题在于和谁比，s中所有长度和p相同的子串都应该进行比较，故有一个循环



**代码**

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
        int[] map = new int[26];
	        //③、设置辅助量
        List<Integer> res = new ArrayList<>();
        boolean flag = true;
        //2、循环
        for(int i = 0; i <= s.length() -p.length(); i++){
            //循环
            for(int j = i; j < i +p.length(); j++){
	        //①、获取kv
                int ins = s.charAt(j) -'a';
                int inp = p.charAt(j -i) -'a';
	        //②、操作逻辑
	        //③、更新kv
                map[ins]++;
                map[inp]--;
            }
            //尾处理
            for(int k = 0; k < 26; k++){
                if(map[k] != 0){
                    flag = false;
                }
                map[k] = 0;
            }
            if(flag){
                res.add(i);
            }
            flag = true;
        }
        //3、尾处理
        return res;
    }
}
```



## 2、数组交集

### ①、[349.两个数组交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

 

示例 1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```


示例 2：

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```


提示：

+ 1 <= nums1.length, nums2.length <= 1000
+ 0 <= nums1[i], nums2[i] <= 1000



### ②、思路

元素存在问题，且去重--->set

可以使用系统的set

也可以自己模拟



### ③、代码



```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        //1、预处理
        	//①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
        int[] set = new int[1000];
        	//③、设置辅助量
        int count = 0;
        //2、循环
        //①、标记循环
        for(int i = 0; i <  nums1.length; i++){
            //③、更新kv
            set[nums1[i]] = 1;
        }
        //②、检查循环
        for(int i = 0; i <  nums2.length; i++){
            //②、操作逻辑
            if(set[nums2[i]] == 1){
                count++;
            }
            set[nums2[i]] = 0;
        }
        //3、尾处理
        //①、初始化
        int[] res = new int[count];
        count = 0;
        //②、构建答案
        for(int i = 0; i <  nums1.length; i++){
            if(set[nums1[i]] == 0){
                res[count++] = nums1[i];
                set[nums1[i]] = 1;
            }
        }
        //返回答案
        return res;
    }
}
```



### ④、类似题

#### Ⅰ、[350.两个数组交集Ⅱ](https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/)

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

 

示例 1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```


示例 2:

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```


提示：

+ 1 <= nums1.length, nums2.length <= 1000
+ 0 <= nums1[i], nums2[i] <= 1000


进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？



**思路**

元素存在问题，且可重复--->map



**代码**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
            int[] map = new int[1001];
	        //③、设置辅助量
            int count = 0;
			//④、初始化
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
        for(int i = 0; i < nums1.length; i++){
	        //①、获取kv
	        //②、操作逻辑
	        //③、更新kv
            map[nums1[i]]++;
        }
        for(int i = 0; i < nums2.length; i++){
	        //①、获取kv
	        //②、操作逻辑
	        //③、更新kv
            if(map[nums2[i]] > 0){
                count++;
                map[nums2[i]]--;
            }
        }
        //3、尾处理
			//①、初始化参数
        int[] res = new int[count];
        count = 0;
			//②、构建答案
        for(int i = 0; i < nums1.length; i++){
            map[nums1[i]]--;
            if(map[nums1[i]] < 0){
                res[count++] = nums1[i];
            }
        }
			//③、返回
        return res;
    }
}
```



## 3、快乐数

### ①、[202.快乐数](https://leetcode.cn/problems/happy-number/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

 

示例 1：

```
输入：n = 19
输出：true
```


解释：

```
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

示例 2：

示例 2：

```
输入：n = 2
输出：false
```


提示：

+ 1 <= n <= 231 - 1



### ②、思路

无限循环，即元素曾经存在，使用set

### ③、代码

```java
class Solution {
    public boolean isHappy(int n) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
                Set<Integer> set = new HashSet<>();
                int[] map = new int[10];
		        //Ⅱ、数组模拟
	        //③、设置辅助量
			//④、初始化
            for(int i = 0; i < 10; i++){
                map[i] = i *i;
            }
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
        while(n != 1 && !set.contains(n)){
            //③、更新kv
            set.add(n);
	        //①、获取kv
	        //②、操作逻辑
            int sum = 0;
            while(n != 0){
                sum += map[n %10];
                n /= 10;
            }
            n = sum;
        }
        //3、尾处理
			//①、初始化参数
			//②、构建答案
			//③、返回
            return n == 1 ;
    }
}
```





## 4、两数之和

### ①、[* 1.两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```


示例 2：

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```


示例 3：

```
输入：nums = [3,3], target = 6
输出：[0,1]
```


提示：

+ 2 <= nums.length <= 104
+ -109 <= nums[i] <= 109
+ -109 <= target <= 109
  只会存在一个有效答案
  进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？





### ②、思路

判断与当前元素相加得target的元素是否存在即可，元素存在问题，且仍需使用存在元素的下标，故用map

由于需要返回元素下标，故不可排序

### ③、代码

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
        Map<Integer, Integer> map = new HashMap<>();
		        //Ⅱ、数组模拟
	        //③、设置辅助量
        int[] res = new int[2];
			//④、初始化
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
        for(int i = 0; i < nums.length; i++){
	        //①、获取kv
	        //②、操作逻辑
           if(map.containsKey(target -nums[i])){
              res[0] = i;
              res[1] = map.get(target -nums[i]);
              break;
           }
           //③、更新kv
            map.put(nums[i], i);
        }
        //3、尾处理
			//①、初始化参数
			//②、构建答案
			//③、返回
        return res;
    }
}
```





## 5、四数相加

### ①、[*  454.四数相加](https://leetcode.cn/problems/4sum-ii/)

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0


示例 1：

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：

(0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0

(1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```



示例 2：

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```


  提示：

+ n == nums1.length
+ n == nums2.length
+ n == nums3.length
+ n == nums4.length
+ 1 <= n <= 200
+ -228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228



### ②、思路

相当于两数之和，只不过每一个数都是两数之和；

当然，也可以是三数之和与第四个数的两数之和；

总之，无论多少个数之和，都看成两数之和即可，至于哪两数是一组，随意，反正其余的两组与之相加得目标。

不需要去重，故不需要排序

### ③、代码

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
                Map<Integer, Integer> map = new HashMap<>();
		        //Ⅱ、数组模拟
	        //③、设置辅助量
            int n = nums1.length;
            int count = 0;
			//④、初始化
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
        
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                map.put(nums1[i] +nums2[j], map.getOrDefault(nums1[i] +nums2[j], 0) +1);
            }
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(map.containsKey(0 -(nums3[i] +nums4[j]))){
                    count += map.get(0 -(nums3[i] +nums4[j]));
                }
            }
        }
        //3、尾处理
			//①、初始化参数
			//②、构建答案
			//③、返回
            return count;
    }
}
```



## 6、三数之和

### ①、[* 15.三数之和](https://leetcode.cn/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```


示例 2：

```
输入：nums = []
输出：[]
```


示例 3：

```
输入：nums = [0]
输出：[]
```


提示：

+ 0 <= nums.length <= 3000
+ -105 <= nums[i] <= 105

### ②、思路

将和分成两部分，一部分放进哈希表，一部分查找

这里使用排序，方便去重和限界



### ③、代码

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
	        //③、设置辅助量
            List<List<Integer>> res = new ArrayList<>();
             //⑤、排序
            QuickSort(nums, 0, nums.length -1);
			//④、初始化
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
        for(int i = 0 ; i < nums.length; i++){
            if(nums[i] > 0){
                break;
            }
            if(i > 0 && nums[i] == nums[i -1]){
                continue;
            }
            int key = 0 -nums[i];
	        int left = i +1;
            int right = nums.length -1;
            while(left < right){
                if(nums[left] + nums[right] == key){
                    List<Integer> cur = new ArrayList<>();
                    cur.add(nums[i]);
                    cur.add(nums[left]);
                    cur.add(nums[right]);
                    res.add(cur);
                    while(left < right && nums[left] == nums[left +1]){
                        left++;
                    }
                    while(left < right && nums[right] == nums[right -1]){
                        right--;
                    }
                    left++;
                    right--;
                }
                else if(nums[left] + nums[right] < key){
                    left++;
                }
                else{
                    right--;
                }
            }
        }
        //3、尾处理
			//①、初始化参数
			//②、构建答案
			//③、返回
        return res;
    }
    public void QuickSort(int[] nums, int left, int right){
        if(left >= right){
            return;
        }
        int key = nums[left];
        int i = left; 
        int j = right;
        while(i < j){
            while(nums[j] >= key && i < j){
                j--;
            }
            while(nums[i] <= key && i < j){
                i++;
            }
            if(i < j){
                nums[i] = nums[i]^nums[j];
                nums[j] = nums[i]^nums[j];
                nums[i] = nums[i]^nums[j];
            }
        }
        nums[left] = nums[i];
        nums[i] = key;
        QuickSort(nums, left, i -1);
        QuickSort(nums, i +1, right);
    }
}
```



## 7、四数之和

### ①、[18.四数之和](https://leetcode.cn/problems/4sum/)

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

 

示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]


提示：

1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109



### ②、思路

同三数之和



### ③、代码

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        //1、预处理
	        //①、特殊情况
	        //②、设置哈希表
		        //Ⅰ、系统自带
		        //Ⅱ、数组模拟
	        //③、设置辅助量
            List<List<Integer>> res = new ArrayList<>();
			//④、初始化
				//Ⅰ、排序
            QuickSort(nums, 0, nums.length -1);
				//Ⅱ、初值
        //2、循环(可以多次循环，每一次的作用为标记或者查找)
        for(int i = 0; i < nums.length; i++){
            if(target < 0 && nums[i] > 0){
                break;
            }
            
            if(i > 0 && nums[i] == nums[i -1]){
                continue;
            }
            for(int j = i +1; j < nums.length; j++){
                long key = target -((long)nums[j] + (long)nums[i]);
                if(j > i +1 && nums[j] == nums[j -1]){
                    continue;
                }
                int left = j +1;
                int right = nums.length -1;
                while(left < right){
                    if(key == nums[left] + nums[right]){
                        List<Integer> cur = new ArrayList<>();
                        cur.add(nums[i]);
                        cur.add(nums[j]);
                        cur.add(nums[left]);
                        cur.add(nums[right]);
                        res.add(cur);
                        while(left < right && nums[left] == nums[left +1]){
                            left++;
                        }
                        while(left < right && nums[right] == nums[right -1]){
                            right--;
                        }
                        left++;
                        right--;
                    }
                    else if(key < nums[left] + nums[right]){
                        right--;
                    }
                    else{
                        left++;
                    }
                }

            }
        }
        //3、尾处理
			//①、初始化参数
			//②、构建答案
			//③、返回
            return res;
    }
     public void QuickSort(int[] nums, int left, int right){
        if(left >= right){
            return;
        }
        int key = nums[left];
        int i = left; 
        int j = right;
        while(i < j){
            while(nums[j] >= key && i < j){
                j--;
            }
            while(nums[i] <= key && i < j){
                i++;
            }
            if(i < j){
                nums[i] = nums[i]^nums[j];
                nums[j] = nums[i]^nums[j];
                nums[i] = nums[i]^nums[j];
            }
        }
        nums[left] = nums[i];
        nums[i] = key;
        QuickSort(nums, left, i -1);
        QuickSort(nums, i +1, right);
    }
}
```





# 四、字符串

## 1、字符串反转

### ①、[题目链接](https://leetcode.cn/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

 

示例 1：

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]


提示：

1 <= s.length <= 105
s[i] 都是 ASCII 码表中的可打印字符



### ②、思路

双指针



### ③、代码

```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length-1;
        while(left < right){
            char temp = s[left];
            s[left++] = s[right];
            s[right--] = temp;
        }
    }
}
```



## 2、字符串反转Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/reverse-string-ii/submissions/)

给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。


示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"
示例 2：

输入：s = "abcd", k = 2
输出："bacd"


提示：

1 <= s.length <= 104
s 仅由小写英文组成
1 <= k <= 104



### ②、思路

递归 + 双指针

### ③、代码

```java
class Solution {
    private int key;
    private char[] str;
    public String reverseStr(String s, int k) {
        this.key = k;
        this.str = s.toCharArray();
        help(0,s.length() -1);
        return String.valueOf(this.str);
    }
    public void help(int left, int right){
        int len = right -left +1;
        if(len >= 2*this.key){
            help(left +2*this.key, right);
        }
        right = right < left +this.key -1 ? right : left +this.key -1;
        while(left < right){
            char temp = str[left];
            str[left++] = str[right];
            str[right--] = temp;
        }
    }
}
```





## 3、替换空格

### ①、[题目链接](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/submissions/)

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

 

示例 1：

输入：s = "We are happy."
输出："We%20are%20happy."


限制：

0 <= s 的长度 <= 10000



### ②、思路

遍历判断



### ③、代码

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == ' '){
                sb.append("%20");
            }
            else{
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
```





## 4、反转字符串的单词

### ①、[题目链接](https://leetcode.cn/problems/reverse-words-in-a-string/)

给你一个字符串 s ，请你反转字符串中 单词 的顺序。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

 

示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
示例 3：

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。


提示：

1 <= s.length <= 104
s 包含英文大小写字母、数字和空格 ' '
s 中 至少存在一个 单词


进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。



### ②、思路

从后往前遍历判断保存即可



### ③、代码

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        int left = 0;
        int right = s.length() -1;
        while(right >= 0){
            while(right >= 0 && s.charAt(right) == ' '){
                right--;
            }
            if(right < 0){
                break;
            }
            left = right;
            while(left >= 0 && s.charAt(left) != ' '){
                left--;
            }
            for(int i = left +1; i <= right; i++){
                sb.append(s.charAt(i));
            }
            sb.append(' ');
            right = left;
        }

        sb.delete(sb.length() -1, sb.length());
        return sb.toString();
    }
}
```





## 5、左旋字符串

### ①、[题目链接](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

 

示例 1：

输入: s = "abcdefg", k = 2
输出: "cdefgab"
示例 2：

输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"

### ②、思路

先遍历后面再遍历前面



### ③、代码

```java
class Solution {
    public String reverseLeftWords(String s, int k) {
        StringBuilder sb = new StringBuilder();
        for(int i = k; i < s.length(); i++){
            sb.append(s.charAt(i));
        }
        for(int i = 0; i < k; i++){
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }
}
```





## 6、* 实现strStr()

### ①、[题目链接](https://leetcode.cn/problems/implement-strstr/)

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

 

示例 1：

输入：haystack = "hello", needle = "ll"
输出：2
示例 2：

输入：haystack = "aaaaa", needle = "bba"
输出：-1


提示：

1 <= haystack.length, needle.length <= 104
haystack 和 needle 仅由小写英文字符组成



### ②、思路

KMP

+ 回溯表
  + 当前俩字符不匹配，模式串需要回溯到的位置
  + 由递推求出回溯表，当前位置之前的字符串前后缀最大长度为k，说明当前位置如果要回溯，应该回溯到第K+1个位置进行比较，因为前K个已经是相等的了。第K+1个的下标为k。故每一个位置的回溯值应当由前面的字符串确定，因此，递推时根据当前的字符串求出。
  + 如果第K+1个位置和当前位置是一样的，那回溯到K+1个位置自然也会匹配不成功，需要再往前。因此，往后哦递推回溯值的时候，如果以当前字符结尾的字符串最大前后缀是K，即后一个位置应该回溯到下标K，如果k下标和后一个位置的字符相等，那应该回溯到k下标位置的回溯值。
  + k代表回溯某个位置的下标，若为0，说明应该和第一个字符比较，如果不相等，k应该赋予一个特殊值，-1。
+ 匹配
  + 不相等就回溯
  + 长度够了就找到第一个

### ③、代码

```java
class Solution {
    public int strStr(String haystack, String needle) {
        char[] hay = haystack.toCharArray();
        char[] nee = needle.toCharArray();
        int hLen = haystack.length();
        int nLen = needle.length();
        int[] nextval = new int[nLen];
        nextval[0] = -1;
        //计算nextval
        int j = 0;
        int k = -1;
        while(j < nLen -1){
            if(k == -1 || nee[k] == nee[j]){
                j++;
                k++;
                if(nee[j] == nee[k]){
                    nextval[j] = nextval[k];
                }
                else{
                    nextval[j] = k;
                }
            }
            else{
                k = nextval[k];
            }
        }
        //匹配
        int i = 0;
        j = 0;
        while(i < hLen){
            if(j == -1 || hay[i] == nee[j]){
                i++;
                j++;
                if(j == nLen){
                    return i -j;
                }
            }
            else{
                j = nextval[j];
            }
        }
        return -1; 
    }
}
```





## 7、* 重复的子字符串

### ①、[题目链接](https://leetcode.cn/problems/repeated-substring-pattern/)

给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 

示例 1:

输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
示例 2:

输入: s = "aba"
输出: false
示例 3:

输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)


提示：

1 <= s.length <= 104
s 由小写英文字母组成

### ②、思路

最大前后缀重叠部分如果是不重叠部分的倍数，则整个字符串可以由某个子串重复构建

### ③、代码

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        char[] str = s.toCharArray();
        int n = s.length();
        int[] next = new int[n +1];
        next[0] = -1;
        //求最大前后缀
        int j = 0;
        int k = -1;
        while(j < n){
            if(k == -1 || str[j] == str[k]){
                j++;
                k++;
                next[j] = k;
            }
            else{
                k = next[k];
            }
        }
        //前后缀重叠长度是不重叠长度地倍数即可推出重复
        return next[n] == 0 ? false : n %(n - next[n]) == 0;
    }
}
```







# 五、队列和栈

## 1、栈实现队列

### ①、[题目链接](https://leetcode.cn/problems/implement-queue-using-stacks/submissions/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。


示例 1：

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false


提示：

1 <= x <= 9
最多调用 100 次 push、pop、peek 和 empty
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）


进阶：

你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。



### ②、思路

双栈即可



### ③、代码

```java
class MyQueue {
    private LinkedList<Integer> list;
    private LinkedList<Integer> help;

    public MyQueue() {
        list = new LinkedList<Integer>();
        help =  new LinkedList<Integer>();
    }
    
    public void push(int x) {
        list.add(x);
    }
    
    public int pop() {
        if(!help.isEmpty()){
            return help.removeLast();
        }
        while(!list.isEmpty()){
            help.add(list.removeLast());
        }
        return help.removeLast();
    }
    
    public int peek() {
        if(!help.isEmpty()){
            return help.getLast();
        }
         while(!list.isEmpty()){
            help.add(list.removeLast());
        }
        return help.getLast();
    }
    
    public boolean empty() {
        return list.isEmpty() && help.isEmpty();
    }
}
```



## 2、队列实现栈

### ①、[题目链接](https://leetcode.cn/problems/implement-stack-using-queues/submissions/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。


注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。


示例：

输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False


提示：

1 <= x <= 9
最多调用100 次 push、pop、top 和 empty
每次调用 pop 和 top 都保证栈不为空


进阶：你能否仅用一个队列来实现栈。



### ②、思路

获取最后一个元素只需将队头拿出放到对位，直到最后一个即可



### ③、代码

```java
class MyStack {
    private LinkedList<Integer> queue;
    private LinkedList<Integer> help;

    public MyStack() {
        queue = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        queue.add(x);
    }
    
    public int pop() {
        int size = queue.size();
        while(--size > 0){
            queue.add(queue.poll());
        }
        return queue.poll();
    }
    
    public int top() {
        int size = queue.size();
        while(--size > 0){
            queue.add(queue.poll());
        }
        int res = queue.poll();
        queue.add(res);
        return res;
    }
    
    public boolean empty() {
        return queue.isEmpty() && help.isEmpty();
    }
}
```



## 3、括号匹配

### ①、[题目链接](https://leetcode.cn/problems/valid-parentheses/	)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。


示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false


提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成



### ②、思路

左括号入栈，右括号匹配



### ③、代码

```java
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<>();
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');
        LinkedList<Character> st = new LinkedList<>();
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == '(' || c == '[' || c == '{'){
                st.add(c);
            }
            else{
                if(st.isEmpty() || c != map.get(st.removeLast())){
                    return false;
                }
            }
        }
        return st.isEmpty();
    }
}
```



## 4、删除字符串相邻重复项

### ①、[题目链接](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。


提示：

1 <= S.length <= 20000
S 仅由小写英文字母组成。



### ②、思路

利用栈得到相邻项，进行比较即可，栈方便删除，而且删除后仍然可以获取相邻项



### ③、代码

```java
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder sb = new StringBuilder();
        LinkedList<Character> st = new LinkedList<>();
        for(int i = 0; i < s.length(); i++){
            char c  = s.charAt(i);
            if(!st.isEmpty() && st.getLast() == c){
                st.removeLast();
            }
            else{
                st.add(c);
            }
        }
        while(!st.isEmpty()){
            sb.append(st.remove());
        }
        return sb.toString();
    }
}
```



## 5、后缀表达式求值

### ①、[题目链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

根据 逆波兰表示法，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

注意 两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

 

示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22


提示：

1 <= tokens.length <= 104
tokens[i] 是一个算符（"+"、"-"、"*" 或 "/"），或是在范围 [-200, 200] 内的一个整数


逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

### ②、思路

操作数入栈，操作符出栈计算，计算结果入栈

### ③、代码

```java
class Solution {
    public int evalRPN(String[] tokens) {
        LinkedList<Integer> st = new LinkedList<>();
        Set<String> set = new HashSet<>();
        set.add("+");
        set.add("-");
        set.add("*");
        set.add("/");
        for(int i = 0; i < tokens.length; i++){
            String cur = tokens[i];
            if(set.contains(cur)){
                int m = st.removeLast();
                int n = st.removeLast();
                int res = 0;
                if(cur.equals("+")){
                    res = m +n;
                }
                else if(cur.equals("-")){
                    res = n -m;
                }
                else if(cur.equals("*")){
                    res = n*m;
                }
                else{
                    res = n/m;
                }
                st.add(res);
            }
            else{
                st.add(Integer.valueOf(cur));
            }
        }
        return st.removeLast();
    }
}
```



## 6、前K个高频元素

### ①、[题目链接](https://leetcode.cn/problems/top-k-frequent-elements/submissions/)

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]


提示：

1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的


进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。



### ②、思路

优先队列大根堆



### ③、代码

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        //计数
        Map<Integer, Integer> map = new HashMap<>();
        for(Integer i : nums){
            map.put(i, map.getOrDefault(i, 0) +1);
        }
        //选大的
        PriorityQueue<Integer> pq =new PriorityQueue<>(k, (a,b)->map.get(b)- map.get(a));
        for(Integer key : map.keySet()){
            pq.add(key);
        }
        //保存答案
        int[] res = new int[k];
        for(int i = 0; i < k; i++){
            res[i] = pq.remove();
        }
        return res;
    }
}
```



## 7、* 滑动窗口最大值

### ①、[题目链接](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length



### ②、思路

双端队列，降序排列

新元素从队尾开始整顿队列，在之后的遍历中，队列的元素肯定会和新元素一个窗口，如果新元素比它们大，那它们就没有任何机会了，如果比它们小，未必没有机会，因为后边的元素还不知道

达到窗口大小便开始取数，如果队首还在范围内，就是最大的，不然就是次队首，三首



### ③、代码

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        LinkedList<Integer> dq = new LinkedList<>();
        int[] res = new int[nums.length -k +1];
        int p = 0;  int l = 0; int r = 0;
        //遍历数组
        while(r < nums.length){
            //新元素从队尾开始整顿队列
            while(!dq.isEmpty() && nums[dq.getLast()] < nums[r]){
                dq.removeLast();
            }
            dq.addLast(r++);
            //达到窗口大小便开始取数
            if(r -l == k){
                while(!dq.isEmpty() && dq.getFirst() < l){
                    dq.removeFirst();
                }
                res[p++] = nums[dq.getFirst()];
                l++;
            }
        }
        return res;
    }
}
```
