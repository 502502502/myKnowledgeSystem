[TOC]



# 六、二叉树

## 1、二叉树前序遍历

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

 

示例 1：


输入：root = [1,null,2,3]
输出：[1,2,3]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]
示例 4：


输入：root = [1,2]
输出：[1,2]
示例 5：


输入：root = [1,null,2]
输出：[1,2]


提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100


进阶：递归算法很简单，你可以通过迭代算法完成吗？



### ②、思路

递归：根左右

迭代：栈，先进后出，出栈处理元素，再让右孩子进去，再让左孩子进去，这样下一次就能先处理左孩子

标记：出栈结点为null，下一个出栈的进行处理，否则按照右左根的顺序依次入栈

### ③、代码

递归

```java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        preOrder(root);
        return res;
    }
    public void preOrder(TreeNode r){
        if(r == null){
            return;
        }
        res.add(r.val);
        preOrder(r.left);
        preOrder(r.right);
    }
}
```

迭代

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        if(root != null){
            st.add(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            res.add(cur.val);
            if(cur.right != null){
                st.addLast(cur.right);
            }
            if(cur.left != null){
                st.addLast(cur.left);
            }
        }
        return res;
    }
}
```



标记

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                //*******************
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                if(cur.left != null){
                    st.addLast(cur.left);
                }
                st.addLast(cur);
                st.add(null);
                //*******************
            }
            else{
                res.add(st.removeLast().val);
            }
        }
        return res;
    }
}
```



## 2、二叉树中序遍历

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

 

示例 1：


输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]


提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100


进阶: 递归算法很简单，你可以通过迭代算法完成吗？



### ②、思路

递归：左根右

迭代：左边一直入栈，对于每一个出栈元素，处理自身，右孩子入栈，然后右孩子往左，一直入栈

标记：出栈结点为null，下一个出栈的进行处理，否则按照右根左的顺序依次入栈

### ③、代码

递归

```java
class Solution {
    private List<Integer> res = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root != null){
            inOrder(root);
        }
        return res;
    }
    public void inOrder(TreeNode r){
        if(r.left != null){
            inOrder(r.left);
        }
        res.add(r.val);
        if(r.right != null){
            inOrder(r.right);
        }
    }
}
```

迭代

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        //直左
        TreeNode cur = root;
        while(cur != null){
            st.addLast(cur);
            cur = cur.left;
        }
        while(!st.isEmpty()){
            cur = st.removeLast();
            res.add(cur.val);
            //点右直左
            if(cur.right != null){
                st.addLast(cur.right);
                cur = cur.right.left;
                while(cur != null){
                    st.addLast(cur);
                    cur = cur.left;
                }
            }
        }
        return res;
    }
}
```

标记

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                //*************************
                if(cur.right != null){
                    st.addLast(cur.right);
                }   
                st.addLast(cur);
                st.addLast(null);
                if(cur.left != null){
                    st.addLast(cur.left);
                }
                // *************************
            }
            else{
                res.add(st.removeLast().val);
            }
        }
        return res;
    }
}
```



## 3、二叉树后序遍历

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

 

示例 1：


输入：root = [1,null,2,3]
输出：[3,2,1]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]


提示：

树中节点的数目在范围 [0, 100] 内
-100 <= Node.val <= 100


进阶：递归算法很简单，你可以通过迭代算法完成吗？



### ②、思路

递归：左右根

迭代：栈，先进后出，出栈处理元素，再让左孩子进去，再让右孩子进去，这样下一次就能先处理右孩子，即根右左，再翻过来，就是左右根

标记：出栈结点为null，下一个出栈的进行处理，否则按照根右左的顺序依次入栈

### ③、代码

递归

```java
class Solution {
    private List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root != null){
            postOrder(root);
        }
        return res;
    }
    public void postOrder(TreeNode r){
        if(r.left != null){
            postOrder(r.left);
        }
        if(r.right != null){
            postOrder(r.right);
        }
        res.add(r.val);
    }
}
```

迭代

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        LinkedList<Integer> res = new LinkedList();
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            res.addFirst(cur.val);
            if(cur.left != null){
                st.addLast(cur.left);
            }
            if(cur.right != null){
                st.addLast(cur.right);
            }
        }
        return res;
    }
}
```

统一

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                //*****************
                st.addLast(cur);
                st.add(null);
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                if(cur.left != null){
                    st.addLast(cur.left);
                }
                //********************
            }
            else{
                res.add(st.removeLast().val);
            }
        }
        return res;
    }
}
```





## 4、二叉树层序遍历

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
示例 2：

输入：root = [1]
输出：[[1]]
示例 3：

输入：root = []
输出：[]


提示：

树中节点数目在范围 [0, 2000] 内
-1000 <= Node.val <= 1000



### ②、思路

利用队列先进先出，对于每一层的结点，处理当前结点，放进孩子结点



### ③、代码

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> temp = new ArrayList<>();
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                temp.add(cur.val);
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            res.add(temp);
        }
        return res;
    }
}
```



## 5、二叉树层序遍历Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
示例 2：

输入：root = [1]
输出：[[1]]
示例 3：

输入：root = []
输出：[]


提示：

树中节点数目在范围 [0, 2000] 内
-1000 <= Node.val <= 1000



### ②、思路

与层序遍历一样，只不过每一层的输出按照头插法进行插入到答案

### ③、代码

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        LinkedList<List<Integer>> res =  new LinkedList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> temp = new ArrayList<>();
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                temp.add(cur.val);
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            res.addFirst(temp);
        }
        return res;
    }
}
```

## 6、二叉树右视图

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

示例 1:



输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
示例 2:

输入: [1,null,3]
输出: [1,3]
示例 3:

输入: []
输出: []


提示:

二叉树的节点个数的范围是 [0,100]
-100 <= Node.val <= 100 



### ②、思路

层序遍历，每层输出最后一个结点



### ③、代码

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            TreeNode cur;
            while(--size > 0){
                cur = q.removeFirst();
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            cur = q.removeFirst();
            res.add(cur.val);
            if(cur.left != null){
                q.addLast(cur.left);
            }
            if(cur.right != null){
                q.addLast(cur.right);
            }
        }
        return res;
    }
}
```



## 7、二叉树层平均值

### ①、[题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。

 

示例 1：



输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
示例 2:



输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]


提示：

树中节点数量在 [1, 104] 范围内
-231 <= Node.val <= 231 - 1



### ②、思路

层序遍历，求和，除以层结点数即可

### ③、代码

```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        LinkedList<TreeNode> q = new LinkedList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            int s = size;
            double sum = 0.0;
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                sum += cur.val;
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            res.add(sum/s);
        }
        return res;
    }
}
```



## 8、N叉树层序遍历

### ①、[题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

 

示例 1：



输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
示例 2：



输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]


提示：

树的高度不会超过 1000
树的节点总数在 [0, 10^4] 之间



### ②、思路

队列存储每层结点，输出单层，存储下一层



### ③、代码

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        LinkedList<Node> q = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> temp = new ArrayList<>();
            while(size-- > 0){
                Node cur = q.removeFirst();
                temp.add(cur.val);
                for(Node n : cur.children){
                    q.addLast(n);
                }
            }
            res.add(temp);
        }
        return res;
    }
}
```



## 9、树行最大值

### ①、[题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。

 

示例1：



输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
示例2：

输入: root = [1,2,3]
输出: [1,3]


提示：

二叉树的节点个数的范围是 [0,104]
-231 <= Node.val <= 231 - 1



### ②、思路

层序遍历，每层找最大值

### ③、代码

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> q = new LinkedList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            int max = Integer.MIN_VALUE;
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                max = max > cur.val ? max : cur.val;
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            res.add(max);
        }
        return res;
    }
}
```



## 10、[填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

### ①、[题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 

示例 1：



输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
示例 2:

输入：root = []
输出：[]


提示：

树中节点的数量在 [0, 212 - 1] 范围内
-1000 <= node.val <= 1000


进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。



### ②、思路

层序遍历

### ③、代码

```java
class Solution {
    public Node connect(Node root) {
        LinkedList<Node> q = new LinkedList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            Node cur;
            while(--size > 0){
                cur = q.removeFirst();
                cur.next = q.getFirst();
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            cur = q.removeFirst();
            cur.next = null;
            if(cur.left != null){
                q.addLast(cur.left);
            }
            if(cur.right != null){
                q.addLast(cur.right);
            }
        }
        return root;
    }
}
```

## 11、[填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### ①、[题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

给定一个二叉树

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 

进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。



### ②、思路

同上

### ③、代码

```java
class Solution {
    public Node connect(Node root) {
        LinkedList<Node> q = new LinkedList<>();
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            Node cur;
            while(--size > 0){
                cur = q.removeFirst();
                cur.next = q.getFirst();
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            cur = q.removeFirst();
            cur.next = null;
            if(cur.left != null){
                q.addLast(cur.left);
            }
            if(cur.right != null){
                q.addLast(cur.right);
            }
        }
        return root;
    }
}
```



## 12、二叉树最大深度

### ①、[题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。



### ②、思路

层序遍历层数

### ③、代码

```java
class Solution {
    public int maxDepth(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        int res = 0;
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            int size = q.size();
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            res++;
        }
        return res;
    }
}
```



## 13、二叉树最小深度

### ①、[题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：2
示例 2：

输入：root = [2,null,3,null,4,null,5,null,6]
输出：5


提示：

树中节点数的范围在 [0, 105] 内
-1000 <= Node.val <= 1000



### ②、思路

层序遍历，遇到叶子中止

### ③、代码

```java
class Solution {
    public int minDepth(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        int res = 0;
        boolean flag = false;
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty() && !flag){
            int size = q.size();
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                if(cur.left == null && cur.right == null){
                    flag = true;
                    break;
                }
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
            }
            res++;
        }
        return res;
    }
}
```



## 14、翻转二叉树

### ①、[题目链接](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

 

示例 1：



输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：



输入：root = [2,1,3]
输出：[2,3,1]
示例 3：

输入：root = []
输出：[]


提示：

树中节点数目范围在 [0, 100] 内
-100 <= Node.val <= 100



### ②、思路

递归：翻转左子树，翻转右子树，交换左右孩子

迭代：遍历结点，每个结点负责交换自己的孩子，前中后不重要

### ③、代码

递归

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return root;
        }
        root.left = invertTree(root.left);
        root.right = invertTree(root.right);
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        return root;
    }
}
```

迭代

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                if(cur.left != null){
                    st.addLast(cur.left);
                }
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                st.addLast(cur);
                st.addLast(null);
            }
            else{
                cur = st.removeLast();
                TreeNode temp = cur.left;
                cur.left = cur.right;
                cur.right = temp;
            }
        }
        return root;
    }
}
```



## 15、对称二叉树

### ①、[题目链接](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 root ， 检查它是否轴对称。

 

示例 1：


输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：


输入：root = [1,2,2,null,3,null,3]
输出：false


提示：

树中节点数目在范围 [1, 1000] 内
-100 <= Node.val <= 100


进阶：你可以运用递归和迭代两种方法解决这个问题吗？



### ②、思路

递归：由于根节点左右对称并不要求子树左右对称，不具备递归条件，故使用辅助函数，比较应该对称的两个子树

迭代：层序遍历，一次性出队两个应该对称的结点

### ③、代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return help(root.left, root.right);
    }
    public boolean help(TreeNode l, TreeNode r){
        if(l == null && r == null){
            return true;
        }
        if(l == null || r == null){
            return false;
        }
        if(l.val != r.val){
            return false;
        }
        return help(l.left, r.right) && help(l.right, r.left);
    }
}
```

迭代

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        q.addLast(root.left);
        q.addLast(root.right);
        while(!q.isEmpty()){
            int size = q.size();
            while(size-- > 0){
                size--;
                TreeNode l = q.removeFirst();
                TreeNode r = q.removeFirst();
                if(l == null && r == null){
                    break;
                }
                if(l == null || r == null){
                    return false;
                }
                if(l.val != r.val){
                    return false;
                }
                q.addLast(l.left);
                q.addLast(r.right);
                q.addLast(l.right);
                q.addLast(r.left);
            }
        }
        return true;
    }
}
```



## 16、相同的树

### ①、[题目链接](https://leetcode.cn/problems/same-tree/)

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 

示例 1：


输入：p = [1,2,3], q = [1,2,3]
输出：true
示例 2：


输入：p = [1,2], q = [1,null,2]
输出：false
示例 3：


输入：p = [1,2,1], q = [1,1,2]
输出：false


提示：

两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104



### ②、思路

递归：当前两结点相等，双方的左右子树分别相同

迭代：层序遍历，每次拿出应该相等的两个结点，依次放入应该相等的子节点

### ③、代码

递归

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null){
            return true;
        }
        if(p == null || q == null){
            return false;
        }
        if(p.val != q.val){
            return false;
        }
        return  isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

迭代

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.addLast(p);
        queue.addLast(q);
        while(!queue.isEmpty()){
            int size = queue.size();
            TreeNode l;
            TreeNode r;
            while(size-- > 0){
                size--;
                l = queue.removeFirst();
                r = queue.removeFirst();
                if(l == null && r == null){
                    continue;
                }
                if(l == null || r == null){
                    return false;
                }
                if(l.val != r.val){
                    return false;
                }
                queue.addLast(l.left);
                queue.addLast(r.left);
                queue.addLast(l.right);
                queue.addLast(r.right);
            }
        }
        return true;
    }
}
```



## 17、另一颗树的子树

### ①、[题目链接](https://leetcode.cn/problems/subtree-of-another-tree/)

给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。

二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。

 

示例 1：


输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
示例 2：


输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false


提示：

root 树上的节点数量范围是 [1, 2000]
subRoot 树上的节点数量范围是 [1, 1000]
-104 <= root.val <= 104
-104 <= subRoot.val <= 104



### ②、思路

递归：若当前树与目标树不相同，则看左右子树是否包含目标结点

迭代：遍历每个结点，判断两树是否相同；判断相同使用层序遍历，应该相等的结点一起入栈，一起出栈

### ③、代码

递归

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if(help(root, subRoot)){
            return true;
        }
        boolean l = false;
        boolean r = false;
        if(root.left != null){
            l = isSubtree(root.left, subRoot);
        }
        if(root.right != null){
            r = isSubtree(root.right, subRoot);
        }
        return  l || r;
    }
    public boolean help(TreeNode p, TreeNode q){
         if(p == null && q == null){
            return true;
        }
        if(p == null || q == null){
            return false;
        }
        if(p.val != q.val){
            return false;
        }
        return  help(p.left, q.left) && help(p.right, q.right);
    }
}
```

迭代

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        LinkedList<TreeNode> st = new LinkedList<>();
        st.addLast(root);
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                if(cur.left != null){
                    st.addLast(cur.left);
                }
                st.addLast(cur);
                st.addLast(null);
            }
            else{
                cur = st.removeLast();
                if(help(cur, subRoot)){
                    return true;
                }
            }
        }
        return false;
    }
    public boolean help(TreeNode p, TreeNode q){
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.addLast(p);
        queue.addLast(q);
        while(!queue.isEmpty()){
            int size = queue.size();
            TreeNode l;
            TreeNode r;
            while(size-- > 0){
                size--;
                l = queue.removeFirst();
                r = queue.removeFirst();
                if(l == null && r == null){
                    continue;
                }
                if(l == null || r == null){
                    return false;
                }
                if(l.val != r.val){
                    return false;
                }
                queue.addLast(l.left);
                queue.addLast(r.left);
                queue.addLast(l.right);
                queue.addLast(r.right);
            }
        }
        return true;
    }
}
```



## 18、N叉树最大深度

### ①、[题目链接](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

 

示例 1：



输入：root = [1,null,3,2,4,null,5,6]
输出：3
示例 2：



输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5


提示：

树的深度不会超过 1000 。
树的节点数目位于 [0, 104] 之间。



### ②、思路

层序遍历

### ③、代码

```java
class Solution {
    public int maxDepth(Node root) {
        LinkedList<Node> q = new LinkedList<>();
        int res = 0;
        if(root != null){
            q.addLast(root);
        }
        while(!q.isEmpty()){
            res++;
            int size = q.size();
            while(size-- >  0){
                Node cur = q.removeFirst();
                for(Node n : cur.children){
                    q.addLast(n);
                }
            }
        }
        return res;
    }
}
```



## 19、* 完全二叉树节点个数

### ①、[题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)

给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

 

示例 1：


输入：root = [1,2,3,4,5,6]
输出：6
示例 2：

输入：root = []
输出：0
示例 3：

输入：root = [1]
输出：1


提示：

树中节点的数目范围是[0, 5 * 104]
0 <= Node.val <= 5 * 104
题目数据保证输入的树是 完全二叉树


进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？



### ②、思路

暴力：遍历

递归：左子树结点数加右子树结点数加1，左右子树高度相等，左子树一定满，否则右子树一定是满的

迭代：自顶向下选择代替者，代替者为可能不是满二叉树的子树

### ③、代码

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        int dl = getDepth(root.left);
        int dr = getDepth(root.right);
        if(dl == dr){
            return (1<<dl) + countNodes(root.right);
        }
        else{
            return (1<<dr) + countNodes(root.left);
        }
    }
    public int getDepth(TreeNode root){
        int res = 0;
        while(root != null){
            res++;
            root = root.left;
        }
        return res;
    }
}
```

迭代

```java
class Solution {
    public int countNodes(TreeNode root) {
        int res = 0;
        TreeNode cur = root;
        while(cur != null){
            int l = getDepth(cur.left);
            int r = getDepth(cur.right);
            if(l == r){
                cur = cur.right;
                res += 1<<l;
            }
            else{
                cur = cur.left;
                res += 1<<r;
            }
        }
        return res;
    }
    public int getDepth(TreeNode root){
        int res = 0;
        while(root != null){
            res++;
            root = root.left;
        }
        return res;
    }
}
```



## 20、平衡二叉树

### ①、[题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：true
示例 2：


输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
示例 3：

输入：root = []
输出：true


提示：

树中的节点数在范围 [0, 5000] 内
-104 <= Node.val <= 104



### ②、思路

递归：先看左右子树是不是平衡树，如果都是，那就看左右子树的高度差是否大于1

迭代：由于需要子树的高度，按照左右根遍历；并将结果保存到结点中以供查询

### ③、代码

递归

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return check(root);
    }
    public boolean check(TreeNode root){
        if(root == null){
            return true;
        }
        if(!check(root.left) ||  !check(root.right)){
            return false;
        }
        return Math.abs(help(root.left) -help(root.right)) < 2;
    }
    public int help(TreeNode cur){
        if(cur == null){
            return 0;
        }
        return Math.max(help(cur.left), help(cur.right)) +1;
    }
}
```

迭代

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.getLast();
            if(cur != null){
                st.addLast(null);
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                if(cur.left != null){
                    st.addLast(cur.left);
                }
            }
            else{
                st.removeLast();
                cur = st.removeLast();
                int l = cur.left == null ? 0 : cur.left.val;
                int r = cur.right == null ? 0 : cur.right.val;
                if(l -r > 1 || r -l > 1){
                    return false;
                }
                cur.val = Math.max(l,r) +1;
            }
        }
        return true;
    }
}
```



## 21、二叉树所有路径

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-paths/)

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。


示例 1：


输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
示例 2：

输入：root = [1]
输出：["1"]


提示：

树中节点的数目在范围 [1, 100] 内
-100 <= Node.val <= 100



### ②、思路

递归 + 回溯，碰到叶子结点输出

### ③、代码

```java
class Solution {
    private List<String> res = new ArrayList<>();
    private StringBuilder sb = new StringBuilder();
    public List<String> binaryTreePaths(TreeNode root) {
        sb.append(root.val);
        if(root.left == null && root.right == null){
            res.add(sb.toString());
            return res;
        }
        if(root.left != null){
            back(root.left);
        }
        if(root.right != null){
            back(root.right);
        }
        return res;
    }
    public void back(TreeNode cur){
        sb.append("->");
        sb.append(cur.val);
        int len= String.valueOf(cur.val).length();
        if(cur.left == null && cur.right == null){
            res.add(sb.toString());
            sb.delete(sb.length() -(len +2), sb.length());
            return ;
        }
        if(cur.left != null){
            back(cur.left);
        }
        if(cur.right != null){
            back(cur.right);
        }
        sb.delete(sb.length() -(len +2), sb.length());
    }
}
```



## 22、左叶子之和

### ①、[题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)

给定二叉树的根节点 root ，返回所有左叶子之和。

 

示例 1：



输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
示例 2:

输入: root = [1]
输出: 0


提示:

节点数在 [1, 1000] 范围内
-1000 <= Node.val <= 1000




### ②、思路

迭代：判断是不是左孩子需要父节点，因此选择根左右的先序遍历并保存前驱结点，当满足叶子和左孩子时累加

### ③、代码

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        LinkedList<TreeNode> st = new LinkedList<>();
        TreeNode pre = null;
        st.addLast(root);
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur.left == null && cur.right == null && pre!= null && pre.left == cur){
                sum += cur.val;
            }
            if(cur.right != null){
                st.addLast(cur.right);
            }
            if(cur.left != null){
                st.addLast(cur.left);
            }
            pre = cur;
        }
        return sum;
    }
}
```



## 23、树左下角的值

### ①、[题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

假设二叉树中至少有一个节点。

 

示例 1:



输入: root = [2,1,3]
输出: 1
示例 2:



输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7


提示:

二叉树的节点个数的范围是 [1,104]
-231 <= Node.val <= 231 - 1 



### ②、思路

迭代：层序遍历，保存每层第一个结点



### ③、代码

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        LinkedList<TreeNode> q = new LinkedList<>();
        q.addLast(root);
        while(!q.isEmpty()){
            int size = q.size();
            TreeNode l = q.getFirst();
            while(size-- > 0){
                TreeNode cur = q.removeFirst();
                if(cur.left != null){
                    q.addLast(cur.left);
                }
                if(cur.right != null){
                    q.addLast(cur.right);
                }
                if(q.isEmpty()){
                    return l.val;
                }
            }
        }
        return 0;
    }
}
```



## 24、路径求和

### ①、[题目链接](https://leetcode.cn/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

 

示例 1：


输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
示例 2：


输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
示例 3：

输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。


提示：

树中节点的数目在范围 [0, 5000] 内
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000



### ②、思路

递归 + 回溯，找到符合的路径中止递归

### ③、代码

```java
class Solution {
    private boolean res = false;
    private int tar;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        tar = targetSum;
        if(root != null){
            back(0, root);
        }
        return res;
    }
    public void back(int sum, TreeNode cur){
        if(cur.left == null && cur.right == null){
            if(sum + cur.val == tar){
                res = true;
            }
            return;
        }
        if(cur.left != null){
            back(sum + cur.val, cur.left);
        }
        if(!res && cur.right != null){
            back(sum + cur.val, cur.right);
        }
    }
}
```



## 25、* 从中序与后序遍历序列构造二叉树

### ①、[题目链接](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

 

示例 1:


输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
示例 2:

输入：inorder = [-1], postorder = [-1]
输出：[-1]


提示:

1 <= inorder.length <= 3000
postorder.length == inorder.length
-3000 <= inorder[i], postorder[i] <= 3000
inorder 和 postorder 都由 不同 的值组成
postorder 中每一个值都在 inorder 中
inorder 保证是树的中序遍历
postorder 保证是树的后序遍历



### ②、思路

区间界定，找根，找左子树范围，找右子树范围



### ③、代码

```java
class Solution {
    private int[] in;
    private int[] po;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        in = inorder;
        po = postorder;
        return build(0, inorder.length -1, 0, postorder.length -1);
    }
    public TreeNode build(int il, int ir, int pl, int pr){
        for(int i = il; i <= ir; i++){
            if(in[i] == po[pr]){
                TreeNode root = new TreeNode(po[pr]);
                root.left = build(il, i -1, pl, i -1 -il +pl);
                root.right = build(i +1, ir, i-il +pl, pr -1);
                return root;
            }
        }
        return null;
    }
}
```



## 26、* 最大二叉树

### ①、[题目链接](https://leetcode.cn/problems/maximum-binary-tree/)

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

创建一个根节点，其值为 nums 中的最大值。
递归地在最大值 左边 的 子数组前缀上 构建左子树。
递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。

 

示例 1：


输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
示例 2：


输入：nums = [3,2,1]
输出：[3,null,2,null,1]


提示：

1 <= nums.length <= 1000
0 <= nums[i] <= 1000
nums 中的所有整数 互不相同



### ②、思路

从前往后遍历，每个结点要做两件事儿，

一：确定自己是左结点还是右结点；

二：确定自己的一个孩子是谁；

由于遍历到自己的时候不知道后边结点的大小情况，因此需要入栈；

之前比自己小的最大结点一定是自己的左孩子，完成二；

离自己最近且比自己大的结点的右孩子一定是自己，完成一；





### ③、代码

```java
class Solution {
    public TreeNode[] st = new TreeNode[1001];
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        int top = 0;
        for(int v : nums){
            TreeNode cur = new TreeNode(v);
            while(top > 0 && st[top -1].val < v){
                cur.left = st[--top];
            }
            if(top > 0){
                st[top -1].right = cur;
            }
            st[top++] = cur;
        }
        return st[0];
    }
}
```



## 27、二叉搜索树搜索

### ①、[题目链接](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

 

示例 1:



输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
示例 2:


输入：root = [4,2,7,1,3], val = 5
输出：[]


提示：

数中节点数在 [1, 5000] 范围内
1 <= Node.val <= 107
root 是二叉搜索树
1 <= val <= 107



### ②、思路



### ③、代码

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null || root.val == val){
            return root;
        }
        else if(root.val < val){
            return searchBST(root.right, val);
        }
        return searchBST(root.left, val);
    }
}
```



## 28、验证二叉搜索树

### ①、[题目链接](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。


示例 1：


输入：root = [2,1,3]
输出：true
示例 2：


输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。


提示：

树中节点数目范围在[1, 104] 内
-231 <= Node.val <= 231 - 1

### ②、思路

中序遍历单调增

### ③、代码

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        st.addLast(root);
        TreeNode pre = null;
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                st.addLast(cur);
                st.addLast(null);
                if(cur.left != null){
                    st.addLast(cur.left);
                }
            }
            else{
                cur = st.removeLast();
                if(pre != null){
                    if(pre.val >= cur.val){
                        return false;
                    }
                }
                pre = cur;
            }
        }
        return true;
    }
}
```



## 29、二叉搜索树最小差值

### ①、[题目链接](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

差值是一个正数，其数值等于两值之差的绝对值。

 

示例 1：


输入：root = [4,2,6,1,3]
输出：1
示例 2：


输入：root = [1,0,48,null,null,12,49]
输出：1


提示：

树中节点的数目范围是 [2, 104]
0 <= Node.val <= 105




### ②、思路

中序遍历

### ③、代码

```java
class Solution {
    public int getMinimumDifference(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        int min = Integer.MAX_VALUE;
        TreeNode pre = null;
        st.addLast(root);
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                st.addLast(cur);
                st.addLast(null);
                if(cur.left != null){
                    st.addLast(cur.left);
                }
            }
            else{
                cur = st.removeLast();
                if(pre != null){
                    min = Math.min(min, Math.abs(cur.val -pre.val));
                    if(min == 1){
                        return 1;
                    }
                }
                pre = cur;
            }
        }
        return min;
    }
}
```



## 30、* 二叉搜索树中的众数

### ①、[题目链接](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。

假定 BST 满足如下定义：

结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树


示例 1：


输入：root = [1,null,2,2]
输出：[2]
示例 2：

输入：root = [0]
输出：[0]


提示：

树中节点的数目在范围 [1, 104] 内
-105 <= Node.val <= 105


进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）



### ②、思路

先序遍历

计数的同时判断是不是众数，而不是计数完一个数字再判断，这样效率很低，而且循环结束后还有额外判断最后一个数

### ③、代码

递归

```java
class Solution {
    private ArrayList<Integer> res = new ArrayList<>();
    private TreeNode pre = null;
    private int max = 0;
    private int curc = 0;
    public int[] findMode(TreeNode root) {
        inorder(root);
        int[] arr = new int[res.size()];
        int i = 0;
        for(int k : res){
            arr[i++] = k;
        }
        return arr;
    }
    public void inorder(TreeNode cur){
        if(cur == null){
            return;
        }
        inorder(cur.left);
        if(pre != null && pre.val != cur.val){
            curc = 0;
        }
        pre = cur;
        curc++;
        if(curc == max){
            res.add(cur.val);
        }
        else if(curc > max){
            max = curc;
            res.clear();
            res.add(cur.val);
        }
        inorder(cur.right);
    }
}
```

迭代

```java
class Solution {
    public int[] findMode(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        List<Integer> res = new ArrayList();
        int curc = 0;
        int max = 0;
        st.addLast(root);
        TreeNode pre = null;
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                if(cur.right != null){
                    st.addLast(cur.right);
                }
                st.addLast(cur);
                st.addLast(null);
                if(cur.left != null){
                    st.addLast(cur.left);
                }
            }
            else{
                cur = st.removeLast();
                if(pre != null && pre.val != cur.val){
                    curc = 0;
                }
                pre = cur;
                curc++;
                if(curc == max){
                    res.add(cur.val);
                }
                else if(curc > max){
                    max = curc;
                    res.clear();
                    res.add(cur.val);
                }
            }
        }
        int[] arr = new int[res.size()];
        int i = 0;
        for(int k : res){
            arr[i++] = k;
        }
        return arr;
    }
}
```



## 31、* 最近公共组先

### ①、[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

 

示例 1：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1


提示：

树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。

### ②、思路

分治，在左右子树分别找最近公共祖先，如果两边都找到了，说明当前结点才是公共祖先

如果左边没有找到，那就是右边的祖先，如果右边没有找到，就是左边的祖先；

当遍历到的结点是p或者q，认为当前结点是祖先，如果假设成立，往下找肯定能找到另一个，如果假设不成立，父节点的另一边也会有一个祖先，那么认为父节点才是祖先。

### ③、代码

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == q || root == p){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null){
            return right;
        }
        if(right == null){
            return left;
        }
        return root;
    }
}
```



## 32、二叉搜索树最近公共祖先

### ①、[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]



 

示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。


说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。



### ②、思路

递归，当前结点出现其中一个，返回当前结点，若在两边，返回当前结点，都比当前结点大，去右边找，否则去左边找



### ③、代码

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == q || root == p){
            return root;
        }
        if(root.val > p.val && root.val < q.val || root.val > q.val && root.val < p.val){
            return root;
        }
        if(root.val < q.val && root.val < q.val){
            return lowestCommonAncestor(root.right, p, q);
        }
        return lowestCommonAncestor(root.left, p, q);
    }
}
```



## 33、二叉搜索树插入操作

### ①、[题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

 

示例 1：


输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：

示例 2：

输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
示例 3：

输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]


提示：

树中的节点数将在 [0, 104]的范围内。
-108 <= Node.val <= 108
所有值 Node.val 是 独一无二 的。
-108 <= val <= 108
保证 val 在原始BST中不存在。



### ②、思路

相当于找到指定结点，直到外界点位置，在此插入即可



### ③、代码

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        TreeNode node = new TreeNode(val);
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur != null){
            pre = cur;
            if(cur.val < val){
                cur = cur.right;
            }
            else{
                cur = cur.left;
            }
        }
        if(pre == null){
            return node;
        }
        if(pre.val > val){
            pre.left = node;
        }
        else{
            pre.right = node;
        }
        return root;
    }
}
```

## 34、删除二叉搜索树的结点

### ①、[题目链接](https://leetcode.cn/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。


示例 1:



输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。


示例 2:

输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
示例 3:

输入: root = [], key = 0
输出: []


提示:

节点数的范围 [0, 104].
-105 <= Node.val <= 105
节点值唯一
root 是合法的二叉搜索树
-105 <= key <= 105


进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。



### ②、思路

如果要删除的结点是叶子或者独子，删除会很容易，直接独子上位即可；

故先找到待删除结点，然后找到替代结点，交换值，再递归删除替代结点即可

### ③、代码

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null){
            return null;
        }
        if(root.val < key){
            root.right = deleteNode(root.right, key);
        }
        else if(root.val > key){
            root.left = deleteNode(root.left, key);
        }
        else{
            if(root.left == null){
                root = root.right;
            }
            else if(root.right == null){
                root = root.left;
            }
            else{
                TreeNode cur = root.right;
                while(cur.left != null){
                    cur = cur.left;
                }
                root.val = cur.val;
                root.right = deleteNode(root.right, cur.val);
            }
        }
        return root;
    }
}
```



## 35、修剪二叉搜索树

### ①、[题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/)

给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

 

示例 1：


输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
示例 2：


输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]


提示：

树中节点数在范围 [1, 104] 内
0 <= Node.val <= 104
树中每个节点的值都是 唯一 的
题目数据保证输入是一棵有效的二叉搜索树
0 <= low <= high <= 104



### ②、思路

递归

如果当前结点不满足，还有一边的子树可能是满足的，把修剪过的子节点上位即可；

如果当前结点满足，那就把两个子树都修剪一遍；



### ③、代码

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null ){
            return null;
        }
        if(root.val < low){
            root = trimBST(root.right, low, high);
        }
        else if(root.val > high){
            root = trimBST(root.left, low, high);
        }
        if(root == null){
            return null;
        }
        if(root.val >= low){
            root.left = trimBST(root.left, low, high);
        }
        if(root.val <= high){
            root.right = trimBST(root.right, low, high);
        }
        return root;
    }
}
```



## 36、有序数组转二叉搜索

### ①、[题目链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

示例 1：


输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：

示例 2：


输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。


提示：

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 按 严格递增 顺序排列

### ②、思路

递归：每次选取中间元素为根，左边区间左子树，右边区间右子树

### ③、代码

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums, 0, nums.length -1);
    }
    public TreeNode build(int[] nums, int l, int r){
        if(l > r){
            return null;
        }
        int mid = l + ((r -l)>>1);
        TreeNode node = new TreeNode(nums[mid]);
        node.left = build(nums, l, mid -1);
        node.right = build(nums, mid +1, r);
        return node;
    }
}
```



## 37、二叉搜索树转累加树

### ①、[题目链接](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

 

示例 1：



输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
示例 2：

输入：root = [0,null,1]
输出：[1,null,1]
示例 3：

输入：root = [1,0,2]
输出：[3,3,2]
示例 4：

输入：root = [3,2,4,1]
输出：[7,9,4,10]


提示：

树中的节点数介于 0 和 104 之间。
每个节点的值介于 -104 和 104 之间。
树中的所有值 互不相同 。
给定的树为二叉搜索树。



### ②、思路

逆中序遍历累加即可

### ③、代码

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        LinkedList<TreeNode> st = new LinkedList<>();
        int sum = 0;
        if(root != null){
            st.addLast(root);
        }
        while(!st.isEmpty()){
            TreeNode cur = st.removeLast();
            if(cur != null){
                if(cur.left != null){
                    st.addLast(cur.left);
                }
                st.addLast(cur);
                st.addLast(null);
                if(cur.right != null){
                    st.addLast(cur.right);
                }
            }
            else{
                cur = st.removeLast();
                sum += cur.val;
                cur.val = sum;
            }
        }
        return root;
    }
}
```

