

# 十、单调栈

## 1、每日温度

### ①、[题目链接](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

 

示例 1:

输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:

输入: temperatures = [30,60,90]
输出: [1,1,0]


提示：

1 <= temperatures.length <= 105
30 <= temperatures[i] <= 100



### ②、思路

当今日气温比昨天的要大，就应该把昨天的答案处理了，否则今天和昨天都是待处理状态；

即，待处理队列维持递减序列，当出现大元素，从末尾往前，更新能更新到的元素的答案，然后把自己放入待处理队列



### ③、代码

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        LinkedList<Integer> st = new LinkedList<>();
        for(int i = 0; i < temperatures.length; i++){
            int cur = temperatures[i];
            //单调进栈
            if(st.isEmpty() || temperatures[st.getLast()] >= cur){
                st.add(i);
            }
            //不单调处理
            else{
                while(!st.isEmpty() && temperatures[st.getLast()] < cur){
                    int pop = st.removeLast();
                    temperatures[pop] = i -pop;
                }
                st.add(i);
            }
        }
        //尾处理
        while(!st.isEmpty()){
            temperatures[st.remove()] = 0;
        }
        return temperatures;
    }
}
```



## 2、下一个更大元素 I

### ①、[题目链接](https://leetcode.cn/problems/next-greater-element-i/)

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

 

示例 1：

输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
示例 2：

输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。


提示：

1 <= nums1.length <= nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 104
nums1和nums2中所有整数 互不相同
nums1 中的所有整数同样出现在 nums2 中


进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？



### ②、思路

单调栈

由于不在同一个数组，用map提前保存待处理元素



### ③、代码

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums1.length; i++){
            map.put(nums1[i], i);
        }
        LinkedList<Integer> st = new LinkedList<>();
        for(int i = 0; i < nums2.length; i++){
            //单调入栈
            if(st.isEmpty() || st.getLast() >= nums2[i]){
                st.addLast(nums2[i]);
            }
            //不单调处理
            else{
                while(!st.isEmpty() && st.getLast() < nums2[i]){
                    int cur = st.removeLast();
                    if(map.containsKey(cur)){
                        nums1[map.get(cur)] = nums2[i];
                    }
                }
                st.add(nums2[i]);
            }
        }
        //尾处理
        while(!st.isEmpty()){
            int cur = st.removeLast();
            if(map.containsKey(cur)){
                nums1[map.get(cur)] = -1;
            }
        }
        return nums1;
    }
}
```



## 3、下一个更大元素 II

### ①、[题目链接](https://leetcode.cn/problems/next-greater-element-ii/)

给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。

数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。

 

示例 1:

输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
示例 2:

输入: nums = [1,2,3,4,3]
输出: [2,3,4,-1,4]


提示:

1 <= nums.length <= 104
-109 <= nums[i] <= 109



### ②、思路

两次单调栈即可；

注意保存的是下标；

若需要的处理结果是元素值，待处理栈应该存入下标，以免后边的元素找不到待处理元素的位置；

如果保存的是元素值，那需要使用额外的空间来记录下标；

如果待处理数组和当前数组不是同一个，必须使用额外空间保存，当然也就不需要保存下标了，直接保存元素本身，因为入栈的元素下标已经不是待处理的下标了。





### ③、代码

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Arrays.fill(res, -1);
        LinkedList<Integer> st = new LinkedList<>();
        for(int i = 0; i < nums.length; i++){
            if(st.isEmpty() || nums[st.getLast()] >= nums[i]){
                st.addLast(i);
            }
            else{
                while(!st.isEmpty() && nums[st.getLast()] < nums[i]){
                    res[st.removeLast()] = nums[i];
                }
                st.addLast(i);
            }
        }
        for(int i = 0; i < nums.length; i++){
            if(st.isEmpty() || nums[st.getLast()] >= nums[i]){
                st.addLast(i);
            }
            else{
                while(!st.isEmpty() && nums[st.getLast()] < nums[i]){
                    int cur = st.removeLast();
                    if(res[cur] == -1){
                        res[cur] = nums[i];
                    }
                }
                st.addLast(i);
            }
        }
        return res;
    }
}
```



## 4、*接雨水

### ①、[题目链接](https://leetcode.cn/problems/trapping-rain-water/)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

示例 1：



输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9


提示：

n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105



### ②、思路

若高度一直按一个方向增长，显然接不到雨水，如果出现扰动元素，说明出现凹槽，适合使用单调栈

小于入栈

大于处理并入栈

每次处理一个元素即可，不用处理完所有低于当前高度的元素，太乱了；

为什么可以这样呢？

计算雨水是需要高和宽，宽是通过下标计算的，处理完后栈顶元素出栈，下一个元素处理的时候，宽度由于是左右坐标计算的，保持不变，但是深度就以下一个元素高度为底，即，把当前处理元素那个位置按照下一个位置的高度填平了；结果保持不变；

处理完元素后，为了维持单调栈，需要进行尾处理，然后加入当前遍历元素



### ③、代码

```java
class Solution {
    public int trap(int[] height) {
        LinkedList<Integer> st = new LinkedList<>();
        int sum = 0;
        for(int i = 0; i < height.length; i++){
            //单调入栈
            if(st.isEmpty() || height[st.getLast()] > height[i]){
                st.add(i);
            }
            else{
                //出栈处理
                while(st.size() > 1 && height[st.getLast()] < height[i]){
                    int mid = st.removeLast();
                    int left = st.getLast();
                    sum += (i -left -1)*(Math.min(height[i], height[left]) -height[mid]);
                }
                //尾处理
                if(!st.isEmpty() && height[st.getLast()] <= height[i]){
                    st.removeLast();
                }
                st.addLast(i);
            }
        }
        return sum;
    }
}
```



## 5、*柱状图中最大的矩形

### ①、[题目链接](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

示例 1:



输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
示例 2：



输入： heights = [2,4]
输出： 4


提示：

1 <= heights.length <=105
0 <= heights[i] <= 104

### ②、思路

当前高度什么时候必须要处理？

即当前高度不能成为矩形的高度的时候，什么时候不能成为矩形高度？

当相邻元素它是最大的时候，它就必须要处理了，之后再出现什么样的高度也和它没有关系了，因为矩阵要连续；

所以，当可以确定是波峰的时候处理元素，故元素应该单调递增；

使用单增栈；

确定波峰高度（栈顶元素）的左边界（次栈顶元素），右边界（当前遍历元素的高度）；矩阵面积底乘以高，底根据坐标计算即可；

只要每一个元素高度确定的矩形都计算一遍，就不会遗漏，因此需要在原数组的左右两边加入两个高度为0的元素，确保所有元素都有成为波峰的机会；



### ③、代码

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] he = new int[heights.length +2];
        for(int i = 0; i < heights.length; i++){
            he[i +1] = heights[i];
        }
        LinkedList<Integer> st = new LinkedList<>();
        int max = 0;
        for(int i = 0; i < he.length; i++){
            if(st.isEmpty() || he[st.getLast()] < he[i] ){
                st.addLast(i);
            }
            else{
                while(he[st.getLast()] > he[i]){
                    int mid = st.removeLast();
                    int left = st.getLast();
                    max = Math.max(max, (i -left -1)*he[mid]);
                }
                st.addLast(i);
            }
        }
        return max;
    }
}
```



# 十一、额外题目

## 1、有多少小于当前数字的数字

### ①、[题目链接](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。

以数组形式返回答案。

 

示例 1：

输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
示例 2：

输入：nums = [6,5,4,8]
输出：[2,1,0,3]
示例 3：

输入：nums = [7,7,7,7]
输出：[0,0,0,0]


提示：

2 <= nums.length <= 500
0 <= nums[i] <= 100

### ②、思路

排序，哈希表快速查找相应元素排位

### ③、代码

```java
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        //保存排位
        Map<Integer, Integer> map = new HashMap<>();
        //数据副本，用于排序
        int[] copy = Arrays.copyOf(nums, nums.length);
        Arrays.sort(copy);
        for(int i = 0; i < copy.length; i++){
            if(i > 0 && copy[i] == copy[i -1]){
                continue;
            }
            map.put(copy[i], i);
        }
        //写入答案
        for(int i = 0; i < nums.length; i++){
            nums[i] = map.get(nums[i]);
        }
        return nums;
    }
}
```



## 2、有效的山脉数组

### ①、[题目链接](https://leetcode.cn/problems/valid-mountain-array/)

给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。

让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组：

arr.length >= 3
在 0 < i < arr.length - 1 条件下，存在 i 使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]






示例 1：

输入：arr = [2,1]
输出：false
示例 2：

输入：arr = [3,5,5]
输出：false
示例 3：

输入：arr = [0,3,2,1]
输出：true


提示：

1 <= arr.length <= 104
0 <= arr[i] <= 104



### ②、思路

遍历，先上升后下降，标记当前是上升还是下降即可



### ③、代码

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        if(arr.length < 3 || arr[0] >= arr[1] || arr[arr.length -1] >= arr[arr.length -2]){
            return false;
        }
        boolean up = true;
        for(int i = 1; i < arr.length -1; i++){
            if(arr[i] > arr[i -1] && !up || arr[i] == arr[i -1]){
                return false;
            }
            if(arr[i] < arr[i -1]){
                up = false;
            }
        }
        return true;
    }
}
```



## 3、移动零

### ①、[题目链接](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

 

示例 1:

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:

输入: nums = [0]
输出: [0]


提示:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1


进阶：你能尽量减少完成的操作次数吗？



### ②、思路

依次将非零元素移动到前边；

将后元素全部赋值为0

### ③、代码

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int res = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != 0){
                nums[res++] = nums[i];
            }
        }
        for(int i = res; i < nums.length; i++){
            nums[i] = 0;
        }
    }
}
```



## 4、轮转数组

### ①、[题目链接](https://leetcode.cn/problems/rotate-array/)

给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

 

示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]


提示：

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105


进阶：

尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？



### ②、思路



### ③、代码

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        reverse(nums, 0, n -1);
        reverse(nums, 0, k -1);
        reverse(nums, k, n -1);
    }
    public void reverse(int[] nums, int l, int r){
        while(l < r){
            nums[l] ^= nums[r];
            nums[r] ^= nums[l];
            nums[l++] ^= nums[r--];
        }
    }
}
```



## 5、独一无二的出现次数

### ①、[题目链接](https://leetcode.cn/problems/unique-number-of-occurrences/)

给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。

如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。

 

示例 1：

输入：arr = [1,2,2,1,1,3]
输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
示例 2：

输入：arr = [1,2]
输出：false
示例 3：

输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]
输出：true


提示：

1 <= arr.length <= 1000
-1000 <= arr[i] <= 1000



### ②、思路



### ③、代码

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        int[] map = new int[2002];
        Set<Integer> set = new HashSet<>();
        for(int i : arr){
            map[i +1000]++;
        }
        for(int i = 0; i < 2002; i++){
            if(map[i] != 0){
                if(set.contains(map[i])){
                    return false;
                }
                set.add(map[i]);
            }
        }
        
        return true;
    }
}
```

## 6、寻找数组的中心下标

### ①、[题目链接](https://leetcode.cn/problems/find-pivot-index/)

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 

示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：

输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：

输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。


提示：

1 <= nums.length <= 104
-1000 <= nums[i] <= 1000




### ②、思路



### ③、代码

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        for(int i : nums){
            sum += i;
        }
        int cur =  0;
        for(int i = 0; i < nums.length; i++){
            if(2*cur == sum -nums[i]){
                return i;
            }
            cur += nums[i];
        }
        return -1;
    }
}
```



## 7、在排序数组中查找元素的第一个和最后一个位置

### ①、[题目链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

 

示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]


提示：

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109



### ②、思路



### ③、代码

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length -1;
        int mid = 0;
        int[] res = new int[]{-1, -1};
        //特殊处理
        if(nums.length == 0){
            return res;
        }
        //找最后一个
        while(left < right){
            mid = left +(right -left +1)/2;
            if(nums[mid] > target){
                right = mid -1;
            }
            else{
                left = mid;
            }
        }
        //一个都没有的特殊处理
        int en = left;
        if(nums[en] != target){
            return res;
        }
        //找第一个
        left = 0;
        while(left < right){
            mid = left +(right -left)/2;
            if(nums[mid] < target){
                left = mid +1;
            }
            else{
                right = mid;
            }
        }
        //找到了两个
        res[0] = left;
        res[1] = en;
        return res;
    }
}
```



## 8、搜索插入位置

### ①、[题目链接](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

 

示例 1:

输入: nums = [1,3,5,6], target = 5
输出: 2
示例 2:

输入: nums = [1,3,5,6], target = 2
输出: 1
示例 3:

输入: nums = [1,3,5,6], target = 7
输出: 4


提示:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 为 无重复元素 的 升序 排列数组
-104 <= target <= 104



### ②、思路



### ③、代码

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0;
        int r = nums.length -1;
        int m = 0;
        if(target < nums[0]){
            return 0;
        }
        if(target > nums[nums.length -1]){
            return nums.length;
        }
        while(l < r){
            m = l +(r -l +1)/2;
            if(nums[m] > target){
                r = m -1;
            }
            else{
                l = m;
            }
        }
        return target == nums[l] ? l : l +1;
    }
}
```



## 9、按奇偶排序数组 II

### ①、[题目链接](https://leetcode.cn/problems/sort-array-by-parity-ii/)

给定一个非负整数数组 nums，  nums 中一半整数是 奇数 ，一半整数是 偶数 。

对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。

你可以返回 任何满足上述条件的数组作为答案 。

 

示例 1：

输入：nums = [4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
示例 2：

输入：nums = [2,3]
输出：[2,3]


提示：

2 <= nums.length <= 2 * 104
nums.length 是偶数
nums 中一半是偶数
0 <= nums[i] <= 1000


进阶：可以不使用额外空间解决问题吗？



### ②、思路



### ③、代码

```java
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int l = 0;
        int r = nums.length -1;
        while(l < nums.length && r >= 0){
            //找偶数位的奇数
            while(l < nums.length && nums[l] %2 == 0){
                l += 2;
            }
            if(l >= nums.length){
                break;
            }
            //找奇数位的偶数
            while(r >= 0 && nums[r] %2 == 1){
                r -= 2;
            }
            //换位置
            nums[l] ^= nums[r];
            nums[r] ^= nums[l];
            nums[l] ^= nums[r];
            l += 2;
            r -= 2;
        }
        return nums;
    }
}
```



## 10、两两交换链表中的节点

### ①、[题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]


提示：

链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100



### ②、思路



### ③、代码

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode pre;
        ListNode cur;
        ListNode next;
        ListNode ppre;
        ListNode nhead = new ListNode();
        nhead.next = head;
        ppre = nhead;
        pre = head;
        if(head == null || head.next == null){
            return head;
        }
        cur = head.next;
        while(cur != null){
            next = cur.next;
            ppre.next = cur;
            cur.next = pre;
            pre.next = next;
            ppre = pre;
            pre = next;
            cur = pre == null ? null : pre.next;
        }
        return nhead.next;
    }
}
```

## 11、回文链表

### ①、[题目链接](https://leetcode.cn/problems/palindrome-linked-list/)

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

 

示例 1：


输入：head = [1,2,2,1]
输出：true
示例 2：


输入：head = [1,2]
输出：false


提示：

链表中节点数目在范围[1, 105] 内
0 <= Node.val <= 9


进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？



### ②、思路



### ③、代码

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode[] arr = new ListNode[100000];
        int p = 0;
        ListNode cur = head;
        while(cur != null){
            arr[p++] = cur;
            cur = cur.next;
        }
        int i = 0;
        int j = p -1;
        while(i < j){
            if(arr[i++].val != arr[j--].val){
                return false;
            }
        }
        return true;
    }
}
```



## 12、重排链表

### ①、[题目链接](https://leetcode.cn/problems/reorder-list/)

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：



输入：head = [1,2,3,4]
输出：[1,4,2,3]
示例 2：



输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]


提示：

链表的长度范围为 [1, 5 * 104]
1 <= node.val <= 1000



### ②、思路



### ③、代码

```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode[] arr = new ListNode[50000];
        ListNode cur = head;
        int p = 0;
        while(cur != null){
            arr[p++] = cur;
            cur = cur.next;
        }
        cur = head;
        ListNode next;
        int i = 1; int j = p -1;
        while(i < j){
            arr[i].next = null;
            arr[j].next = null;
            cur.next = arr[j--];
            cur = cur.next;
            cur.next = arr[i++];
            cur = cur.next;
        }
        if(i == j){
            arr[i].next = null;
            cur.next = arr[i];
        }
    }
}
```



## 13、环形链表

### ①、[题目链接](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：false
解释：链表中没有环。


提示：

链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。


进阶：你能用 O(1)（即，常量）内存解决此问题吗？



### ②、思路



### ③、代码

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null){
            return false;
        }
        ListNode fast = head.next;
        ListNode low = head;
        while(fast != null && fast.next != null && fast != low){
            fast = fast.next.next;
            low = low.next;
        }
        return fast == low;
    }
}
```



## 14、同构字符串

### ①、[题目链接](https://leetcode.cn/problems/isomorphic-strings/)

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

示例 1:

输入：s = "egg", t = "add"
输出：true
示例 2：

输入：s = "foo", t = "bar"
输出：false
示例 3：

输入：s = "paper", t = "title"
输出：true


提示：

1 <= s.length <= 5 * 104
t.length == s.length
s 和 t 由任意有效的 ASCII 字符组成



### ②、思路



### ③、代码

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> map = new HashMap<>();
        Set<Character> set = new HashSet<>();
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int n = ss.length;
        if(tt.length != n){
            return false;
        }
        for(int i = 0; i <n; i++){
            if(map.containsKey(ss[i])){
                if(map.get(ss[i]) != tt[i]){
                    return false;
                }
            }
            else{
                if(set.contains(tt[i])){
                    return false;
                }
                map.put(ss[i], tt[i]);
                set.add(tt[i]);
            }
        }
        return true;
    }
}
```



## 15、查找共用字符

### ①、[题目链接](https://leetcode.cn/problems/find-common-characters/)

给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。


示例 1：

输入：words = ["bella","label","roller"]
输出：["e","l","l"]
示例 2：

输入：words = ["cool","lock","cook"]
输出：["c","o"]


提示：

1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] 由小写英文字母组成



### ②、思路



### ③、代码

```java
class Solution {
    public List<String> commonChars(String[] words) {
        Map<Character, Integer> map = new HashMap<>();
        Map<Character, Integer> res = new HashMap<>();
        Map<Character, Integer> temp;
        ArrayList<String> ans = new ArrayList<>();
        for(char c : words[0].toCharArray()){
            map.put(c, map.getOrDefault(c, 0) +1);
        }
        for(int i = 1; i < words.length; i++){
            for(char c : words[i].toCharArray()){
                if(map.containsKey(c)){
                    res.put(c, Math.min(map.get(c), res.getOrDefault(c, 0) +1));
                }
            }
            temp = res;
            map.clear();
            res = map;
            map = temp;
        }
        for(Map.Entry<Character, Integer> entry : map.entrySet()){
            for(int i = 0; i < entry.getValue(); i++){
                ans.add(String.valueOf(entry.getKey()));
            }
        }
        return ans;
    }
}
```

## 16、长按键入

### ①、[题目链接](https://leetcode.cn/problems/long-pressed-name/)

你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。


提示：

1 <= name.length, typed.length <= 1000
name 和 typed 的字符都是小写字母



### ②、思路



### ③、代码

```java
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        char[] n = name.toCharArray();
        char[] t = typed.toCharArray();
        int p1 = 1;
        int p2 = 1;
        if(n[0] != t[0] || n.length > t.length){
            return false;
        }
        while(p1 < n.length && p2 < t.length){
            if(n[p1] != n[p1 -1]){
                while(p2 < t.length && t[p2] == t[p2 -1]){
                    p2++;
                }
            }
            if(p2 < t.length && n[p1++] != t[p2++]){
                return false;
            }
        }
        while(p2 < t.length && t[p2] == t[p2 -1]){
            p2++;
        }
        return p1 == n.length && p2 == t.length;
    }
}
```



## 17、*比较含退格的字符串

### ①、[题目链接](https://leetcode.cn/problems/backspace-string-compare/)

给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

示例 1：

输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
示例 2：

输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
示例 3：

输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。


提示：

1 <= s.length, t.length <= 200
s 和 t 只含有小写字母以及字符 '#'


进阶：

你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？



### ②、思路



### ③、代码

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int ps = ss.length -1;
        int pt = tt.length -1;
        int tabs = 0;
        int tabt = 0;
        while(ps >= 0 || pt >= 0){
            //找s的下一个拿来比较的字符
            while(ps >= 0){
                if(ss[ps] == '#'){
                    ps--;
                    tabs++;
                }
                else if(tabs > 0){
                     ps--;
                    tabs--;
                }
                else{
                    break;
                }
            }
            //找t的下一个拿来比较的字符
            while(pt >= 0 ){
                if(tt[pt] == '#'){
                    pt--;
                    tabt++;
                }
                else if(tabt > 0){
                    pt--;
                    tabt--;
                }
                else{
                    break;
                }
            }
            //都到尽头了
            if(ps < 0 && pt < 0){
                return true;
            }
            //有一边没到尽头
            if(pt < 0 || ps < 0){
                return false;
            }
            //不相等；
            if(ss[ps] != tt[pt]){
                return false;
            }
            //相等
            ps--;
            pt--;
        }
        return ps < 0 && pt < 0;
    }
}
```



## 18、 求根节点到叶节点数字之和

### ①、[题目链接](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

 

示例 1：


输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
示例 2：


输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026


提示：

树中节点的数目在范围 [1, 1000] 内
0 <= Node.val <= 9
树的深度不超过 10



### ②、思路



### ③、代码

```java
class Solution {
    private int sum = 0;
    private int cur = 0;
    public int sumNumbers(TreeNode root) {
        help(root);
        return sum;
    }
    public void help(TreeNode root){
        cur *= 10;
        cur += root.val;
        if(root.left == null && root.right == null){
            sum += cur;
            cur /= 10;
            return;
        }
        if(root.left != null){
            help(root.left);
        }
        if(root.right != null){
            help(root.right);
        }
        cur /= 10;
    }
}
```



## 19、*将二叉搜索树变平衡

### ①、[题目链接](https://leetcode.cn/problems/balance-a-binary-search-tree/)

给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。

如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。

 

示例 1：



输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
示例 2：



输入: root = [2,1,3]
输出: [2,1,3]


提示：

树节点的数目在 [1, 104] 范围内。
1 <= Node.val <= 105



### ②、思路

不用左旋右旋，直接构造有序数组即可

### ③、代码

```java
class Solution {
    private TreeNode[] arr = new TreeNode[10000];
    private int n = 0;
    public TreeNode balanceBST(TreeNode root) {
        help(root);
        return build(0, n -1);
    }
    public void help(TreeNode root){
        if(root == null){
            return;
        }
        help(root.left);
        arr[n++] = root;
        help(root.right);
    }
    public TreeNode build(int l, int r){
        if(l > r){
            return null;
        }
        int mid = l + (r -l)/2;
        arr[mid].left = build(l, mid -1);
        arr[mid].right = build(mid +1, r);
        return arr[mid];
    }
}
```



## 20、N皇后 II

### ①、[题目链接](https://leetcode.cn/problems/n-queens-ii/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。

 

示例 1：


输入：n = 4
输出：2
解释：如上图所示，4 皇后问题存在两个不同的解法。
示例 2：

输入：n = 1
输出：1


提示：

1 <= n <= 9



### ②、思路



### ③、代码

```java
class Solution {
    public int res = 0;
    public int[][] que;
    public int n;
    public int totalNQueens(int n) {
        que = new int[n][n];
        this.n = n;
        backTracking(0);
        return res;
    }
    public void backTracking(int index){
        if(index >= n){
            res++;
            return;
        }
        for(int i = 0; i < n; i++){
            que[index][i] = 1;
            if(check(index, i)){
                backTracking(index +1);
            }
            que[index][i] = 0;
        }
    }
    public boolean check(int h, int l){
        for(int i = 0; i < h; i++){
            if(que[i][l] == 1){
                return false;
            }
            if(l -(h -i) >= 0 && que[i][l -(h -i)] == 1){
                return false;
            }
            if(l +(h -i) < n  && que[i][l +(h -i)] == 1){
                return false;
            }
        }
        return true;
    }
}
```

## 21、Dota2 参议院

### ①、[题目链接](https://leetcode.cn/problems/dota2-senate/)

Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：

禁止一名参议员的权利：

参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。

宣布胜利：

          如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。

 





给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。

 

示例 1：

输入："RD"
输出："Radiant"
解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
示例 2：

输入："RDD"
输出："Dire"
解释：
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利


提示：

给定字符串的长度在 [1, 10,000] 之间.



### ②、思路



### ③、代码

```java
class Solution {
    public String predictPartyVictory(String senate) {
        char[] sen = senate.toCharArray();
        int n = sen.length;
        //被禁止
        boolean[] f = new boolean[n];
        //被禁止但是尚未被禁止的数量
        int fr = 0;
        int fd = 0;
        //还没有被禁止的数量
        int cr = 0;
        int cd = 0;
        for(int i = 0; i < n; i++){
            if(sen[i] == 'R'){
                cr++;
            }
            else{
                cd++;
            }
        }
        //循环使用权力
        while(true){
            for(int i = 0; i < n; i++){
                if(sen[i] == 'R'){
                    //未被禁止，未执行禁止的数量也是0，执行禁止另一个阵营的权力或者宣布胜利
                    if(!f[i] && fr == 0){
                        if(cd == 0){
                            return "Radiant";
                        }
                        fd++;
                    }
                    //未被禁止但是未执行禁止的数量不为0，应当被禁止
                    else if(!f[i] && fr != 0){
                        fr--;
                        cr--;
                        f[i] = true;
                    }
                }
                else{
                    if(!f[i] && fd == 0){
                        if(cr == 0){
                            return "Dire";
                        }
                        fr++;
                    }
                    else if(!f[i] && fd != 0){
                        fd--;
                        cd--;
                        f[i] = true;
                    }
                }
            }
        }
    }
}
```



## 22、分割平衡字符串

### ①、[题目链接](https://leetcode.cn/problems/split-a-string-in-balanced-strings/)

在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。

给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

注意：分割得到的每个字符串都必须是平衡字符串，且分割得到的平衡字符串是原平衡字符串的连续子串。

返回可以通过分割得到的平衡字符串的 最大数量 。

 

示例 1：

输入：s = "RLRRLLRLRL"
输出：4
解释：s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
示例 2：

输入：s = "RLLLLRRRLR"
输出：3
解释：s 可以分割为 "RL"、"LLLRRR"、"LR" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
示例 3：

输入：s = "LLLLRRRR"
输出：1
解释：s 只能保持原样 "LLLLRRRR".
示例 4：

输入：s = "RLRRRLLRLL"
输出：2
解释：s 可以分割为 "RL"、"RRRLLRLL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。


提示：

1 <= s.length <= 1000
s[i] = 'L' 或 'R'
s 是一个 平衡 字符串
通过次数90,505提交次数106,877



### ②、思路



### ③、代码

```java
class Solution {
    public int balancedStringSplit(String s) {
        char[] ss = s.toCharArray();
        int cr = 0;
        int cl = 0;
        int res = 0;
        for(int i = 0; i < ss.length; i++){
            if(ss[i] == 'R'){
                cr++;
                if(cr == cl){
                    res++;
                    cr = 0;
                    cl = 0;
                }
            }
            else{
                cl++;
                if(cr == cl){
                    cr = 0;
                    cl = 0;
                    res++;
                }
            }
        }
        return res;
    }
}
```



## 23、最长回文子串

### ①、[题目链接](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"


提示：

1 <= s.length <= 1000
s 仅由数字和英文字母组成




### ②、思路



### ③、代码

```java
class Solution {
    public String longestPalindrome(String s) {
        char[] ss = s.toCharArray();
        int n= ss.length;
        boolean[][] dp = new boolean[n][n];
        int[] max = new int[2];
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(ss[i] == ss[j]){
                    if(j -i < 2){
                        dp[i][j] = true;
                    }
                    else{
                        dp[i][j] = dp[i +1][j -1];
                    }
                    if(dp[i][j]){
                        if(max[1] -max[0] < j -i){
                            max[1] = j;
                            max[0] = i;
                        }
                    }
                }
            }
        }
        return String.valueOf(ss, max[0], max[1] -max[0] +1);
    }
}
```



## 24、*分割回文串 II

### ①、[题目链接](https://leetcode.cn/problems/palindrome-partitioning-ii/)

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。

返回符合要求的 最少分割次数 。

 

示例 1：

输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
示例 2：

输入：s = "a"
输出：0
示例 3：

输入：s = "ab"
输出：1


提示：

1 <= s.length <= 2000
s 仅由小写英文字母组成




### ②、思路

0~i的最少分割次数为状态，若0-i不是回文，就从0 ~ i之间找一个元素j，看j到i是不是回文，如果是，那dp[j] +1就可能是最少的；

怎么看是不是回文呢？

先用dp[i] [j]得到每两个位置是不是回文的；



### ③、代码

```java
class Solution {
    public int minCut(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        int[] dp2 = new int[n];
        boolean[][] dp1 = new boolean[n][n];
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(ss[i] == ss[j]){
                    if(j - i < 2){
                        dp1[i][j] = true;
                    }
                    else{
                        dp1[i][j] = dp1[i +1][j -1];
                    }
                }
            }
        }
        Arrays.fill(dp2, n);
        dp2[0] = 0;
        for(int i = 1; i < n; i++){
            if(dp1[0][i]){
                dp2[i] = 0;
                continue;
            }
            for(int j = 1; j <= i; j++){
                if(dp1[j][i]){
                    dp2[i] = Math.min(dp2[i], dp2[j -1] +1);
                }
            }
        }
        return dp2[n -1];
    }
}
```



## 25、*最长递增子序列的个数

### ①、[题目链接](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数 。

注意 这个数列必须是 严格 递增的。

 

示例 1:

输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:

输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。


提示: 

1 <= nums.length <= 2000
-106 <= nums[i] <= 106

### ②、思路



### ③、代码

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        //dp[i][0]:以i结尾的最大长度
        //dp[i][1]:以i结尾最大长度的序列数
        int[][] dp = new int[n][2];
        for(int i = 0; i < n; i++){
            dp[i][0] = 1;
            dp[i][1] = 1;
        }
        //记录最大长度及其个数
        int max = 1;
        int count = 1;
        for(int i = 1; i < n; i++){
            //找上一个小的数字
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    if(dp[i][0] < dp[j][0] +1){
                        dp[i][0] = dp[j][0] +1;
                        dp[i][1] = dp[j][1];
                    }
                    else if(dp[i][0] == dp[j][0] +1){
                        dp[i][1] += dp[j][1];
                    }
                }
            }
            //每次更新，因为最长序列不一定以最后一个字符结尾
            if(max < dp[i][0]){
                max = dp[i][0];
                count = dp[i][1];
            }
            else if(max == dp[i][0]){
                count += dp[i][1];
            }
        }
        return count;
    }
}
```



## 26、钥匙和房间

### ①、[题目链接](https://leetcode.cn/problems/keys-and-rooms/)

有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。

当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。

给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。

 

示例 1：

输入：rooms = [[1],[2],[3],[]]
输出：true
解释：
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
示例 2：

输入：rooms = [[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。


提示：

n == rooms.length
2 <= n <= 1000
0 <= rooms[i].length <= 1000
1 <= sum(rooms[i].length) <= 3000
0 <= rooms[i][j] < n
所有 rooms[i] 的值 互不相同



### ②、思路



### ③、代码

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        LinkedList<Integer> q = new LinkedList<>();
        boolean[] visit = new boolean[n];
        int size = 0;
        int count = 1;
        q.addLast(0);
        visit[0] = true;
        while(!q.isEmpty()){
            size = q.size();
            //层序遍历
            for(int i = 0; i < size; i++){
                int cur = q.removeFirst();
                //将每个房间的钥匙加入队列
                for(int r : rooms.get(cur)){
                    if(!visit[r]){
                        q.addLast(r);
                        visit[r] = true;
                        count++;
                        if(count >= n){
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}
```



## 27、*单词接龙

### ①、[题目链接](https://leetcode.cn/problems/word-ladder/)

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：

每一对相邻的单词只差一个字母。
 对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。
sk == endWord
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。


示例 1：

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
示例 2：

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。


提示：

1 <= beginWord.length <= 10
endWord.length == beginWord.length
1 <= wordList.length <= 5000
wordList[i].length == beginWord.length
beginWord、endWord 和 wordList[i] 由小写英文字母组成
beginWord != endWord
wordList 中的所有字符串 互不相同



### ②、思路



### ③、代码

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        LinkedList<String> q = new LinkedList<>();
        int n = wordList.size();
        int len = 0;
        q.addLast(beginWord);
        boolean[] visit = new boolean[n];
        int size = 0;
        while(!q.isEmpty()){
            size = q.size();
            len++;
            //层序遍历
            for(int i = 0; i < size; i++){
                String cur = q.removeFirst();
                //找到最终单词，肯定是最短的
                if(cur.equals(endWord)){
                    return len;
                }
                //查找于当前单词相差一个字符的单词
                for(int j = 0; j < n; j++){
                    //没有被访问过就加入队列
                    if(!visit[j] && check(cur, wordList.get(j))){
                        q.addLast(wordList.get(j));
                        visit[j] = true;
                    }
                }
            } 
        }
        return 0;
    }
    //判断是否相差一个字符
    public boolean check(String t, String s){
        boolean f = false;
        for(int i = 0; i < t.length(); i++){
            if(t.charAt(i) != s.charAt(i)){
                if(!f){
                    f = true;
                }
                else{
                    return false;
                }
            }
        }
        return true;
    }
}
```



## 28、* 冗余连接

### ①、[题目链接](https://leetcode.cn/problems/redundant-connection/)

树可以看成是一个连通且 无环 的 无向 图。

给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。

 

示例 1：



输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
示例 2：



输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]


提示:

n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ai < bi <= edges.length
ai != bi
edges 中无重复元素
给定的图是连通的 



### ②、思路

并查集，集合元素是节点；

若当前边的两个节点属于同一颗树，删除当前边；

否则将当前两个结点所在的树合并

### ③、代码

```java
class Solution {
    private int n = 1005;
    private int[] farther;
    public int[] findRedundantConnection(int[][] edges) {
        farther = new int[n];
        for(int i = 0; i < n; i++){
            farther[i] = i;
        }
        for(int i = 0; i < edges.length; i++){
            if(same(edges[i][0], edges[i][1])){
                return edges[i];
            }
            else{
                union(edges[i][0], edges[i][1]);
            }
        }
        return null;
    }
    public boolean same(int u, int v){
        if(find(u) == find(v)){
            return true;
        }
        return false;
    }
    public void union(int u, int v){
        farther[find(u)] = find(v);
    }
    public int find(int i){
        if(farther[i] == i){
            return i;
        }
        return find(farther[i]);
    }
}
```



## 29、*冗余连接 II

### ①、[题目链接]()

在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。

返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

 

示例 1：


输入：edges = [[1,2],[1,3],[2,3]]
输出：[2,3]
示例 2：


输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
输出：[4,1]


提示：

n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ui, vi <= n

### ②、思路

本题与无向图的区别在于，除了会成环外，还可能出现入度为2的情况；

若按照无向图的处理办法，处理第一个成环的边，那可能入度为2的情况依然存在，所以必须先处理入度为2的结点；

入度为2，边有两条，删除靠后那条，因此从后往前遍历；若删除边后环仍然存在，那么应当删除的不是现在这条边，而是另一条

### ③、代码

```java

class Solution {
    private int n = 1005;
    private int[] farther = new int[1005];
    public int[] findRedundantDirectedConnection(int[][] edges) {
        //入度统计
        int[] in = new int[n];
        for(int i = 0; i < edges.length; i++){
            in[edges[i][1]]++;
        }
        //检查入度为2，如果有入度为2，优先处理，不能先处理环，因为处理环了入度可能还是2
        for(int i = edges.length -1; i >= 0; i--){
            if(in[edges[i][1]] == 2){
                if(removeTry(i, edges)){
                    return edges[i];
                }
            }
        }
        //与无向图一致，入度都是1，但是有环
        return removeFirstedge(edges);
    }
    //删除入度为2的边，检查是否已经去除环，如果已经去除，返回true
    public boolean removeTry(int k, int[][] edges){
        init();
        for(int i = 0; i < edges.length; i++){
            if(k == i){
                continue;
            }
            if(same(edges[i][0], edges[i][1])){
                return false;
            }
            else{
                union(edges[i][0], edges[i][1]);
            }
        }
        return true;
    }
    //按照无向图地处理方法，直接处理第一个成环的边
    public int[] removeFirstedge(int[][] edges){
        init();
        for(int i = 0; i < edges.length; i++){
            if(same(edges[i][0], edges[i][1])){
                return edges[i];
            }
            else{
                union(edges[i][0], edges[i][1]);
            }
        }
        return null;
    }
    public void init(){
        for(int i = 0; i < n; i++){
            farther[i] = i;
        }
    }
    public boolean same(int u, int v){
        if(find(u) == find(v)){
            return true;
        }
        return false;
    }
    public void union(int u, int v){
        farther[find(u)] = find(v);
    }
    public int find(int i){
        if(farther[i] == i){
            return i;
        }
        return find(farther[i]);
    }
}
```



## 30、机器人能否返回原点

### ①、[题目链接](https://leetcode.cn/problems/robot-return-to-origin/)

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。

如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

 

示例 1:

输入: moves = "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
示例 2:

输入: moves = "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。


提示:

1 <= moves.length <= 2 * 104
moves 只包含字符 'U', 'D', 'L' 和 'R'



### ②、思路



### ③、代码

```java
class Solution {
    public boolean judgeCircle(String moves) {
        char[] m = moves.toCharArray();
        int[] map = new int[24];
        map['U'-'A'] = 1;
        map['D' -'A'] = -1;
        map['L' -'A'] = 1;
        map['R' -'A'] = -1;
        int ud = 0;
        int lr = 0;
        for(int i = 0; i < m.length; i++){
            if(m[i] == 'U' || m[i] == 'D'){
                ud += map[m[i] -'A'];
            }
            else{
                lr += map[m[i] -'A'];
            }
        }
        return ud == 0 && lr == 0;
    }
}
```



## 31、下一个排列

### ①、[题目链接](https://leetcode.cn/problems/next-permutation/)

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

 

示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 100



### ②、思路



### ③、代码

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int k = nums.length -1;
        //特殊情况
        if(k == 0){
            return;
        }
        //从后往前找第一个减小的元素
        while(k > 0 && nums[k] <= nums[k -1]){
            k--;
        }
        //没找到，是最大序列
        if(k == 0 ){
            reverse(0, nums.length -1, nums);
        }
        else{
            k--;
            int b = nums.length -1;
            //从后往前找第一个比nums[k]大的数字
            while(b > k && nums[b] <= nums[k]){
                b--;
            }
            //交换这两个元素
            nums[k] ^= nums[b];
            nums[b] ^= nums[k];
            nums[k] ^= nums[b];
            //将后面进行颠倒
            reverse(k +1, nums.length -1, nums);
        }
    }
    public void reverse(int l, int r, int[] nums){
        while(l < r){
            nums[l] ^= nums[r];
            nums[r] ^= nums[l];
            nums[l] ^= nums[r];
            l++;
            r--;
        }
    }
}
```



## 32、岛屿的周长

### ①、[题目链接](https://leetcode.cn/problems/island-perimeter/)

给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

示例 1：



输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
示例 2：

输入：grid = [[1]]
输出：4
示例 3：

输入：grid = [[1,0]]
输出：4


提示：

row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] 为 0 或 1



### ②、思路



### ③、代码

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int sum = 0;
        int m = grid.length;
        int n = grid[0].length;    
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    sum += 4;
                    if(i -1 >= 0 && grid[i -1][j] == 1){
                        sum--;
                    }
                    if(i +1 < m && grid[i +1][j] == 1){
                        sum--;
                    }
                    if(j -1 >= 0 && grid[i][j -1] == 1){
                        sum--;
                    }
                    if(j +1 < n && grid[i][j +1] == 1){
                        sum--;
                    }
                }
            }
        }
        return sum;
    }
}
```



## 33、*根据数字二进制下 1 的数目排序

### ①、[题目链接](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)

给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。

如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。

请你返回排序后的数组。

 

示例 1：

输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
示例 2：

输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]
输出：[1,2,4,8,16,32,64,128,256,512,1024]
解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。
示例 3：

输入：arr = [10000,10000]
输出：[10000,10000]
示例 4：

输入：arr = [2,3,5,7,11,13,17,19]
输出：[2,3,5,17,7,11,13,19]
示例 5：

输入：arr = [10,100,1000,10000]
输出：[10,100,10000,1000]


提示：

1 <= arr.length <= 500
0 <= arr[i] <= 10^4



### ②、思路

n& n -1会将最后一个1变成0

比较器不能使用基本类型

### ③、代码

```java
class Solution {
    public int[] sortByBits(int[] arr) {
        int[] map = new int[10001];
        for(int i = 0; i < arr.length; i++){
            map[arr[i]] = cal(arr[i]);
        }
        Integer[] ar = new Integer[arr.length];
        for(int i = 0; i < arr.length; i++){
            ar[i] = arr[i];
        }
        Arrays.sort(ar, (Integer a, Integer b)->{
            if(map[a] < map[b]){
                return -1;
            }
            if(map[a] > map[b]){
                return 1;
            }
            return a -b;
        });
        for(int i = 0; i < arr.length; i++){
            arr[i] = ar[i];
        }
        return arr;
    }
    public int cal(int k){
        int sum = 0;
        while(k != 0){
            sum++;
            k &= (k -1);
        }
        return sum;
    }
}
```

