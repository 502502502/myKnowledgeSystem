#### 0、技巧



**比较器问题**

（a, b）-> { 	}

表示当前a在b的前面，当递增排序时：

+ 第一个元素比第二个元素大，返回1， 表示需要交换ab位置，即大的a应该在后面

结论：递增前大正，递减前大负



数组排序：Arrays.sort()

集合排序：Collections.sort()



**数组遍历**

不需要索引使用

```java
for(Object o : arr){

}
```

需要索引使用

```java
int size = arr.length;
for(int i = 0; i < size; i++){
	arr[i];
}
```









**List遍历**

LinkedList优先使用

```java
Iterator iter = list.iterator();
   while(iter.hasNext()){
      Object o = iter.next();
   }
```



ArrayList优先使用

```java
int size = list.size();
for(int i = 0; i < size; i++){
	list.get(i);
}
```

```java
for(Object o : list){
	
}
```





**map遍历**

有删除，使用迭代器

```java
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, String> entry = iterator.next();
            entry.getKey();
            entry.getValue();
        }
```

```java
 for (Map.Entry<Integer, String> entry : map.entrySet()) {
            entry.getKey();
            entry.getValue();
        }
```

```java
map.forEach((key, value) -> {
            
        });
```





**工具的使用**

+ 能用数组用数组

+ 栈和队列使用ArrayDeque

  void addFirst(E e)

  void addLast(E e)

  E removeFirst()

  E removeLast()

  E getFirst()

  E getLast()







#### 1、[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

**双指针**

处理元素只看当前，忌一次处理多个

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int ps = ss.length -1;
        int pt = tt.length -1;
        int tabs = 0;
        int tabt = 0;
        while(ps >= 0 || pt >= 0){
            while(ps >= 0){
                if(ss[ps] == '#'){
                    tabs++;
                    ps--;
                }else if(tabs > 0){
                    ps--;
                    tabs--;
                }else{
                    break;
                }
            }
            while(pt >= 0){
                if(tt[pt] == '#'){
                    pt--;
                    tabt++;
                }else if(tabt > 0){
                    pt--;
                    tabt--;
                }else{
                    break;
                }
            }
            if(ps < 0 && pt < 0){
                return true;
            }
            if(ps < 0 || pt < 0){
                return false;
            }
            if(ss[ps] != tt[pt]){
                return false;
            }
            ps--;
            pt--;
        }
        return true;
    }
}
```



#### 2、[34. 在排序数组第一最后](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

**二分法**

不取等循环

找第一个什么样的位置

上取整还是下取整

左边跨mid还是右边跨mid

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int l = 0;
        int r = nums.length -1;
        int mid = 0;
        int[] res = new int[]{-1, -1};
        if(nums.length == 0 || nums[0] > target || nums[nums.length -1] < target){
            return res;
        }
        while(l  < r){
            mid = l +(r -l +1)/2;
            if(nums[mid] > target){
                r = mid -1;
            }
            else{
                l = mid;
            }
        }
        if(nums[l] != target){
            return res;
        }
        res[1] = l;
        while(l >= 0 && nums[l] == target){
            l--;
        }
        res[0] = l +1;
        return res;
    }
}
```



#### 3、[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

**滑动窗口**

变化右边界

窗口不成立后修正左边界

```java
class Solution {
    public int totalFruit(int[] fruits) {
        int[] count = new int[100001];
        int curKind = 0;
        int curLen = 0;
        int res = 0;
        int l = 0;
        int r = 0;
        while(r < fruits.length){
            if(count[fruits[r]] == 0){
                //修正窗口
                while(curKind > 1){
                    count[fruits[l]]--;
                    if(count[fruits[l]] == 0){
                        curKind--;
                    }
                    l++;
                    curLen--;
                }
                //种类变化
                curKind++;
            }
            //窗口变化
            curLen++;
            count[fruits[r++]]++;
            res = Math.max(res, curLen);
        }
        return res;
    }
}
```



#### 4、[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

滑动窗口

窗口成立条件比较复杂

左右更新都一样

```java
class Solution {
    private int[] tcount = new int[70];
    private int[] win = new int[70];
    public String minWindow(String s, String t) {
        int[] res = new int[2];
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int slen = ss.length;
        int tlen = tt.length;
        //是否存在答案
        boolean flag = false;
        //排除不可能时间
        if(slen < tlen){
            return "";
        }
        res[1] = slen -1;
        //计数
        for(char c : tt){
            tcount[c -'A']++;
        }
        for(int i = 0; i < tlen -1; i++){
            win[ss[i] -'A']++;
        }
        int l = 0;
        int r = tlen -1;
        //窗口
        while(r < slen){
            //移动右边界
            win[ss[r] -'A']++;
            //更新左边界
            while(check()){
                flag = true;
                if(r -l < res[1] -res[0]){
                    res[1] = r;
                    res[0] = l;
                }
                win[ss[l++] -'A']--;
            }
            r++;
        }
        if(!flag){
            return "";
        }
        return s.substring(res[0], res[1] +1);
    }
    //检查是否包含
    public boolean check(){
        for(int i = 0; i < 70; i++){
            if(tcount[i] > win[i]){
                return false;
            }
        }
        return true;
    }
}
```



#### 5、[59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

模拟

左下右上绕一圈

控制边界

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int top = 0;
        int but = n -1;
        int l = 0;
        int r = n -1;
        int cur  = 1;
        while(cur < n*n){
            for(int i = l; i < r; i++){
                res[top][i] = cur++;
            }
            for(int i = top; i < but; i++){
                res[i][r] = cur++;
            }
            for(int i = r; i > l; i--){
                res[but][i] = cur++;
            }
            for(int i = but; i > top; i--){
                res[i][l] = cur++;
            }
            top++;
            l++;
            r--;
            but--;
        }
        if(cur <= n*n){
            res[top][l] = cur;
        }
        return res;
    }
}
```



#### 6、[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int t = 0;
        int l = 0;
        int b = m -1;
        int r = n -1;
        List<Integer> list = new ArrayList<>();
        while(list.size() < m*n -1){
            for(int i = l; i < r; i++){
                list.add(matrix[t][i]);
            }
            for(int i = t; i < b; i++){
                list.add(matrix[i][r]);
            }
            //防止单行回写
            if(t != b){
                for(int i = r; i > l; i--){
                    list.add(matrix[b][i]);
                }
            }else{
                list.add(matrix[b][r]);
            }
            //防止单列回写
            if(l != r){
                for(int i = b; i > t; i--){
                    list.add(matrix[i][l]);
                }
            }else{
                list.add(matrix[b][l]);
            }
            //边界更新
            l++;
            r--;
            t++;
            b--;
        }
        //正中间
        if(list.size() < m*n){
            list.add(matrix[t][l]);
        } 
        return list;
    }
}
```



#### 7、[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

递归法更简洁

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode f = head.next;
        ListNode l = head;
        l.next = swapPairs(f.next);
        f.next = l;
        return f;
    }
}
```



#### 8、[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

异位词重排后可作为哈希表的键



```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        Map<String, List<String>> map = new HashMap();
        for(String s : strs){
            char[] ss = s.toCharArray();
            Arrays.sort(ss);
            String k = String.valueOf(ss);
            if(map.containsKey(k)){
                map.get(k).add(s);
            }else{
                List<String> li = new ArrayList<>();
                li.add(s);
                map.put(k, li);
                res.add(li);
            }
        }
        return res;
    }
}
```



#### 9、[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

利用计数替代哈希表



```java
class Solution {
    private int[] pcount = new int[26];
    private int[] curcount = new int[26];
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        char[] ss = s.toCharArray();
        char[] pp = p.toCharArray();
        int m = ss.length;
        int n = pp.length;
        if(m < n){
            return res;
        }
        for(char c : pp){
            pcount[c -'a']++;
        }
        for(int i = 0; i < n -1; i++){
            curcount[ss[i] -'a']++;
        }
        for(int i = n -1; i < m; i++){
            curcount[ss[i] -'a']++;
            if(check()){
                res.add(i -n +1);
            }
            curcount[ss[i -n +1] -'a']--;
        }
        return res;
    }
    public boolean check(){
        for(int i = 0; i < 26; i++){
            if(curcount[i] != pcount[i]){
                return false;
            }
        }
        return true;
    }
}
```



#### 10、[15. 三数之和](https://leetcode.cn/problems/3sum/)

排序双指针

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        for(int k = 0; k < nums.length -2 && nums[k] < 1; k++){
            //去重
            if(k > 0 && nums[k] == nums[k -1]){
                continue;
            }
            int i = k +1;
            int j = nums.length -1;
            while(i < j){
                int sum = nums[i] + nums[j] +nums[k];
                if(sum == 0){
                    List<Integer> li = new ArrayList<>();
                    li.add(nums[i]);
                    li.add(nums[j]);
                    li.add(nums[k]);
                    res.add(li);
                    //去重
                    while(i < j && nums[i +1] == nums[i]){
                        i++;
                    }
                    while(i < j && nums[j -1] == nums[j]){
                        j--;
                    }
                    i++;
                    j--;
                }else if(sum < 0){
                    i++;
                }else{
                    j--;
                }
            }
        }
        return res;
    }
}
```



#### 11、[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

最大前后缀重叠部分如果是不重叠部分的倍数，则整个字符串可以由某个子串重复构建

为什么呢？

因为重叠部分必然是相等的，而重叠部分又是前缀的尾部，不重叠部分是后缀的尾部，刚好也是相等的，后缀的尾部最长是不重叠长度，前缀尾部最长就是重叠部分长度。

重叠部分是不重叠的整数倍，则整个字符串长度是不重叠部分的整数倍



```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        char[] str = s.toCharArray();
        int n = s.length();
        int[] next = new int[n +1];
        next[0] = -1;
        //求最大前后缀
        int j = 0;
        int k = -1;
        while(j < n){
            if(k == -1 || str[j] == str[k]){
                j++;
                k++;
                next[j] = k;
            }
            else{
                k = next[k];
            }
        }
        //前后缀重叠长度是不重叠长度地倍数即可推出重复
        return next[n] == 0 ? false : n %(n - next[n]) == 0;
    }
}
```



#### 12、[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

KMP

+ 回溯表
  + 当前俩字符不匹配，模式串需要回溯到的位置
  + 由**递推求出回溯表**，当前位置之前的字符串**前后缀最大长度为k**，说明当前位置如果要回溯，应该回溯到第K+1个位置进行比较，因为前K个已经是相等的了。第K+1个的下标为k。故每一个位置的回溯值应当由前面的字符串确定，因此，递推时根据当前的字符串求出。
  + 如果第K+1个位置和当前位置是一样的，那回溯到K+1个位置自然也会匹配不成功，需要再往前。因此，往后哦递推回溯值的时候，如果以当前字符结尾的字符串最大前后缀是K，即后一个位置应该回溯到下标K，如果k下标和后一个位置的字符相等，那应该回溯到k下标位置的回溯值。
  + **k代表回溯某个位置的下标，若为0，说明应该和第一个字符比较，如果不相等，k应该赋予一个特殊值，-1。**
+ 匹配
  + 不相等就回溯
  + 长度够了就找到第一个



```java
class Solution {
    public int strStr(String haystack, String needle) {
        char[] hay = haystack.toCharArray();
        char[] nee = needle.toCharArray();
        int hLen = haystack.length();
        int nLen = needle.length();
        int[] nextval = new int[nLen];
        nextval[0] = -1;
        //计算nextval
        int j = 0;
        int k = -1;
        while(j < nLen -1){
            if(k == -1 || nee[k] == nee[j]){
                j++;
                k++;
                if(nee[j] == nee[k]){
                    nextval[j] = nextval[k];
                }
                else{
                    nextval[j] = k;
                }
            }
            else{
                k = nextval[k];
            }
        }
        //匹配
        int i = 0;
        j = 0;
        while(i < hLen){
            if(j == -1 || hay[i] == nee[j]){
                i++;
                j++;
                if(j == nLen){
                    return i -j;
                }
            }
            else{
                j = nextval[j];
            }
        }
        return -1; 
    }
}
```



#### 13、[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

单调栈

入栈更新不可能成为答案的值

队首最大值，如果在窗口边界将其出队

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] res = new int[nums.length -k +1];
        int p = 0;
        int[] st = new int[100001];
        int l = 0;
        int r = -1;
        //单调入栈
        for(int i = 0; i < k -1; i++){
            while(r != -1 && nums[st[r]] <= nums[i]){
                r--;
            }
            st[++r] = i;
        }
        //单调入栈，顺序出队
        for(int i = k -1; i < nums.length; i++){
            while(r -l >= 0 && nums[st[r]] <= nums[i]){
                r--;
            }
            st[++r] = i;
            res[p++] = nums[st[l]];
            if(st[l] <= i -k +1){
                l++;
            }
        }
        return res;
    }
}
```



#### 14、[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        int res = 0;
        TreeNode cur = root;
        while(cur != null){
            int l = getDepth(cur.left);
            int r = getDepth(cur.right);
            //左子树一定是满树
            if(l == r){
                cur = cur.right;
                res += 1<<l;
            }else{
                //右子树一定是满树
                cur = cur.left;
                res += 1<<r;
            }
        }
        return res;
    }
    public int getDepth(TreeNode root){
        int res = 0;
        TreeNode cur = root;
        while(cur != null){
            res++;
            //最大深度由左子结点决定
            cur = cur.left;
        }
        return res;
    }
}
```



15、[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

计算左子树高度和右子树高度之差

若根结点左右高度差不超过1，还需要判断以左右为根是否平衡，因此需要重复计算高度；

故从底往上计算，可以利用计算结果。

由于需要左右子树的高度，所以返回值必须为int，而所需答案为boolean，故增加辅助函数

若高度返回-1说明不平衡，之后无需计算高度。

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return help(root) != -1;
    }
    public int help(TreeNode root){
        if(root == null){
            return 0;
        }
        int l = help(root.left);
        if(l == -1){
            return -1;
        }
        int r = help(root.right);
        if(r == -1){
            return -1;
        }
        return Math.abs(l -r) < 2 ? Math.max(l, r) +1 : -1;
    }
}
```



#### 15、[112. 路径总和](https://leetcode.cn/problems/path-sum/)

回溯

不能利用空结点做递归出口，得利用叶子结点

因为结点不一定都有两个结点，也就是说，遇到空结点了，它的父节点不一定是叶子，即不是路径终点。

由于只需要一条路径，当找到符合的直接剪枝



```java
class Solution {
    private int sum = 0;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }
        //根
        sum += root.val;
        //递归出口
        if(root.left == null && root.right == null){
            return sum == targetSum;
        }
        //左
        if(root.left != null){
            boolean l = hasPathSum(root.left, targetSum);
            //剪枝
            if(l){
                return true;
            }
            //回溯
            sum -= root.left.val;
        }
        //右
        if(root.right != null){
            boolean r = hasPathSum(root.right, targetSum);
            //剪枝
            if(r){
                return true;
            }
            //回溯
            sum -= root.right.val;
        }
        return false;
    }
}
```



#### 16、[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return build(inorder, postorder, 0, inorder.length -1, 0, postorder.length -1);
    }
    public TreeNode build(int[] in, int[] po, int il, int ir, int pl, int pr){
        if(pl > pr || il > ir){
            return null;
        }
        int ro = 0;
        for(int i = il; i <= ir; i++){
            if(in[i] == po[pr]){
                ro = i;
                break;
            }
        }
        TreeNode node = new TreeNode(po[pr]);
        node.left = build(in, po, il, ro -1, pl, pl + ro -il -1);
        node.right = build(in, po, ro +1, ir, pl +ro -il, pr -1);
        return node;
    }
}
```



#### 17、[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

单调栈

大结点应该让左边最大小结点成为它的左节点，应该成为左边最小大结点的右节点

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode[] st = new TreeNode[nums.length];
        int top = -1;
        for(int v : nums){
            TreeNode node = new TreeNode(v);
            while(top != -1 && st[top].val < v){
                node.left = st[top--];
            }
            if(top != -1){
                st[top].right = node;
            }
            st[++top] = node;
        }
        return st[0];
    }
}
```



#### 18、[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

中序遍历是递增序列

剪枝

```java
class Solution {
    private TreeNode pre = null;
    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        if(!isValidBST(root.left)){
            return false;
        }
        if(pre != null){
            if(pre.val >= root.val){
                return false;
            }
        }
        pre = root;
        return isValidBST(root.right);
    }
}
```



#### 19、[501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

中序遍历连续计数

计数大于历史最大就更新

```java
class Solution {
    private TreeNode pre = null;
    private int cur = 0;
    private int max = 0;
    private List<Integer> li = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        help(root);
        //list转int
        int[] res = new int[li.size()];
        int p = 0;
        for(int v : li){
            res[p++] = v;
        }
        return res;
    }
    public void help(TreeNode r){
        //出口
        if(r == null){
            return;
        }
        //左
        help(r.left);
        //根
        if(pre != null && pre.val == r.val){
            cur++;
        }else{
            cur = 1;
        }
        //更新众数
        if(cur > max){
            li.clear();
            li.add(r.val);
            max = cur;
        }else if(cur == max){
            li.add(r.val);
        }
        pre = r;
        //右
        help(r.right);
    }
}
```

#### 20、[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

将待删除结点移动到叶子，再删除叶子

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null){
            return root;
        }
        //找到目标结点
        if(root.val == key){
            //已经在叶子，直接删除
            if(root.left == null && root.right == null){
                return null;
            }
            //不在叶子，找一个叶子，交换位置，再删除叶子
            TreeNode cur = null;
            if(root.left != null){
                cur = root.left;
                while(cur.right != null){
                    cur = cur.right;
                }
                root.val ^= cur.val;
                cur.val ^= root.val;
                root.val ^= cur.val;
                root.left = deleteNode(root.left, cur.val);
            }else{
                cur = root.right;
                while(cur.left != null){
                    cur = cur.left;
                }
                root.val ^= cur.val;
                cur.val ^= root.val;
                root.val ^= cur.val;
                root.right = deleteNode(root.right, cur.val);
            }
        }else if(root.val > key){
            //目标在左边
            root.left = deleteNode(root.left, key);
        }else{
            //目标在右边
            root.right = deleteNode(root.right, key);
        }
        return root;
    }
}
```



#### 21、[77. 组合](https://leetcode.cn/problems/combinations/)

剪枝可以大大提高效率

无索引是排列

有索引是组合，组合去重用排序或者局部访问标记或者第一个索引

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        backTracking(n, k, 1);
        return res;
    }
    public void backTracking(int n, int k, int index){
        if(k <= 0){
            res.add(new ArrayList<Integer>(path));
            return;
        }
        for(int i = index; i <= n -k +1; i++){
            path.add(i);
            backTracking(n, k -1, i +1);
            path.remove(path.size() -1);
        }
    }
}
```



#### 22、[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

分割方案，不是找回文串

```java
class Solution {
    private List<List<String>> res =  new ArrayList<>();
    private List<String> path = new ArrayList<>();
    private char[] ss;
    private boolean[][] dp;
    public List<List<String>> partition(String s) {
        ss = s.toCharArray();
        dp = new boolean[ss.length][ss.length];
        check();
        backTracking(0);
        return res;
    }
    public void backTracking(int index){
        if(index >= ss.length){
            res.add(new ArrayList<String>(path));
            return;
        }
        for(int i = index; i < ss.length; i++){
            if(dp[index][i]){
                path.add(tostr(index, i));
                backTracking(i +1);
                path.remove(path.size() -1);
            }
        }
    }
    public void check(){
        for(int i = 0; i < ss.length; i++){
            dp[i][i] = true;
        }
        for(int i = ss.length -1; i >= 0; i--){
            for(int j = i; j < ss.length; j++){
                if(ss[i] == ss[j]){
                    if(j -i < 2){
                        dp[i][j] = true;
                    }else{
                        dp[i][j] = dp[i +1][j -1];
                    }
                }
            }
        }
    }
    public String tostr(int l, int r){
        StringBuilder sb = new StringBuilder();
        while(l <= r){
            sb.append(ss[l++]);
        }
        return sb.toString();
    }
}
```



#### 23、[332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

对重复元素的访问标记，不应该使用Set，而是使用boolean数组

```java
class Solution {
    //对重复元素的访问标记，不能使用Set
    private Map<String, boolean[]> used = new HashMap<>();
    private Map<String, List<String>> map = new HashMap<>();
    private List<String> res = new ArrayList<>();
    private int n;
    public List<String> findItinerary(List<List<String>> tickets) {
        //分类
        for(List<String> t : tickets){
            if(map.containsKey(t.get(0))){
                List<String> li = map.get(t.get(0));
                li.add(t.get(1));
            }else{
                List<String> li = new ArrayList<>();
                li.add(t.get(1));
                map.put(t.get(0), li);
            }
        }
        //排序
        map.forEach((key, value)->{
            Collections.sort(value, (a, b)->{
                for(int i= 0;i < 3; i++){
                    if(a.charAt(i) -b.charAt(i) != 0){
                        return a.charAt(i) -b.charAt(i);
                    }
                }
                return 0;
            });
            used.put(key, new boolean[value.size()]);
        });
        //初始化
        n = tickets.size();
        res.add("JFK");
        //递归
        backTracking("JFK", 0);
        return res;
    }
    public boolean backTracking(String pre, int count){
        //出口
        if(count >= n){
            return true;
        }
        if(map.get(pre) == null){
            return false;
        }
        //枚举
        List<String> li = map.get(pre);
        for(int i = 0; i < li.size(); i++){
            if(used.get(pre)[i]){
                continue;
            }
            res.add(li.get(i));
            used.get(pre)[i] = true;
            if(backTracking(li.get(i), count +1)){
                return true;
            }
            //回溯
            res.remove(res.size() -1);
            used.get(pre)[i] = false;
        }
        return false;
    }
}
```

#### 24、[51. N 皇后](https://leetcode.cn/problems/n-queens/)

一维数组表示二维分布

```java
class Solution {
    private int[] q;
    private List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        q = new int[n +1];
        backTracking(n, 1);
        return res;
    }
    public void backTracking(int n, int cur){
        if(cur > n){
            buuld(n);
            return;
        }
        for(int i = 1; i <= n; i++){
            if(check(cur, i)){
                q[cur] = i;
                backTracking(n, cur +1);
                q[cur] = 0;
            }
        }
    }
    public boolean check(int h, int l){
        for(int i = 1; i < h; i++){
            int left = l -(h -i);
            int right = l + (h -i);
            if(q[i] == left || q[i] == right || q[i] == l){
                return false;
            }
        }
        return true;
    }
    public void buuld(int n){
        List<String> cur = new ArrayList<>();
        for(int i = 1; i <= n; i++){
            StringBuilder sb = new StringBuilder();
            for(int j = 1; j <= n; j++){
                if(j == q[i]){
                    sb.append('Q');
                }else{
                    sb.append('.');
                }
            }
            cur.add(sb.toString());
        }
        res.add(cur);
    }
}
```

#### 25、[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

使用数字访问标记

```java
class Solution {
    private char[][] bo;
    //行列块的数字访问标记
    private boolean[][] hu; 
    private boolean[][] lu; 
    private boolean[][] ku; 
    public void solveSudoku(char[][] board) {
        bo = board;
        hu = new boolean[9][10];
        lu = new boolean[9][10];
        ku = new boolean[9][10];
        //初始化
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                if(board[i][j] != '.'){
                    int cur = board[i][j] -'0';
                    hu[i][cur] = true;
                    lu[j][cur] = true;
                    int k = (i/3)*3 + j/3;
                    ku[k][cur] = true;
                }
            }
        }
        //递归
        backTracking(0);
    }
    public boolean backTracking(int cur){
        //出口
        if(cur >= 81){
            return true;
        }
        //位置计算
        int h = cur/9;
        int l = cur %9;
        int k = (h/3)*3 +l/3;
        //枚举数字
        if(bo[h][l] != '.'){
            if(backTracking(cur +1)){
                return true;
            }
        }else{
            for(int i = 1;i  <= 9; i++){
                if(hu[h][i] || lu[l][i] || ku[k][i]){
                    continue;
                }
                bo[h][l] = (char)(i +'0');
                hu[h][i] = true;
                lu[l][i] = true;
                ku[k][i] = true;
                if(backTracking(cur +1)){
                    return true;
                }
                bo[h][l] = '.';
                hu[h][i] = false;
                lu[l][i] = false;
                ku[k][i] = false;
            }
        }
        return false;
    }
}
```

#### 26、[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

dp[i]：以i结尾的最大子数组和

递归：前一个的最大和加上自己，或者自己，取一个最大的；

为什么不可能是前一个的部分加上自己呢？

假设将前一元素的最大连续和分为前后两部分，如果后一部分比全部都要大，那后一部分将会成为前一个元素结尾的最大连续和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int dp = 0;;
        for(int i = 0; i < nums.length; i++){
            dp = Math.max(dp +nums[i], nums[i]);
            max = Math.max(max, dp);
        }
        return max;
    }
}
```

#### 27、[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        //手上的现金，根股票价格无关，只有买入卖出时才会变化
        int hav = -prices[0];
        int nohav = 0;
        int temp;
        for(int i = 1; i < n; i++){
            temp = hav;
            //继续持有或者买入
            hav = Math.max(hav, nohav -prices[i]);
            //继续不持有，或者前一天卖出
            nohav = Math.max(nohav, temp +prices[i]);
        }
        return nohav;
    }
}
```

#### 28、[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/	)

不要把第一个位置纳入考虑，第一个位置不用跳

```java
class Solution {
    public int jump(int[] nums) {
        //当前最远
        int curFar;
        //下一个最远
        int nextFar = nums[0];
        //跳跃次数
        int res = 0;
        //从第二块开始，因为第一块不用跳就能到
        int cur = 1;
        //只要没跳到最后一块就继续跳
        while(cur < nums.length){
            //跳一次
            res++;
            //走到当前能走的最远，更新下一个最远距离
            curFar = nextFar;
            while(cur <= curFar && cur < nums.length){
                nextFar = Math.max(nextFar, cur + nums[cur]);
                cur++;
            }
        }
        return res;
    }
}
```

#### 29、[134. 加油站](https://leetcode.cn/problems/gas-station/)

不可行了，不需要从走过的任何一个点重新统计

因为如果有能迈过去的，初始点肯定可以过去

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int cur = 0;
        int st = 0;
        int n = cost.length;
        //走两圈
        for(int i = 0; i < 2*n; i++){
            //完成一圈
            if(i >= st +n){
                return st;
            }
            //更新
            cur += gas[i %n] -cost[i %n];
            //不可行，从下一个点开始
            if(cur < 0){
                cur = 0;
                st = i +1;
            }
        }
        return -1;
    }
}
```

#### 30、[135. 分发糖果](https://leetcode.cn/problems/candy/)

分别只考虑左边和右边，保证对一边负责的最小糖果数，取左右最大值，保证两边都满足

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int res = n;
        int[] left = new int[n];
        int[] right = new int[n];
        //比左边高，肯定比左边多一颗
        for(int i = 1; i < n; i++){
            if(ratings[i] > ratings[i -1]){
                left[i] = left[i -1] +1;
            }
        }
        //比右边高，肯定比右边多一颗
        for(int i = n -2; i >= 0; i--){
            if(ratings[i] > ratings[i +1]){
                right[i] = right[i +1] +1;
            }
        }
        //取两者最大
        for(int i = 0; i < n; i++){
            res += Math.max(left[i], right[i]);
        }
        return res;
    }
}
```

#### 31、[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

高的先挑位置，序号靠前的先挑位置

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        int n = people.length; 
        //按身高降序排列，身高相同按序号升序排列
        Arrays.sort(people, (a, b)->{
            if(a[0] < b[0]){
                return 1;
            }else if(a[0] > b[0]){
                return -1;
            }else if(a[1] > b[1]){
                return 1;
            }
            return -1;
        });
        //从左往右，序号就是位置
        ArrayList<Integer> list = new ArrayList<>();
        for(int i = 0; i < n; i++){
            list.add(people[i][1], i);
        }
        //答案整理
        int[][] res = new int[n][2];
        for(int i = 0; i < n; i++){
            res[i] = people[list.get(i)];
        }
        return res;
    }
}
```

#### 32、[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

优先移除大区间

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b)->a[0] -b[0]);
        int res = 0;
        int st = intervals[0][0];
        int end = intervals[0][1];
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] < end){
                res++;
                end = Math.min(end, intervals[i][1]);
            }else{
                st = intervals[i][0];
                end = intervals[i][1];
            }
        }
        return res;
    }
}
```

#### 33、[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

递推公式：dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i])

需要满足的前置条件

| 1    | 1       |      |
| ---- | ------- | ---- |
| 1    | 1       |      |
|      | **cur** |      |
|      |         |      |

①、dp[i] [j] **j先遍历**，`j从小往大`：满足递推前置

| 1    | 1       |      |
| ---- | ------- | ---- |
| 1    | 1       |      |
| 1    | **cur** |      |
| 1    |         |      |

②、dp[i] [j] **i先遍历**，`j从小往大`：满足递推前置

| 1    | 1       | 1    |
| ---- | ------- | ---- |
| 1    | 1       | 1    |
| 1    | **cur** |      |
|      |         |      |

③、dp[i] [j] **j先遍历**，`j从大往小`

| 1    |         |      |
| ---- | ------- | ---- |
| 1    |         |      |
| 1    | **cur** |      |
| 1    | 1       |      |

④、dp[i] [j] **i先遍历**，`j从大往小`

| 1    | 1       | 1    |
| ---- | ------- | ---- |
| 1    | 1       | 1    |
|      | **cur** | 1    |
|      |         |      |

③是不正确的递推，没有满足前置条件，上边是空的，所以，容量从大往小计算的时候，只能先遍历货物，再遍历背包，保证上边的货物会先计算出来，即情况④。



故使用一维数组优化时，由于本身存储之前的信息，容量必须从大往小递推，否则递推用到的信息就不是旧的信息了；

由于容量从大往小递推，为了保证正上方的货物信息提前准备好，只能先遍历货物。

正左边的容量信息不是递推条件，否则不能用一维数组优化。



```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i : nums){
            sum += i;
        }
        if(sum %2 == 1){
            return false;
        }
        int[] dp = new int[sum];
        for(int v : nums){
            for(int i = sum/2; i >= v; i--){
                dp[i] = Math.max(dp[i], dp[i -v] + v);
            }
        }
        return dp[sum/2] == sum/2;
    }
}
```

#### 34、[494. 目标和](https://leetcode.cn/problems/target-sum/)



```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        //每个物品都需要放入，每个物品不是加就是减，物品都是正整数；
        //把货物分成两部分，一部分是不取反的和，一部分是取反的和，x + y = target
        //这两部分的绝对值之和是固定的，x - y = sum;
        //联立得2x = target + sum；右边是固定的，说明左边也是固定的；
        //而且左右都是正整数，说明右边如果不是偶数，无解；
        //问题由此转化为，在nums货物中找一部分不取反货物，这部分货物之和为 (target + sum)/2;
        int sum = 0;
        for(int v : nums){
            sum += v;
        }
        int total = sum + target;
        if(total %2 == 1){
            return 0;
        }
        int tar = Math.abs(total/2);
        int[] dp = new int[tar +1];
        dp[0] = 1;
        for(int v  : nums){
            for(int i = tar; i >= v; i--){
                dp[i] += dp[i -v];
            }
        }
        return dp[tar];
    }
}
```

#### 35、[474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //货物：字符串
        //背包：0和1的数量
        //货物不重复，01背包
        //收益：货物的数量
        //dp[i][j]：容量为i和j的背包放入的最大字符串长度；
        int[][] dp = new int[m +1][n +1];
        for(int k = 0; k < strs.length; k++){
            int c0 = 0;
            int c1 = 0;
            for(char c : strs[k].toCharArray()){
                if(c == '0'){
                    c0++;
                }else{
                    c1++;
                }
            }
            for(int i = m; i >= c0; i--){
                for(int j = n; j >= c1; j--){
                    dp[i][j] = Math.max(dp[i][j], dp[i -c0][j -c1] +1);
                }
            }
        }
        return dp[m][n];
    }
}
```

#### 36、[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

先货物后背包是组合；

先背包后货物是排列

背包从小往大是重复；

背包从大往小是不重复；



```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target +1];
        dp[0] = 1;
        //一列一列填每个容量，同一组物体，物体放入顺序不同，也算一种组合
        for(int i = 1; i <= target; i++){
            for(int v : nums){
                if(i -v >= 0){
                    dp[i] += dp[i -v];
                }
            }
        }
        return dp[target];
    }
}
```

#### 37、[139. 单词拆分](https://leetcode.cn/problems/word-break/)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        //货物：单词
        //背包：字符串
        //重量：长度
        //当货物符合一定条件，可以放进背包，问是否能装满背包
        //可重复，背包从小往大；而且重复的位置不集中，所以必须先遍历背包，每个背包都尝试所有的货物
        int n = s.length();
        boolean[] dp = new boolean[n +1];
        dp[0] = true;
        for(int i = 0; i <= n; i++){
            for(String t : wordDict){
                int m = t.length();
                if(i >= m){
                    String cur = s.substring(i -m, i);
                    if(cur.equals(t)){
                        dp[i] = dp[i -m] || dp[i];
                    }
                }
            }
        }
        return dp[n];
    }
}
```

#### 38、[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

三种情况：

偷当前的，还有前两天的；

偷当前的，还有前三天的；

不偷当前的，就是前一天的；

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n ==1){
            return nums[0];
        }
        if(n == 2){
            return Math.max(nums[0], nums[1]);
        }
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = nums[1];
        dp[2] = Math.max(dp[1], dp[0] + nums[2]);
        for(int i = 3; i < n; i++){
            dp[i] = Math.max(dp[i -1], Math.max(dp[i -2] + nums[i], dp[i -3] +nums[i]));
        }
        return dp[n -1];
    }
}
```

#### 39、[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

以当前节点为根的最大收益，要么是偷当前节点，**子节点一个不偷**；要么是不偷当前节点，偷**子节点的最大收益**；

所以，需要知道**不偷两个子节点的收益**、**子节点的最大收益**（包括或者不包括子节点本身）

在数组的时候，不包括前一个元素的收益，可以从前两个找，但是这里，前两个是四个孙子节点，不好判断，因此，递推状态应该包括当前节点偷的最大收益，还有不偷的最大收益，方便判断子节点究竟是偷了还是没偷；

故dp[i]是一个两元素的数组；

先偷完子节点，再判断投不投根节点，选择后序遍历；

由于非递归的后序遍历前驱后继之间可能没有关系，因此不存在递推关系，只能选用递归；

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = help(root);
        return Math.max(res[0], res[1]);
    }
    public int[] help(TreeNode cur){
        if(cur == null){
            return new int[]{0, 0};
        }
        int[] left = help(cur.left);
        int[] right = help(cur.right);
        int val1 = cur.val +left[0] +right[0];
        int val2 = Math.max(left[0], left[1]) +Math.max(right[0], right[1]);
        return new int[]{val2, val1};
    }
}
```

#### 40、[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

递推关系

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int slen = ss.length;
        int tlen = tt.length;
        boolean[][] dp = new boolean[slen +1][tlen +1];
        for(int i = 0; i <= tlen; i++){
            dp[0][i] = true;
        }
        for(int i = 1; i <= slen; i++){
            for(int j = 1; j <= tlen; j++){
                if(ss[i -1] == tt[j -1]){
                    dp[i][j] = dp[i -1][j -1] || dp[i][j -1];
                }else{
                    dp[i][j] = dp[i][j -1];
                }
            }
        }
        return dp[slen][tlen];
    }
}
```

#### 41、[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

搞清楚谁包含谁

```java
class Solution {
    public int numDistinct(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int slen = ss.length;
        int tlen = tt.length;
        int[][] dp = new int[slen +1][tlen +1];
        for(int i = 0; i <= slen; i++){
            dp[i][0] = 1;
        }
        for(int i = 1; i <= slen; i++){
            for(int j = 1; j <= tlen; j++){
                if(ss[i -1] == tt[j -1]){
                    dp[i][j] = dp[i -1][j -1] +dp[i -1][j];
                }else{
                    dp[i][j] = dp[i -1][j];
                }
            }
        }
        return dp[slen][tlen];
    }
}
```

#### 42、[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

回文串的递推是从中间向两边

```java
class Solution {
    public int countSubstrings(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        boolean[][] dp = new boolean[n][n];
        int res = 0;
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(ss[i] == ss[j]){
                    if(j -i < 2){
                        dp[i][j] = true;
                    }else{
                        dp[i][j] = dp[i +1][j -1];
                    }
                    res += dp[i][j] ? 1 : 0;
                }
            }
        }
        return res;
    }
}
```

#### 43、[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

回文串永远是从中间往两边递推

中间字符是什么跟两端字符一点关系都没有，只需要知道中间是不是回文，有多长

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        char[] ss = s.toCharArray();
        int n = ss.length;
        int[][] dp = new int[n][n];
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(j -i == 0){
                    dp[i][j] = 1;
                }else{
                    if(ss[i] == ss[j]){
                        dp[i][j] = dp[i +1][j -1] +2;
                    }else{
                        dp[i][j] = Math.max(dp[i +1][j], dp[i][j -1]);
                    }
                }
            }
        }
        return dp[0][n -1];
    }
}
```

#### 44、[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int[] st = new int[n];
        int top = -1;
        int res = 0;
        for(int i = 0; i < n; i++){
            //以每一个小于当前高度的值为底装雨水
            while(top != -1 && height[st[top]] < height[i]){
                if(top > 0){
                    //左边界(不包括)；右边界i（不包括）
                    int l = st[top -1];
                    //底部高度
                    int mid = st[top];
                    //积水高度
                    int h = Math.min(height[l], height[i]) - height[mid];
                    //积水宽
                    int w = (i -l -1);
                    //积水面积
                    res += w*h;
                }
                top--;
            }
            st[++top] = i;
        }
        return res;
    }
}
```

#### 45、[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        //在前后插入0，保证所有高度会被当成矩阵高度计算一次
        int[] he = new int[n +2];
        for(int i = 0; i < n; i++){
            he[i +1] = heights[i];
        }
        int max = 0;
        int[] st = new int[n +2];
        int top = -1;
        for(int i = 0; i < n +2; i++){
            while(top != -1 && he[st[top]] > he[i]){
                //高度
                int h = he[st[top]];
                //左边界（不包括）；右边界i（不包括）
                int l = st[top -1];
                //宽
                int w = i -l -1;
                //更新最大面积
                max = Math.max(max, h*w);
                top--;
            }
            st[++top] = i;
        }
        return max;
    }
}
```

#### 46、[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        int l = 0;
        int r = n -1;
        if(n == 0){
            return new int[]{-1, -1};
        }
        //找最后一个
        while(l < r){
            int mid = l +(r -l +1)/2;
            if(nums[mid] > target){
                r = mid -1;
            }else{
                l = mid;
            }
        }
        int[] res = new int[2];
        if(nums[l] != target){
            return new int[]{-1,-1};
        }
        res[1] = r;
        l = 0;
        //找第一个
        while(l < r){
            int mid = l +(r -l)/2;
            if(nums[mid] < target){
                l = mid +1;
            }else{
                r = mid;
            }
        }
        res[0] = l;
        return res;
    }
}
```

#### 47、[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head.next == null){
            return true;
        }
        ListNode f = head.next;
        ListNode l = head;
        ListNode pre = null;
        ListNode lnext;
        //快慢指针，反转前半部分结点
        while(f != null && f.next != null){
            lnext = l.next;
            l.next = pre;
            pre = l;
            l = lnext;
            f = f.next.next;
        }
        //获取两个链表头结点
        ListNode head2 = l.next;
        ListNode head1;
        if(f == null){
            head1 = pre;
        }else{
            l.next = pre;
            head1 = l;
        }
        //比较两个链表
        while(head1 != null && head2 != null){
            if(head1.val != head2.val){
                return false;
            }
            head1 = head1.next;
            head2 = head2.next;
        }
        return head1 == head2;
    }
}
```

#### 48、[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode f = head.next;
        ListNode l = head;
        //取一半
        while(f != null && f.next != null){
            f = f.next.next;
            l = l.next;
        }
        //后一半倒转
        ListNode pre = null;
        ListNode st = l.next;
        l.next = null;
        ListNode snext;
        while(st != null){
            snext = st.next;
            st.next = pre;
            pre = st;
            st = snext;
        }
        //获取后边链表头结点
        st = pre;
        //获取前边链表头结点
        ListNode end = head;
        ListNode enext;
        //交叉写入
        while(st != null){
            enext = end.next;
            snext = st.next;
            end.next = st;
            st.next = enext;
            st = snext;
            end = enext;
        }
    }
}
```

#### 49、[205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> map = new HashMap<>();
        Set<Character> set = new HashSet<>();
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        if(ss.length != tt.length){
            return false;
        }
        for(int i = 0; i < ss.length; i++){
            if(map.containsKey(ss[i])){
                if(map.get(ss[i]) != tt[i]){
                    return false;
                }
            }else{
                if(set.contains(tt[i])){
                    return false;
                }
                map.put(ss[i], tt[i]);
                set.add(tt[i]);
            }
        }
        return true;
    }
}
```

#### 50、[1002. 查找共用字符](https://leetcode.cn/problems/find-common-characters/)

```java
class Solution {
    public List<String> commonChars(String[] words) {
        int[] min = new int[27];
        int[] cur = new int[27];
        for(char c : words[0].toCharArray()){
            min[c -'a']++;
        }
        //遍历统计每个单词的字符
        for(int i = 1; i < words.length; i++){
            Arrays.fill(cur, 0);
            for(char c : words[i].toCharArray()){
                cur[c -'a']++;
            }
            //依次合并前后两个单词的公共字符
            add(min, cur);
        }
        //将公共字符转成集合
        List<String> res = new ArrayList<>();
        for(int i = 0; i < 27; i++){
            while(min[i]-- > 0){
                res.add(String.valueOf((char)('a' +i)));
            }
        }
        return res;

    }
    //合并公共部分
    public void add(int[] min, int[] cur){
        for(int i = 0; i < 27; i++){
            min[i] = Math.min(min[i], cur[i]);
        }
    }
}
```

#### 51、[925. 长按键入](https://leetcode.cn/problems/long-pressed-name/)

```java
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        char[] na = name.toCharArray();
        char[] ty = typed.toCharArray();
        int m = na.length;
        int n = ty.length;
        if(m > n || ty[0] != na[0]){
            return false;
        }
        int i = 1;
        int j = 1;
        while(i < m && j < n){
            //字符相等
           if(na[i] == ty[j]){
               i++;
               j++;
           }
           //字符不相等，一定要和前一个字符相同
           else if(ty[j] != ty[j -1]){
               return false;
           }else{
               j++;
           }
        }
        //末尾一定要是最后一个字符重复
        while(j < n && ty[j] == ty[j -1]){
            j++;
        }
        return i == m && j == n;
    }
}
```

#### 52、[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        char[] ss = s.toCharArray();
        char[] tt = t.toCharArray();
        int sc = 0;
        int tc = 0;
        int sl = ss.length;
        int tl = tt.length;
        int sp = sl -1;
        int tp = tl -1;
        //正常两个都应该<0；只要有一个还没小于，应当继续
        while(sp >= 0 || tp >= 0){
            //s找第一个字符
            while(sp >= 0){
                if(ss[sp] == '#'){
                    sp--;
                    sc++;
                }else if(sc > 0){
                    sp--;
                    sc--;
                }else{
                    break;
                }
            }
            //t找第一个字符
            while(tp >= 0){
                if(tt[tp] == '#'){
                    tp--;
                    tc++;
                }else if(tc > 0){
                    tp--;
                    tc--;
                }else{
                    break;
                }
            }
            //比较
            if(tp >= 0 && sp >= 0 && ss[sp] != tt[tp]){
                return false;
            }
            if(tp < 0 && sp < 0){
                return true;
            }
            if(tp < 0 || sp < 0){
                return false;
            }
            sp--;
            tp--;
        }
        //能出来循环，肯定是两个都小于0了
        return true;
    }
}
```

#### 53、[1382. 将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/)

```java
class Solution {
    private TreeNode[] arr = new TreeNode[10001];
    private int n = -1;
    public TreeNode balanceBST(TreeNode root) {
        count(root);
        return build(0, n);
    }
    public void count(TreeNode root){
        if(root.left != null){
            count(root.left);
        }
        arr[++n] = root;
        if(root.right != null){
            count(root.right);
        }
    }
    public TreeNode build(int l, int r){
        if(l > r){
            return null;
        }
        int m = l + (r -l)/2;
        arr[m].left = build(l, m -1);
        arr[m].right = build(m +1, r);
        return arr[m];
    }
}
```

#### 54、[649. Dota2 参议院](https://leetcode.cn/problems/dota2-senate/)

```java
class Solution {
    public String predictPartyVictory(String senate) {
        char[] s = senate.toCharArray();
        int n = s.length;
        //被禁止但是还没禁止的数量
        int rno = 0;
        int dno = 0;
        //有权利的数量
        int rwork = 0;
        int dwork = 0;
        //权力是否被禁止
        boolean[] no = new boolean[n];
        //统计双方数量
        for(char c : s){
            if(c == 'R'){
                rwork++;
            }else{
                dwork++;
            }
        }
        int i = 0;
        //直到一方没有战斗力了退出循环
        while(rwork > 0 && dwork > 0){
            //循环遍历
            i %= n;
            //没有权利的位置
            if(no[i]){
                i++;
                continue;
            }
            //R方
            if(s[i] == 'R'){
                //没有被禁止，禁止对方
                if(rno == 0){
                    dno++;
                    dwork--;
                }
                //被禁止了
                else{
                    rno--;
                    no[i] = true;
                }
            }else{
                if(dno == 0){
                    rno++;
                    rwork--;
                }else{
                    dno--;
                    no[i] = true;
                }
            }
            i++;
        }
        return rwork  == 0 ? "Dire" : "Radiant";
    }
}
```

#### 55、[132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

```java
class Solution {
    public int minCut(String s) {
        char[] ss= s.toCharArray();
        int n = ss.length;
        //计算任意两个位置之间是不是回文
        boolean[][] dp = new boolean[n][n];
        for(int i = n -1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(ss[i] == ss[j]){
                    if(j -i < 2){
                        dp[i][j] = true;
                    }else{
                        dp[i][j] = dp[i +1][j -1];
                    }
                }
            }
        }
        int[] dp2 = new int[n];
        Arrays.fill(dp2, n);
        //递推以i结尾地字符串的最小分割数
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= i; j++){
                if(dp[j][i]){
                    if(j > 0){
                        dp2[i] = Math.min(dp2[i], dp2[j -1] +1);
                    }else{
                        dp2[i] = 0;
                    }
                }
            }
        }
        return dp2[n -1];
    }
}
```

#### 56、[673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        int[][] dp = new int[n][2];
        //历史最长
        int max = 1;
        int res = 0;
        //初始化
        for(int i = 0; i < n; i++){
            dp[i][0] = 1;
            dp[i][1] = 1;
        }
        for(int i = 0; i < n; i++){
            //以i结尾的最长和最多
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    if(dp[i][0] < dp[j][0] +1){
                        dp[i][0] = dp[j][0] +1;
                        dp[i][1] = dp[j][1];
                    }else if(dp[i][0] == dp[j][0] +1){
                        dp[i][1] += dp[j][1];
                    }
                }
            }
            //更新历史最长最多
            if(dp[i][0] > max){
                max = dp[i][0];
                res = dp[i][1];
            }else if(dp[i][0] == max){
                res += dp[i][1];
            }
        }
        return res;
    }
}
```

#### 57、[841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        boolean[] visit = new boolean[n];
        int[] q = new int[1001];
        int in = 1;
        int out = 0;
        int count = 1;
        visit[0] = true;
        //层序遍历
        while(in > out && count < n){
            for(int v : rooms.get(q[out++])){
                if(!visit[v]){
                    q[in++] = v;
                    count++;
                    visit[v] = true;
                }
            }
        }
        return count == n;
    }
}
```

#### 58、[127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        int n = wordList.size();
        int m = wordList.get(0).length();
        //字符串转数组
        char[][] wos = new char[n][m];
        for(int i = 0; i< n; i++){
            wos[i] = wordList.get(i).toCharArray();
        }
        //队列
        int[] q = new int[n];
        int in = 0;
        int out = 0;
        //访问标记
        boolean[] used = new boolean[n];
        //初始化
        char[] be = beginWord.toCharArray();
        for(int i = 0; i < n; i++){
            if(checkIs(be, wos[i])){
                q[in++] = i;
                used[i] = true;
            }
        }
        int count = 1;
        //遍历队列
        while(in > out){
            int size = in -out;
            //层序遍历
            while(size-- > 0){
                int cur = q[out++];
                //结束判断
                if(wordList.get(cur).equals(endWord)){
                    return count +1;
                }
                //邻居入队
                for(int i = 0; i < n; i++){
                    if(!used[i] && checkIs(wos[cur], wos[i])){
                        q[in++] = i;
                        used[i] = true;
                    }
                }
            }
            count++;
        }
        return 0;
    }
    //检查是不是邻居
    public boolean checkIs(char[] a, char[] b){
        boolean f = false;
        for(int i = 0; i < a.length; i++){
            if(a[i] != b[i]){
                if(!f){
                    f = true;
                }else{
                    return false;
                }
            }
        }
        return f;
    }
}
```

#### 59、[1356. 根据数字二进制下 1 的数目排序](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)

```java
class Solution {
    public int[] sortByBits(int[] arr) {
        int[] map = new int[10001];
        //计数
        for(int v : arr){
            int count = 0;
            int cur = v;
            while(cur != 0){
                cur &= cur -1;
                count++;
            }
            map[v] = count;
        }
        //装箱
        Integer[] a = new Integer[arr.length];
        for(int i = 0; i < arr.length; i++){
            a[i] = arr[i];
        }
        //排序
        Arrays.sort(a,(m,n)->{
            if(map[m] > map[n]){
                return 1;
            }else if(map[m] < map[n]){
                return -1;
            }
            return m -n;
        });
        //拆箱
        for(int i = 0; i < arr.length; i++){
            arr[i] = a[i];
        }
        return arr;
    }
}
```

#### 60、[685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)

```java
class Solution {
    private int[] in = new int[1001];
    private int[] far = new int[1001];
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int n = edges.length;
        //统计入度
        for(int i = 0; i < n; i++){
            in[edges[i][1]]++;
        }
        //优先检查入度为2,尝试删除，删除后满足树就删除这条边，靠后优先
        for(int i = n -1; i >= 0; i--){
            if(in[edges[i][1]] > 1 && removeTry(edges, i)){
               return edges[i];
            }
        }
        //从前往后找第一条破坏稳定的边
        Arrays.fill(far, 0);
        for(int i = 0; i < n; i++){
            int fa = find(edges[i][0]);
            int fb = find(edges[i][1]);
            if(fa == fb){
                return edges[i];
            }
            far[fa] = fb;
        }
        return null;
    }
    //找爸爸
    public int find(int a){
        while(far[a] != 0){
            a = far[a];
        }
        return a;
    }
    //尝试删除，就是跳过这构建查并集
    public boolean removeTry(int[][] edges, int k){
        Arrays.fill(far, 0);
        for(int i = 0; i < edges.length; i++){
            if(i == k){
                continue;
            }
            int fa = find(edges[i][0]);
            int fb = find(edges[i][1]);
            if(fa == fb){
                return false;
            }
            far[fa] = fb;
        }
        return true;
    }
}
```

