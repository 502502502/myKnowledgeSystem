# 七、回溯

## 1、组合

### ①、[题目链接](https://leetcode.cn/problems/combinations/)

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。

 

示例 1：

输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
示例 2：

输入：n = 1, k = 1
输出：[[1]]


提示：

1 <= n <= 20
1 <= k <= n



### ②、思路

回溯剪纸

剪纸主要是在水平方向上

### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        backtracking(1, n, k);
        return res;
    }
    public void backtracking(int cur, int n, int k){
        if(k == 0){
            res.add(new ArrayList<>(temp));
            return;
        }
        while(cur <= n -k +1){
            temp.add(cur++);
            backtracking(cur, n, k -1);
            temp.remove(temp.size() -1);
        }
    }
}
```



## 2、组合Ⅲ

### ①、[题目链接](https://leetcode.cn/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

只使用数字1到9
每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

 

示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
示例 3:

输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。


提示:

2 <= k <= 9
1 <= n <= 60



### ②、思路

回溯

当个数超过k之后退出递归

### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(1, 0, n, k);
        return res;
    }
    public void backtracking(int index, int cur, int sum, int k){
        if(k == 0){
            if(cur == sum){
                res.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        while(index < 10){
            temp.add(index++);
            backtracking(index, cur +index -1, sum, k -1);
            temp.remove(temp.size() -1);
        }
    }
}
```



## 3、电话号码

### ①、[题目链接](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



 

示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：

输入：digits = ""
输出：[]
示例 3：

输入：digits = "2"
输出：["a","b","c"]


提示：

0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。



### ②、思路

回溯

### ③、代码

```java
class Solution {
    private List<String> res = new ArrayList<>();
    private StringBuilder sb = new StringBuilder();
    private Map<Integer, char[]> map = new HashMap<>();
    public List<String> letterCombinations(String digits) {
        map.put(2, new char[]{'a', 'b', 'c'});
        map.put(3, new char[]{'d', 'e', 'f'});
        map.put(4, new char[]{'g', 'h', 'i'});
        map.put(5, new char[]{'j', 'k', 'l'});
        map.put(6, new char[]{'m', 'n', 'o'});
        map.put(7, new char[]{'p', 'q', 'r', 's'});
        map.put(8, new char[]{'t', 'u', 'v'});
        map.put(9, new char[]{'w', 'x', 'y', 'z'});
        if(!digits.equals("")){
           backtracking(0, digits);
        }
        return res;
    }
    public void backtracking(int index, String dig){
        if(index == dig.length()){
            res.add(sb.toString());
            return;
        }
        for(char c : map.get(dig.charAt(index) -'0')){
            sb.append(c);
            backtracking(index +1, dig);
            sb.delete(sb.length() -1, sb.length());
        }
    }
}
```



## 4、组合总和

### ①、[题目链接](https://leetcode.cn/problems/combination-sum/)

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

 

示例 1：

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
示例 2：

输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
示例 3：

输入: candidates = [2], target = 1
输出: []


提示：

1 <= candidates.length <= 30
1 <= candidates[i] <= 200
candidate 中的每个元素都 互不相同
1 <= target <= 500



### ②、思路

回溯

排序后剪枝，在水平方向上，如果当前已经大于总和，之后的元素就不必试了

### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates, target, 0);
        return res;
    }
    public void backtracking(int[] can, int tar,  int index){
        if(tar <= 0){
            if(tar == 0){
                res.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        while(index < can.length && tar -can[index] >= 0){
            temp.add(can[index]);
            backtracking(can, tar -can[index], index++);
            temp.remove(temp.size() -1);
        }
    }
}
```



## 5、组合总和Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/combination-sum-ii/)

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 

 

示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
示例 2:

输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]


提示:

1 <= candidates.length <= 100
1 <= candidates[i] <= 50
1 <= target <= 30



### ②、思路

回溯，

排序

剪枝：如果加上当前元素已经大于等于总和，那么本层之后的元素就没有必要继续了，要么重复，要么大于

去重：对于重复的元素，深度递归的时候可以重复利用，但是水平枚举的时候不可以重复利用；

如何确定是递归呢？

如果当前元素和上一个重复，且这是本次循环的第一个元素，那就是深度递归，可以使用当前元素；

否则就是水平枚举，不应当使用当前这个重复的元素

### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates, target, 0);
        return res;
    }
    public void backtracking(int[] can, int tar, int index){
        if(tar <= 0){
            if(tar == 0){
                res.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        for(int i = index; i < can.length && tar -can[i] >= 0; i++){
            if(i > 0 && can[i] == can[i -1] && i != index){
                continue;
            }
            temp.add(can[i]);
            backtracking(can, tar -can[i], i +1);
            temp.remove(temp.size() -1);
        }
    }
}
```

## 6、分割回文串

### ①、[题目链接](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

 

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
示例 2：

输入：s = "a"
输出：[["a"]]


提示：

1 <= s.length <= 16
s 仅由小写英文字母组成



### ②、思路

集合中每一种元素是一个切割方案，所有方案即组合问题，回溯保存共同路径

枚举当前需要分割出来的区间，剩下的递归构造即可

如果当前切割的子串不是回文串，就不需要递归了，直接回溯



### ③、代码

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();
    private List<String> temp = new ArrayList<>();
    public List<List<String>> partition(String s) {
        backtracking(s, 0);
        return res;
    }
    public void backtracking(String s, int index){
        if(index >= s.length()){
            res.add(new ArrayList<String>(temp));
            return;
        }
        for(int i = index +1; i <= s.length(); i++){
            String cur = s.substring(index, i);
            if(check(cur)){
                temp.add(cur);
                backtracking(s, i);
                temp.remove(temp.size() -1);
            }
        }
    }
    public boolean check(String s){
        int i = 0; 
        int j = s.length() -1;
        while(i < j){
            if(s.charAt(i++) != s.charAt(j--)){
                return false;
            }
        }
        return true;
    }
}
```



## 7、复原IP地址

### ①、[题目链接](https://leetcode.cn/problems/restore-ip-addresses/)

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

 

示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
示例 2：

输入：s = "0000"
输出：["0.0.0.0"]
示例 3：

输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]


提示：

1 <= s.length <= 20
s 仅由数字组成



### ②、思路

回溯剪枝

如果切割下来当前整数后，后边的整数位数过大，直接剪枝

如果当前整数含有前导0，直接剪枝



### ③、代码

```java
class Solution {
    public List<String> res = new ArrayList<>();
    private StringBuilder sb = new StringBuilder();
    public List<String> restoreIpAddresses(String s) {
        backtracking(s, 0, 0);
        return res;
    }
    public void backtracking(String s, int index, int count){
        //中止条件
        if(count == 4){
            res.add(sb.toString());
            return;
        }
        for(int i = index +1; i <= s.length() && i < index +4; i++){
            //剪枝
            if(s.length()- i > (3*(3 -count))){
                continue;
            }
            if(i != index +1 && s.charAt(index) == '0'){
                break;
            }
            //递归回溯
            String cur = s.substring(index, i);
            if(check(cur)){
                sb.append(cur);
                if(count < 3){
                    sb.append('.');

                }
                backtracking(s, i, count +1);
                sb.delete(sb.length() -(i -index), sb.length());
                if(count < 3){
                    sb.delete(sb.length() -1, sb.length());
                }
            }
        }
    }
    public boolean check(String s){
        if(s.length() < 3){
            return true;
        }
        int sum = 0;
        for(int i = 0; i < 3; i++){
            sum *= 10;
            sum += s.charAt(i) -'0';
        }
        return sum <= 255;
    }
}
```



## 8、子集

### ①、[题目链接](https://leetcode.cn/problems/subsets/)

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：

输入：nums = [0]
输出：[[],[0]]


提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同

### ②、思路

回溯加索引



### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtraking(nums, 0);
        return res;
    }
    public void backtraking(int[] nums, int index){
        res.add(new ArrayList<Integer>(temp));
        for(int i = index; i < nums.length; i++){
            temp.add(nums[i]);
            backtraking(nums, i +1);
            temp.remove(temp.size() -1);
        }
    }
}
```



## 9、子集Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

 

示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
示例 2：

输入：nums = [0]
输出：[[],[0]]


提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10



### ②、思路

回溯去重

去重需要先排序

### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        backtracking(nums, 0);
        return res;
    }
    public void backtracking(int[] nums, int index){
        res.add(new ArrayList<Integer>(temp));
        for(int i = index; i < nums.length; i++){
            if(i > 0 && nums[i] == nums[i -1] && i != index){
                continue;
            }
            temp.add(nums[i]);
            backtracking(nums, i +1);
            temp.remove(temp.size() -1);
        }
    }
}
```



## 10、递增子序列

### ①、[题目链接](https://leetcode.cn/problems/increasing-subsequences/)

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

示例 1：

输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
示例 2：

输入：nums = [4,4,3,2,1]
输出：[[4,4]]


提示：

1 <= nums.length <= 15
-100 <= nums[i] <= 100

### ②、思路

递归加回溯

非降序剪枝

对于重复元素，如果不可以排序，那就设立一个本层的局部访问表，本层不可以重复使用元素



### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums, 0);
        return res;
    }
    public void backtracking(int[] nums, int index){
        if(temp.size() > 1){
            res.add(new ArrayList<Integer>(temp));
        }
        Set<Integer> used = new HashSet<>();
        for(int i = index; i < nums.length; i++){
            //非降
            if(temp.size() > 0 && nums[i] < temp.get(temp.size() -1)){
                continue;
            }
            //去重，本层不得再使用已经用过的元素
            //重复元素只能在下一层使用
            if(used.contains(nums[i])){
                continue;
            }
            temp.add(nums[i]);
            used.add(nums[i]);
            backtracking(nums, i +1);
            temp.remove(temp.size() -1);
        }
    }
}
```

## 11、全排列

### ①、[题目链接](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]


提示：

1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同



### ②、思路

回溯

使用过的元素在同一条路径不能再使用，使用访问数组标记即可

### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    private boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        backtracking(nums);
        return res;
    }
    public void backtracking(int[] nums){
        if(temp.size() == nums.length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(!used[i]){
                temp.add(nums[i]);
                used[i] = true;
                backtracking(nums);
                temp.remove(temp.size() -1);
                used[i] = false;
            }
        }
    }
}
```



## 12、全排列Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/permutations-ii/)

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]


提示：

1 <= nums.length <= 8
-10 <= nums[i] <= 10



### ②、思路

回溯

同一条路径不能使用重复的位置，全局访问标记数组

同一层枚举不能重复使用元素，与索引无关，故索引+排序失效，使用Set保存访问过的元素



### ③、代码

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> temp = new ArrayList<>();
    private boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];
        backtracking(nums);
        return res;
    }
    public void backtracking(int[] nums){
        if(temp.size() == nums.length){
            res.add(new ArrayList<Integer>(temp));
            return;
        }
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < nums.length; i++){
            if(!used[i] && !set.contains(nums[i])){
                temp.add(nums[i]);
                used[i] = true;
                set.add(nums[i]);
                backtracking(nums);
                temp.remove(temp.size() -1);
                used[i] = false;
            }
        }
    }
}
```



## 13、重新安排行程

### ①、[题目链接](https://leetcode.cn/problems/reconstruct-itinerary/)

给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

 

示例 1：


输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
示例 2：


输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。


提示：

1 <= tickets.length <= 300
tickets[i].length == 2
fromi.length == 3
toi.length == 3
fromi 和 toi 由大写英文字母组成
fromi != toi



### ②、思路

就是机票的一个重新排列，用回溯

用Map按出发城市将**机票分组**

按字典序将每个城市的**机票排序**

每次从当前城市按次序选一张没用过的机票，同一路径不可重复，使用**访问标记**

遇到第一个满足的方案即为答案，中止回溯；

### ③、代码

```java
class Solution {
    private List<String> res = new ArrayList<>();//方案
    private boolean f = false;//是否找到第一种方案
    private int len;//票数
    private Map<String, List<String>> map = new HashMap<>();//从每个城市出发的票
    private Map<String, boolean[]> used = new HashMap<>();//票是否已经被本次方案使用
    public List<String> findItinerary(List<List<String>> tickets) {
        //将票归类
        for(List<String> i : tickets){
            if(map.containsKey(i.get(0))){
                map.get(i.get(0)).add(i.get(1));
            }
            else{
                List<String> list = new ArrayList<>();
                list.add(i.get(1));
                map.put(i.get(0), list);
                used.put(i.get(0), new boolean[100]);
            }
        }
        //将票排序
        for(List<String> list : map.values()){
            Collections.sort(list, (a, b)-> {
                for(int i  = 0; i < 3; i++){
                    if(a.charAt(i) < b.charAt(i)){
                        return -1;
                    }
                    if(a.charAt(i) > b.charAt(i)){
                        return 1;
                    }
                }
                return -1;
                }
            );
        }
        //初始化
        len = tickets.size();
        res.add("JFK");
        //递归
        backtracking();
        return res;
    }
    public void backtracking(){
        //中止
        if(res.size() > len){
            f = true;
            return;
        }
        String key = res.get(res.size() -1);
        boolean[] u = used.get(key);
        List<String> list = map.get(key);
        //从该城市出发没有票
        if(list == null){
            return;
        }
        //遍历从该城市出发的票
        for(int i = 0; i < list.size(); i++){
            if(!u[i]){
                res.add(list.get(i));
                u[i] = true;
                backtracking();
                if(f){
                    return;
                }
                u[i] = false;
                res.remove(res.size() -1);
            }
        }
    }
}
```



## 14、N皇后

### ①、[题目链接](https://leetcode.cn/problems/n-queens/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

 

示例 1：


输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
示例 2：

输入：n = 1
输出：[["Q"]]


提示：

1 <= n <= 9



### ②、思路

回溯

递归每一行

枚举每行的位置，若合法，递归下一行，否则回溯，找下一个位置

矩阵更已于回溯和判断，因此，使用矩阵进行方案的构建，最后再将方案转化为字符串

### ③、代码

```java
class Solution {
    public List<List<String>> res = new ArrayList<>();//所以方案
    private int[][] temp;//方案矩阵
    private int n;//皇后总数
    public List<List<String>> solveNQueens(int n) {
        this.temp = new int[n][n];
        this.n = n;
        backtracking(0);
        return res;
    }
    public void backtracking(int index){
        if(index >= n){
            res.add(make());
            return;
        }
        //每行枚举每个位置
        for(int i = 0; i < n; i++){
            //递归合法的位置，若失败则回溯
            if(check(index, i)){
                temp[index][i] = 1;
                backtracking(index +1);
                temp[index][i] = 0;
            }
        }
    }
    //将方案矩转化为字符串集合
    public List<String> make(){
        List<String> cur = new ArrayList<>();
        for(int i = 0; i < n; i++){
            StringBuilder sb = new StringBuilder();
            for(int j = 0; j < n; j++){
                if(temp[i][j] == 1){
                    sb.append('Q');
                }
                else{
                    sb.append('.');
                }
            }
            cur.add(sb.toString());
        }
        return cur;
    }
    //判断某个位置是否合法
    public boolean check(int index, int j){
        for(int i = 0; i < index; i++){
            if(temp[i][j] == 1){
                return false;
            }
            if(i +j -index >= 0 && temp[i][i +j -index] == 1){
                return false;
            }
            if(j + index -i < n && temp[i][j +index -i] == 1){
                return false;
            }
        }
        return true;
    }
}
```



## 15、数独

### ①、[题目链接](https://leetcode.cn/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

 

示例 1：


输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：




提示：

board.length == 9
board[i].length == 9
board[i][j] 是一位数字或者 '.'
题目数据 保证 输入数独仅有一个解



### ②、思路

回溯

枚举当前位置的所有能填的数字，递归下一层

如果当前位置所有数字都不能构成解决方案，回到上一步，并将本次修改复原。

判断合法性：

+ 行合法
+ 列合法
+ 块合法
  + 先计算当前位置的块号
  + 遍历当前块所在的三行三列



### ③、代码

```java
class Solution {
    private boolean f = false;//找到解决方案
    public void solveSudoku(char[][] board) {
        backtracking(board, 0, 0);
    }
    public void backtracking(char[][] bo, int i, int j){
        if(i >= 9){
            f = true;
            return;
        }
        //当前位置不需要枚举
        if(bo[i][j] != '.'){
            backtracking(bo, i +(j +1)/9, (j +1)%9);
        }
        else{
            //在当前位置枚举所有数字，看看哪个合法
            for(char v = '1'; v <= '9' && !f; v++){
                //合法数字先填入，递归下一个位置
                if(check(bo, v, i, j)){
                    bo[i][j] = v;
                    backtracking(bo, i +(j +1)/9, (j +1)%9);
                }
            }
            //当前位置的所有合法数组都不能构成解决方案，回到上一步，选择别的合法数字
            if(!f){
                bo[i][j] = '.';
            }
        }
    }
    //检查当前位置填入某数字时的合法性
    public boolean check(char[][] bo, char v, int i, int j){
        for(int k = 0; k < 9; k++){
            if(bo[i][k] == v || bo[k][j] == v){
                return false;
            }
        }
        int po = (i/3)*3 +j/3;
        int st = (po/3)*3;
        int lt = (po%3)*3;
        for(int m = st; m < st +3; m++){
            for(int n = lt; n < lt +3; n++){
                if(bo[m][n] == v){
                    return false;
                }
            }
        }
        return true;
    }
}
```













# 八、贪心

## 1、分发饼干

### ①、[题目链接](https://leetcode.cn/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。


示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.


提示：

1 <= g.length <= 3 * 104
0 <= s.length <= 3 * 104
1 <= g[i], s[j] <= 231 - 1



### ②、思路

贪心，用尽量小的饼干满足最小的胃口

将胃口和饼干非降排序，从小饼干开始分发，能满足最小的胃口就发，否则换下一块大一点的饼干



### ③、代码

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0;
        int j = 0;
        while(i < s.length && j < g.length){
            if(s[i++] >= g[j]){
                j++;
            }
        }
        return j;
    }
}
```



## 2、摆动序列

### ①、[题目链接](https://leetcode.cn/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

 

示例 1：

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
示例 2：

输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
示例 3：

输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2


提示：

1 <= nums.length <= 1000
0 <= nums[i] <= 1000


进阶：你能否用 O(n) 时间复杂度完成此题?



### ②、思路

只记录波峰波谷，每次遇到不拐弯的，如果比上一次选的要大或者小，就抛弃之前选的，因为它不是峰值

<img src="https://ningct.oss-cn-hangzhou.aliyuncs.com/image-20220914082717212.png" alt="image-20220914082717212" style="zoom:50%;" />

### ③、代码

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int res = 1;
        int cur = 0;
        for(int i = 1; i < nums.length; i++){
            if(cur == 0){
                if(nums[i] == nums[i -1]){
                    continue;
                }
                res++;
                cur = nums[i] > nums[i -1] ? 1 : -1;
            }
            else if(cur == 1 && nums[i] < nums[i -1] || cur == -1 && nums[i] > nums[i -1]){
                    res++;
                    cur *= -1;
            }
        }
        return res;
    }
}
```



## 3、最大子数组和

### ①、[题目链接](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104


进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。



### ②、思路

不断的尝试子数组，记录最大值

如果之前的子数组和是正数，加了当前值还是正数（哪怕变小了），都有可能是最大子数组的部分

否则从当前元素开始记录子数组



### ③、代码

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int cur = nums[0];
        for(int i = 1; i < nums.length; i++){
            if(cur > 0 && cur + nums[i] > 0){
                cur += nums[i];
            }
            else{
                cur = nums[i];
            }
            max = max > cur ? max : cur;
        }
        return max;
    }
}
```



## 4、买卖股票的最佳时机 II

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 

示例 1：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
示例 3：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。


提示：

1 <= prices.length <= 3 * 104
0 <= prices[i] <= 104



### ②、思路

以天为单位，每次上涨都要赚，如果比昨天贵了，那就昨天买，今天卖。

### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        for(int i = 1; i < prices.length; i++){
            int x = prices[i] -prices[i -1];
            res += x > 0 ? x : 0;
        }
        return res;
    }
}
```



## 5、跳跃游戏

### ①、[题目链接](https://leetcode.cn/problems/jump-game/)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。


提示：

1 <= nums.length <= 3 * 104
0 <= nums[i] <= 105




### ②、思路

每次更新能到达的最远距离，若超过自己能到达的最远距离或者走到尽头就退出遍历



### ③、代码

```java
class Solution {
    public boolean canJump(int[] nums) {
        int far = 0;
        for(int i = 0; i < nums.length && i <= far; i++){
            int cur = i + nums[i];
            far = far < cur ? cur : far;
        }
        return far >= nums.length -1;
    }
}
```

## 6、跳跃游戏Ⅱ

### ①、[题目链接](https://leetcode.cn/problems/jump-game-ii/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2


提示:

1 <= nums.length <= 104
0 <= nums[i] <= 1000



### ②、思路

这一步没走完，不更新下一步，选择一个最远的距离进行下一步的更新

### ③、代码

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length == 1){
            return 0;
        }
        int res = 1;
        int far = nums[0];//当前最远距离
        int curmax = nums[0];//在到达最远距离前，能够更新到的最远距离
        for(int i = 1; i < nums.length && far < nums.length -1; i++){
            //未到达当前最远距离，更新下一步能到的最远
            if(i <= far){
                int cur = i + nums[i];
                curmax = curmax < cur ? cur : curmax;
            }
            //到达最远距离了，更新下一步的最远距离
            else{
                res++;
                far = curmax;
                curmax = i + nums[i];
            }
        }
        return res;
    }
}
```



## 7、K 次取反后最大化的数组和

### ①、[题目链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

以这种方式修改数组后，返回数组 可能的最大和 。

 

示例 1：

输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
示例 2：

输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
示例 3：

输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。


提示：

1 <= nums.length <= 104
-100 <= nums[i] <= 100
1 <= k <= 104

### ②、思路

每次取一个最小值进行取反



### ③、代码

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(Integer i : nums){
            pq.add(i);
        }
        for(int i = 0; i < k; i++){
            Integer top = pq.remove();
            top *= -1;
            pq.add(top);
        }
        int sum = 0;
        while(!pq.isEmpty()){
            sum += pq.remove();
        }
        return sum;
    }
}
```



## 8、加油站

### ①、[题目链接](https://leetcode.cn/problems/gas-station/)

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

 

示例 1:

输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
示例 2:

输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。


提示:

gas.length == n
cost.length == n
1 <= n <= 105
0 <= gas[i], cost[i] <= 104



### ②、思路

滑动窗口，若窗口值小于0，更新左端点，

更新时直接更新为右端点即可，因此从窗口左端点到窗口内任意一点都是非负的，整个窗口不行，谁也不行。

若右端点已经循环了，还不行，说明所有位置为起点都不行

### ③、代码

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int st = 0;
        int end = 1;
        int n = gas.length;
        for(int i = 0; i < n; i++){
            gas[i] -= cost[i];
        }
        int cur = gas[0];
        while(st < n && st != end && end < n){
            if(cur < 0){
                if(st > end){
                    break;
                }
                cur = 0;
                st = end;
            }
            cur += gas[end++];
            end %= n;
        }
        return cur >= 0 ? st : -1;
    }
}
```



## 9、* 分糖果

### ①、[题目链接](https://leetcode.cn/problems/candy/)

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

 

示例 1：

输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
示例 2：

输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。


提示：

n == ratings.length
1 <= n <= 2 * 104
0 <= ratings[i] <= 2 * 104



### ②、思路

右边比左边大，右边的糖果应该比左边多1；

左边比右边大，左边的糖果应该比右边多1；

每个元素都需要比较它的前后，以上前者需要从前向后遍历，后者需要从后向前遍历，因为需要到遍历过的最近一次结果

### ③、代码

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] can = new int[n];
        int sum = n;
        int i = 1;
        int j = ratings.length -2;
        while(i < n){
            if(ratings[i] > ratings[i -1]){
                can[i] = can[i -1] +1;
            }
            i++;
        }
        while(j >= 0){
            if(ratings[j] > ratings[j +1]){
                can[j] = Math.max(can[j +1] +1, can[j]);
            }
            sum += can[j];
            j--;
        }
        sum += can[n -1];
        return sum;
    }
}
```



## 10、柠檬水找零

### ①、[题目链接](https://leetcode.cn/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

 

示例 1：

输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
示例 2：

输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。


提示：

1 <= bills.length <= 105
bills[i] 不是 5 就是 10 或是 20 



### ②、思路

记录五块的张数和十块的张数，每次看看够不够找

### ③、代码

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;
        for(int i = 0; i < bills.length && five >= 0; i++){
            if(bills[i] == 5){
                five++;
            }
            else if(bills[i] == 10){
                five--;
                ten++;
            }
            else{
                if(ten == 0){
                    five -= 3;
                }
                else{
                    five--;
                    ten--;
                }
            }
        }
        return five >= 0 && ten >= 0;
    }
}
```

## 11、* 根据身高建队

### ①、[题目链接](https://leetcode.cn/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

 

示例 1：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
示例 2：

输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]


提示：

1 <= people.length <= 2000
0 <= hi <= 106
0 <= ki < people.length
题目数据确保队列可以被重建

### ②、思路

先按照身高非增排序，若身高相同，按照序号排队

从前往后遍历，前面的元素都比当前元素的身高要大，因此序号就是当前数组的下标，插入即可

### ③、代码

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b)->{
            if(b[0] > a[0]){
                return 1;
            }
            else if(b[0] < a[0]){
                return -1;
            }
            else{
                return a[1] -b[1];
            }
        });
        List<int[]> st = new LinkedList<>();
        for(int i = 0; i < people.length; i++){
            st.add(people[i][1], people[i]);
        }
        return st.toArray(new int[0][0]);
    }
}
```



## 12、用最少数量的箭引爆气球

### ①、[题目链接](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。


示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
示例 2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
示例 3：

输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。


提示:

1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1



### ②、思路

左端点排序，

遍历气球

找重叠区间，更新重叠区间



### ③、代码

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a,b)->{
            if(a[0] < b[0]){
                return -1;
            }
            return 1;
        });
        int res = points.length;
        int st = points[0][0];
        int end = points[0][1];
        for(int i = 1; i < points.length; i++){
            if(end >= points[i][0] && points[i][0] >= st){
                end = Math.min(end, points[i][1]);
                st = Math.max(st, points[i][0]);
                res--;
            }
            else{
                st = points[i][0];
                end = points[i][1];
            }
        }
        return res;
    }
}
```



## 13、无重叠区间

### ①、[题目链接](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

 

示例 1:

输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。


提示:

1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104



### ②、思路

按左端点排序，注意相同要返回0

从前往后遍历，检查区间重叠情况

包含当前区间删除上一个，

包含当前区间的一部分删除当前区间

### ③、代码

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b)->{
            if(a[0] < b[0]){
                return -1;
            }
            else if(a[0] > b[0]){
                return 1;
            }
            return 0;
        });
        int res = 0;
        int st = intervals[0][0];
        int end = intervals[0][1];
        for(int i = 1; i < intervals.length; i++){
            //包含在内,移除大区间
            if(intervals[i][1] <= end){
                res++;
                st = intervals[i][0];
                end = intervals[i][1];
            }
            //包含一部分，移除当前区间，如果当前区间和后面区间没有重叠，那么上一个区间自然不会；
            //如果当前区间与之后有重叠，上一个区间可能有，可能没有，不会比当前区间坏；
            else if(intervals[i][0] < end){
                res++;
            }
            //无重叠，更新区间
            else{
                st = intervals[i][0];
                end = intervals[i][1];
            }
        }
        return res;
    }
}
```



## 14、划分字母区间

### ①、[题目链接](https://leetcode.cn/problems/partition-labels/)

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

 

示例：

输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。


提示：

S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。



### ②、思路

保存每个字母的最远距离

从前往后遍历，更新最远距离

若已经达到最远距离，说明应该分段了

注意，若使用HashMap，效率会低很多



### ③、代码

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> res = new ArrayList<>();
        int[] map = new int[26];
        int n = s.length();
        for(int i = 0; i < n; i++){
            map[s.charAt(i) -'a'] = i;
        }
        int st = 0;
        int end = map[s.charAt(st) -'a'];
        for(int i = 0; i < n; i++){
            end = Math.max(end, map[s.charAt(i) -'a']);
            if(i == end){
                res.add(end -st +1);
                st = end +1;
            }
            else{
                map[s.charAt(i) -'a']= 0;
            }
        }
        return res;
    }
}
```



## 15、合并区间

### ①、[题目链接](https://leetcode.cn/problems/merge-intervals/)

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。


提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104



### ②、思路

左端点排序

从前往后遍历，重叠合并，不重叠保存

原地修改，最后复制一份即可

### ③、代码

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a,b)->a[0] -b[0]);
        int st = intervals[0][0];
        int end = intervals[0][1];
        int res = 0;
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i][0] <= end){
                end = Math.max(end, intervals[i][1]);
            }
            else{
                intervals[res][0] = st;
                intervals[res++][1] = end;
                st = intervals[i][0];
                end = intervals[i][1];
            }
        }
        intervals[res][0] = st;
        intervals[res++][1] = end;
        return Arrays.copyOf(intervals, res);
    }
}
```

## 16、* 单调递增的数字

### ①、[题目链接](https://leetcode.cn/problems/monotone-increasing-digits/)

当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。

给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。

 

示例 1:

输入: n = 10
输出: 9
示例 2:

输入: n = 1234
输出: 1234
示例 3:

输入: n = 332
输出: 299


提示:

0 <= n <= 109

### ②、思路

找到该减1的位置：第一个波峰的第一个元素

后边补9

### ③、代码

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        char[] arr = String.valueOf(n).toCharArray();
        int i = 0;
        //找到最后一个非降元素
        while(i < arr.length -1 && arr[i] <= arr[i +1]){
            i++;
        }
        //最后一个非降元素不是最后一个，需要减小，否则不需要减小
        if(i < arr.length -1){
            //往回找相同元素，从第一个相同元素开始减
            while(i > 0 && arr[i] == arr[i -1]){
                i--;
            }
            //最高位减一
            arr[i] = --arr[i];
            //后边补9
            while(++i < arr.length){
                arr[i] = '9';
            }
        }
        return Integer.parseInt(String.valueOf(arr));
    }
}
```



## 17、* 买卖股票的最佳时机含手续费

### ①、[题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

示例 1：

输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
示例 2：

输入：prices = [1,3,7,5,10,3], fee = 3
输出：6


提示：

1 <= prices.length <= 5 * 104
1 <= prices[i] < 5 * 104
0 <= fee < 5 * 104



### ②、思路

为小跌设置亏损线，价格低于亏损线在之前的高峰卖，在今天买入；

故开始跌的时候不算钱，因为可能在高峰就卖了；



### ③、代码

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int sum = 0;
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < prices.length; i++){
            //比买入那天还要低，换今天买；或者比亏损线还低，就直接换今天买
            if(prices[i] < min){
                min = prices[i];
            }
            //赚钱了，先算钱，给之后的价格设置一个亏损线
            else if(prices[i] > min + fee){
                sum += prices[i] -min -fee;
                min = prices[i] -fee;
            }
            //小跌就不算钱了，如果还在亏损线上就持仓
        }
        return sum;
    }
}
```



## 18、*监控二叉树

### ①、[题目链接](https://leetcode.cn/problems/binary-tree-cameras/)

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

 

示例 1：



输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
示例 2：



输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。

提示：

给定树的节点数的范围是 [1, 1000]。
每个节点的值都是 0。



### ②、思路

一层放，一层不放，叶子层不放，叶子层父节点放最贪心，下有叶子，上大概率有父节点

由于叶子不一定都在同一层，因此不能使用层序遍历，故使用后序遍历

如何判断当前结点放不放？

若孩子**有没被覆盖** 0 | 0，当前结点应该**有摄像头** 1；

若孩子**有摄像头** 1 | 1，当前结点**被覆盖** 2；

否则当前结点应该是**未被覆盖**，即状态0



故有三种状态，被覆盖的 2，不被覆盖的 0，有摄像头的 1；

空值如何处理？

叶子不能放，也没有被覆盖，即状态0

所以空值不能是0状态，也不能是1状态，只能是2状态



### ③、代码

```java
class Solution {
    private int res = 0;
    public int minCameraCover(TreeNode root) {
        if(help(root) == 0){
            res++;
        }
        return res;
    }
    public int help(TreeNode cur){
        if(cur == null){
            return 2;
        }
        int l = help(cur.left);
        int r = help(cur.right);
        if(l == 0 || r == 0){
            res++;
            return 1;
        }
        if(l == 1 || r == 1){
            return 2;
        }
        return 0;
    }
}
```



