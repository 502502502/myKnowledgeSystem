### 1、冒泡、插入、选择

从左到右依次比较相邻的两个元素，如果左边的元素大于右边的元素，就交换它们的位置，这样一趟下来，最大的元素就会被移动到最右边。然后重复这个过程，直到所有元素都有序为止

```java
// 冒泡排序
public static void bubbleSort(int[] arr) {
    // 参数检查
    if (arr == null || arr.length <= 1) {
        return;
    }
    // 外层循环控制趟数，每趟将一个最大元素移动到最右边
    for (int i = 0; i < arr.length - 1; i++) {
        // 内层循环控制比较次数，每次比较相邻两个元素并交换位置
        for (int j = 0; j < arr.length - 1 - i; j++) {
            // 如果左边元素大于右边元素，交换位置
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```


从左到右依次取出每个元素，将它插入到已经有序的左边部分中，这样一趟下来，左边部分就多了一个有序元素。然后重复这个过程，直到所有元素都有序为止

```java
// 插入排序
public static void insertionSort(int[] arr) {
    // 参数检查
    if (arr == null || arr.length <= 1) {
        return;
    }
    // 外层循环控制取出元素的位置，从第二个元素开始
    for (int i = 1; i < arr.length; i++) {
        // 内层循环控制插入位置的寻找，从右向左比较
        int temp = arr[i]; // 保存当前要插入的元素
        int j = i - 1; // 指向已经有序的最后一个元素
        while (j >= 0 && arr[j] > temp) { // 如果当前元素大于要插入的元素，就将其后移一位
            arr[j + 1] = arr[j];
            j--;
        }
        // 找到了合适的插入位置，将要插入的元素放在那里
        arr[j + 1] = temp;
    }
}
```


每次从未排序的元素中选出最小（或最大）的一个元素，放在已排序的元素的末尾，直到所有元素都排好序

```java
	public static void selectionSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) { // 外层循环控制需要进行多少趟比较
            int minIndex = i; // 假设每趟开始时，最小值的索引为i
            for (int j = i + 1; j < arr.length; j++) { // 内层循环从i+1开始，找出最小值的索引
                if (arr[j] < arr[minIndex]) { // 如果发现比假设的最小值还小的元素
                    minIndex = j; // 更新最小值的索引为j
                }
            }
            if (minIndex != i) { // 如果最小值不是原来假设的那个元素
                int temp = arr[i]; // 交换两个元素的位置
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }
```



### 2、归并、快排、堆排

将一个数组分成两个子数组，对每个子数组进行排序，然后将两个有序的子数组合并成一个有序的数组

```java
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {8, 4, 5, 7, 1, 3, 6, 2}; // 定义一个待排序的数组
        int[] temp = new int[arr.length]; // 定义一个临时数组，用于存放合并结果
        mergeSort(arr, 0, arr.length - 1, temp); // 调用归并排序方法
        for (int num : arr) { // 遍历并打印数组
            System.out.print(num + " ");
        }
    }

    public static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) { // 如果左边界小于右边界，说明还可以继续分割
            int mid = (left + right) / 2; // 计算中间位置
            mergeSort(arr, left, mid, temp); // 对左半部分进行递归排序
            mergeSort(arr, mid + 1 , right , temp); // 对右半部分进行递归排序
            merge(arr , left , mid , right , temp); // 将两个有序的子数组合并为一个有序的数组
        }
    }

    public static void merge(int[] arr , int left , int mid , int right , int[] temp) {
        int i = left; // 左边子数组的起始位置
        int j = mid + 1; // 右边子数组的起始位置
        int t = 0; // 临时数组的起始位置

        while (i <= mid && j <= right) { // 当左右两个子数组都还有元素时，比较它们的大小，并按顺序放入临时数组中
            if (arr[i] <= arr[j]) { // 如果左边元素小于等于右边元素，将左边元素放入临时数组，并移动指针到下一位
                temp[t++] = arr[i++];
            } else { // 否则，将右边元素放入临时数组，并移动指针到下一位
                temp[t++] = arr[j++];
            }
        }

        while (i <= mid) { // 当左边子数组还有剩余元素时，将它们全部放入临时数组中，并移动指针到下一位
            temp[t++] = arr[i++];
        }

        while (j <= right) { // 当右边子数组还有剩余元素时，将它们全部放入临时数组中，并移动指针到下一位
            temp[t++] = arr[j++];
        }

        t = 0; // 将临时变量重置为0

        while(left <= right){ // 将临时变量中存储的有序数据拷贝回原来的arr中[left,right]
            arr[left++] = temp[t++];
         }
    }
}
```



选择一个中心元素，将数组划分成两个子数组，左边的元素都比中心元素小，右边的元素都比中心元素大，然后对两个子数组递归地进行快速排序

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {8, 4, 5, 7, 1, 3, 6, 2}; // 定义一个待排序的数组
        quickSort(arr , 0 , arr.length - 1); // 调用快速排序方法
        for (int num : arr) { // 遍历并打印数组
            System.out.print(num + " ");
        }
    }

    public static void quickSort(int[] arr , int left , int right) {
        if (left < right) { // 如果左边界小于右边界，说明还可以继续分割
            int pivot = partition(arr , left , right); // 调用划分方法，返回中心元素的位置
            quickSort(arr , left , pivot - 1); // 对左半部分进行递归排序
            quickSort(arr , pivot + 1 , right); // 对右半部分进行递归排序
        }
    }

    public static int partition(int[] arr , int left , int right) {
        int pivot = arr[right]; // 取最后一个元素作为中心元素
        int i = left; // 定义一个变量i指向左边界

        for (int j = left; j < right; j++) { // 遍历从左边界到右边界之前的所有元素
            if (arr[j] < pivot) { // 如果当前元素小于中心元素，则将其与i位置上的元素交换，并将i向右移动一位
                swap(arr , i++ , j);
            }
        }

        swap(arr , i , right); // 最后将i位置上的元素与中心元素交换，并返回i作为中心元素的位置

        return i;
    }

    public static void swap(int[] arr , int i , int j) {
        int temp = arr[i]; // 定义一个临时变量，用于存放交换时的值
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```



我可以帮你用Java写一个堆排序。堆排序是一种树形选择排序方法，它的思想是：将数组看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中父节点和子节点之间的关系，在当前无序区中选择最大（或最小）的元素，然后交换到数组末尾，缩小无序区范围，重复这个过程，直到整个数组有序¹²³。下面是一个用Java实现的堆排序的代码¹⁴：

```java
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {4, 6, 8, 5, 9}; // 定义一个待排序的数组
        heapSort(arr); // 调用堆排序方法
        for (int num : arr) { // 遍历并打印数组
            System.out.print(num + " ");
        }
    }

    public static void heapSort(int[] arr) {
        int len = arr.length; // 获取数组长度

        // 构建初始大顶堆，从最后一个非叶子节点开始调整
        for (int i = len / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, len);
        }

        // 循环交换堆顶元素和末尾元素，并重新调整堆结构
        for (int j = len - 1; j > 0; j--) {
            swap(arr, 0, j); // 将堆顶元素与末尾元素交换
            adjustHeap(arr, 0, j); // 将剩余元素重新调整为大顶堆
        }
    }

    public static void adjustHeap(int[] arr, int i, int len) {
        int temp = arr[i]; // 取出当前节点的值

        // 遍历当前节点的左右子节点，找出最大值并替换父节点
        for (int k = i * 2 + 1; k < len; k = k * 2 + 1) {
            if (k + 1 < len && arr[k] < arr[k + 1]) { // 如果右子节点存在且大于左子节点，则将k指向右子节点
                k++;
            }
            if (arr[k] > temp) { // 如果子节点大于父节点，则将子节点赋值给父节点，并继续往下遍历
                arr[i] = arr[k];
                i = k;
            } else { // 否则说明已经调整好了，退出循环
                break;
            }
        }

        arr[i] = temp; // 最后将原来的父节点值赋值给最终位置上的元素，完成一次调整操作
    }

    public static void swap(int[] arr, int a ,int b) {
       int temp=arr[a];
       arr[a]=arr[b];
       arr[b]=temp;
   }
}
```





### 3、希尔、桶排

希尔排序是一种改进的插入排序，它的思想是先定义一个增量，将数组按照增量分成若干组，对每组进行插入排序，然后逐渐减小增量，直到增量为1时，整个数组就变成了有序的

```java
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6}; // 定义一个待排序的数组
        shellSort(arr); // 调用希尔排序方法
        for (int num : arr) { // 遍历并打印数组
            System.out.print(num + " ");
        }
    }

    public static void shellSort(int[] arr) {
        int len = arr.length; // 获取数组长度
        int gap = len / 2; // 定义初始增量为数组长度的一半

        while (gap > 0) { // 当增量大于0时，继续循环
            for (int i = gap; i < len; i++) { // 遍历从增量位置开始到数组末尾的所有元素
                int j = i; // 定义一个变量j指向当前元素位置
                int temp = arr[j]; // 定义一个临时变量存放当前元素值

                while (j - gap >= 0 && temp < arr[j - gap]) { // 如果j减去增量位置还在有效范围内，并且当前元素值小于前面对应位置上的元素值，则进行交换，并将j向前移动一个增量位置
                    arr[j] = arr[j - gap];
                    j -= gap;
                }

                arr[j] = temp; // 最后将临时变量赋值给j位置上的元素，完成一次插入操作
            }

            gap /= 2; // 缩小增量为原来的一半，继续下一轮循环
        }
    }
}
```



桶排序是一种将待排序数组中的元素划分为多个桶（范围段），对每个桶分别进行排序，然后将多个桶组合即为排序结果的方法²⁴。它假设输入数据服从均匀分布，所以它的时间复杂度为O(n)⁵。

```java
public class BucketSort {
    public static void main(String[] args) {
        int[] arr = {4, 6, 8, 5, 9}; // 定义一个待排序的数组
        bucketSort(arr); // 调用桶排序方法
        for (int num : arr) { // 遍历并打印数组
            System.out.print(num + " ");
        }
    }

    public static void bucketSort(int[] arr) {
        int max = Integer.MIN_VALUE; // 定义一个最大值变量，用于存放数组中的最大值
        int min = Integer.MAX_VALUE; // 定义一个最小值变量，用于存放数组中的最小值

        // 遍历数组，找出最大值和最小值
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
            min = Math.min(min, arr[i]);
        }

        // 计算桶的数量，每个桶存放10个数值范围内的元素
        int bucketNum = (max - min) / 10 + 1;

        // 创建一个二维列表，表示多个桶，每个桶是一个列表
        ArrayList<ArrayList<Integer>> bucketList = new ArrayList<>(bucketNum);

        // 初始化每个桶为空列表
        for (int i = 0; i < bucketNum; i++) {
            bucketList.add(new ArrayList<>());
        }

        // 遍历数组，将每个元素放入对应的桶中
        for (int i = 0; i < arr.length; i++) {
            int index = (arr[i] - min) / 10; // 计算元素应该放入哪个桶
            bucketList.get(index).add(arr[i]); // 将元素添加到对应的桶中
        }

        // 对每个非空的桶进行排序，并将排好序的元素依次放回原数组中
        int k = 0; // 定义一个指针变量，用于记录原数组中待插入位置

       for (int i = 0; i < bucketNum; i++) { 
           if (!bucketList.get(i).isEmpty()) { 
               Collections.sort(bucketList.get(i)); 
               for (int j : bucketList.get(i)) { 
                   arr[k++] = j;
               }
           }
       }
    }
}
```





### 4、二叉树、平衡树、查找树





### 5、B+树、B树





### 6、红黑树、字典树





### 7、List、Map、Set



